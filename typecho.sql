-- MySQL dump 10.13  Distrib 5.6.21, for linux-glibc2.5 (x86_64)
--
-- Host: localhost    Database: typecho
-- ------------------------------------------------------
-- Server version	5.6.21-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `typecho_comments`
--

DROP TABLE IF EXISTS `typecho_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_comments`
--

LOCK TABLES `typecho_comments` WRITE;
/*!40000 ALTER TABLE `typecho_comments` DISABLE KEYS */;
INSERT INTO `typecho_comments` VALUES (2,34,1427762510,'wpBy2',0,1,'531180739@qq.com',NULL,'10.251.244.169','Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2267.0 Safari/537.36','感谢分享……在微信公共号知道这里的，忘更新下去','comment','approved',0),(3,34,1427850257,'run',1,1,'727271755@qq.com','http://blog.chromev.com','10.251.244.169','Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36','必须的','comment','approved',2),(4,41,1433853267,'梁二妮儿',0,1,'119331@supinfo.com',NULL,'10.251.244.169','Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.81 Safari/537.36','很全面，谢谢！ ','comment','approved',0),(5,109,1450078989,'wfuser',0,1,'louyefenglin@qq.com','http://www.freepik.com/','198.1.184.76','Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36','一个精彩的FREE图片站','comment','spam',0);
/*!40000 ALTER TABLE `typecho_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_contents`
--

DROP TABLE IF EXISTS `typecho_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` text,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=150 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_contents`
--

LOCK TABLES `typecho_contents` WRITE;
/*!40000 ALTER TABLE `typecho_contents` DISABLE KEYS */;
INSERT INTO `typecho_contents` VALUES (2,'关于','about',1425551700,1451878735,'<!--markdown-->Run 80后\r\n\r\n你必须非常努力,才能看起来毫不费力\r\n\r\n\r\n玩Linux,c,python,php,javascript\r\n\r\n有兴趣加群 linux,php,symfony2 交流群 **139731083**\r\n\r\n除非文章内特别说明，你可以转载RUN的文章，但请加入文章作者和出处。谢谢。',5,1,NULL,'page','publish',NULL,0,'1','1','1',0),(17,'shell编写git commit -am \'\' ','17',1426594620,1426671131,'<!--markdown-->git修改文件多的，需要git commit -m \'\' -a\r\n\r\n突然想起shell也可以，不过还要优化\r\n\r\n```shell\r\n#!/bin/bash\r\n\r\nargc=$#\r\n\r\nlines=$(git status | awk -F \':\'  \'/\\.[php|css|js|jpg|jpeg|html|htm|png|swf|gif]/{print $2}\')\r\n#echo $lines\r\nfor line in $lines\r\n>---do  echo $lines;git add $line;\r\ndone\r\n\r\nif [$argc > 0]; then\r\n>---git commit -m $1\r\nfi\r\ngit status\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(6,'tomcat的solr安装配置,支持中文分词IK Analyzer,支持MYSQL数据库索引','6',1426433700,1427378587,'<!--markdown-->环境 java,tomcat,solr,mysql\r\n\r\n### 一java安装\r\n```shell\r\nyum install java\r\njava -version\r\n```\r\n\r\n\r\n### 二tomcat安装配置\r\n下载地址 http://tomcat.apache.org/download-70.cgi \r\n解压缩\r\n```shell\r\ntar -C /usr/local -zxf /usr/local/src/apache-tomcat-7.*.tar.gz\r\nmv /usr/local/apache-tomcat-7* /usr/local/tomcat\r\nsudo sed -i s/8080/8983/g /usr/local/tomcat/conf/server.xml\r\n```\r\n添加用户\r\n```shell\r\nuseradd -Mb /usr/local tomcat\r\nchown -R tomcat:tomcat /usr/local/tomcat\r\nsudo -u tomcat /usr/local/tomcat/bin/startup.sh\r\n```\r\n启动关闭\r\n```shell\r\n/usr/local/tomcat/bin/startup.sh\r\n/usr/local/tomcat/bin/shutdown.sh\r\n```\r\n\r\n### 三 solr安装\r\n最新版下载地址 http://apache.arvixe.com/lucene/solr/5.0.0/\r\n\r\n```python\r\ntar -zxf solr-5.0.0.tgz\r\ncp solr-5.0.0/dist/solrj-lib/* /usr/local/tomcat/lib/\r\ncp solr-5.0.0/example/resources/log4j.properties /usr/local/tomcat/conf/\r\ncp solr-5.0.0/dist/solr-.war /usr/local/tomcat/webapps/solr.war/dist/solr-5.0.0.war /usr/local/tomcat/webapps/solr.war\r\ncp /usr/local/src/solr-5.0.0/example/lib/ext/* /usr/local/tomcat/webapps/solr/WEB-INF/lib/\r\n```\r\n\r\n虚拟主机配置文件\r\n创建/usr/local/tomcat/conf/Catalina/localhost/solr.xml 　\r\n```python\r\n<Context docBase=\"/usr/local/tomcat/webapps/solr.war\" debug=\"0\" crossContext=\"true\">\r\n  <Environment name=\"solr/home\" type=\"java.lang.String\" value=\"/usr/local/tomcat/solr\" override=\"true\" />\r\n</Context>\r\n```\r\n\r\n创建solr索引目录,solr所有的数据在这个目录(相当于应用程序目录)\r\n把官方的测试数据collection1拷贝过来看下\r\n```python\r\nmkdir -p /usr/local/tomcat/solr\r\ncp -r solr-5.0.0/example/solr/collection1/conf /usr/local/tomcat/solr/\r\n```\r\n\r\n重新启动tomcat，测试http://ip:port/solr看下\r\n![solr1.png][1]\r\n\r\n\r\n看到如图表示成功\r\n\r\n\r\n### 四solr中文分词 IK Analyzer配置\r\n还有个分词库 mmseg4j分词\r\n[源下载地址][2]\r\n\r\n解压缩\r\n```python\r\nunzip IK Analyzer 2012FF_hf1.zip -d /tmp\r\n```\r\n拷贝需要的文件到tomcat的solr虚拟应用程序目录\r\n```python\r\ncp IKAnalyzer2012FF_u1.jar /usr/local/tomcat/webapps/solr/WEB-INF/lib\r\ncp IKAnalyzer.cfg.xml /usr/local/tomcat/webapps/solr/WEB-INF/classes\r\ncp stopword.dic /usr/local/tomcat/webapps/solr/WEB-INF/classes\r\n```\r\n\r\n修改应用程序solr的配置文件 /usr/local/tomcat/solr/conf/schema.xml文件使它支持中文分词\r\n```\r\n<fieldType name=\"text_ik\" class=\"solr.TextField\">\r\n<analyzer class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/>\r\n</fieldType>\r\n```\r\n看下![solr2.png][3]\r\n\r\n### 五 solr支持数据源mysql，及生成索引库\r\n默认是xml的数据源\r\n\r\n1.solr官方是提供一个工具的—Data Import Handler\r\n找到源码包的\r\n${SOLR_SRC}\\dist\\solr-dataimporthandler-4.9.0.jar\r\n${SOLR_SRC}\\dist\\solr-dataimporthandler-extras-4.9.0.jar\r\n将这两个jar包添加进web-inf/lib中\r\ncp ${SOLR_SRC}\\dist\\solr-dataimporthandler-4.9.0.jar /usr/local/tomcat/webapps/solr/WEB-INF/lib\r\n\r\n2.solr安装mysql驱动\r\n在[http://www.oracle.com/][4]官方下载 mysql-connector-java-5.1.25-bin.jar\r\ncp  mysql-connector-java-5.1.25-bin.jar /usr/local/tomcat/webapps/solr/WEB-INF/lib\r\n\r\n3.配置mysql源\r\n修改solrconfig.xml导入mysql的jar包\r\n```\r\n<lib dir=\"../contrib/dataimporthandler/lib\" regex=\".*\\.jar\" />\r\n<lib dir=\"../dist/\" regex=\"solr-dataimporthandler-\\d.*\\.jar\" />\r\n```\r\n配置dataimporthandler\r\n```\r\n<requestHandler name=\"/dataimport\" class=\"org.apache.solr.handler.dataimport.DataImportHandler\">\r\n    <lst name=\"defaults\">\r\n        <str name=\"config\">data-config.xml</str>\r\n    </lst>\r\n</requestHandler>\r\n```\r\n添加data-config.xml及对应数据库和表\r\n```python\r\nDROP TABLE IF EXISTS `documents`; \r\nCREATE TABLE `documents` ( \r\n  `id` int(11) NOT NULL auto_increment, \r\n  `date_added` datetime NOT NULL, \r\n  `title` varchar(255) NOT NULL, \r\n  `content` text NOT NULL, \r\n  PRIMARY KEY  (`id`) \r\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; \r\n-- ---------------------------- \r\n-- Records of documents \r\n-- ---------------------------- \r\nINSERT INTO `documents` VALUES (\'1\', \'2012-01-11 23:15:59\', \'world\', \'test1\'); \r\nINSERT INTO `documents` VALUES (\'2\', \'2012-01-11 23:16:30\', \'hello\', \'test\'); \r\nINSERT INTO `documents` VALUES (\'3\', now(), \'hello12\', \'test\'); \r\nINSERT INTO `documents` VALUES (\'4\', now(), ‘我们’, \'test\');\r\n```\r\n```xml\r\n<dataConfig>\r\n   <dataSource type=\"JdbcDataSource\"-\r\n              driver=\"com.mysql.jdbc.Driver\"\r\n              url=\"jdbc:mysql://127.0.0.1/test\"-\r\n              user=\"root\"-\r\n              password=\"\"/>\r\n   <document>\r\n		<entity name=\"documents\" query=\"SELECT id, content, title, date_added  FROM documents\" >\r\n			<field column=\"id\" name=\"id\" />-\r\n			<field column=\"content\" name=\"content\" />-\r\n			<field column=\"title\" name=\"hashcode\" />-\r\n			<field column=\"date_added\" name=\"updatetime\" />\r\n		</entity>\r\n   </document>\r\n</dataConfig>\r\n```\r\n\r\n4.修改solr配置文件schema.xml支持字段\r\n```mysql\r\n<field name=\"id\" type=\"string\" indexed=\"true\" stored=\"true\" required=\"true\" /> \r\n<field name=\"title\" type=\"text_general\" indexed=\"true\" stored=\"true\" termVectors=\"true\" termPositions=\"true\" termOffsets=\"true\"/> \r\n<field name=\"content\" type=\"text_general\" indexed=\"true\" stored=\"true\" termVectors=\"true\" termPositions=\"true\" termOffsets=\"true\"/> \r\n<field name=\"date_added\" type=\"date\" indexed=\"false\" stored=\"true\"/> \r\n```\r\n5.查看及测试\r\n导入mysql索引数据\r\n![solr4.png][5]\r\n点击Execute\r\n![solr5.png][6]\r\n查看状态\r\n![solr6.png][7]\r\n模拟搜索\r\n![solr7.png][8]\r\n成功!\r\n\r\n\r\n最终实现的计划 通过python抓取批量数据到mysql，然后solr生成实时索引，php实现前端搜索页面\r\n\r\n[博客地址][9] http://blog.chromev.com/archives/6/\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/03/3854896764.png\r\n  [2]: https://code.google.com/p/ik-analyzer/downloads/list\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/03/2963210938.png\r\n  [4]: http://dev.mysql.com/downloads/connector/j/\r\n  [5]: http://blog.chromev.com/usr/uploads/2015/03/204158441.png\r\n  [6]: http://blog.chromev.com/usr/uploads/2015/03/2956201324.png\r\n  [7]: http://blog.chromev.com/usr/uploads/2015/03/1856506501.png\r\n  [8]: http://blog.chromev.com/usr/uploads/2015/03/2923238375.png\r\n  [9]: http://blog.chromev.com/archives/6/',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(9,'solr1.png','solr1-png',1426470121,1426470121,'a:5:{s:4:\"name\";s:9:\"solr1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/3854896764.png\";s:4:\"size\";i:36602;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(11,'solr2.png','solr2-png',1426471832,1426471832,'a:5:{s:4:\"name\";s:9:\"solr2.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/2963210938.png\";s:4:\"size\";i:40039;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(12,'solr3.png','solr3-png',1426473277,1426473277,'a:5:{s:4:\"name\";s:9:\"solr3.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/03/813186842.png\";s:4:\"size\";i:15827;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(13,'solr4.png','solr4-png',1426473455,1426473455,'a:5:{s:4:\"name\";s:9:\"solr4.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/03/204158441.png\";s:4:\"size\";i:57963;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',4,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(14,'solr5.png','solr5-png',1426473508,1426473508,'a:5:{s:4:\"name\";s:9:\"solr5.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/2956201324.png\";s:4:\"size\";i:47965;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',5,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(15,'solr6.png','solr6-png',1426473540,1426473540,'a:5:{s:4:\"name\";s:9:\"solr6.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/1856506501.png\";s:4:\"size\";i:7814;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',6,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(16,'solr7.png','solr7-png',1426473598,1426473598,'a:5:{s:4:\"name\";s:9:\"solr7.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/03/2923238375.png\";s:4:\"size\";i:46719;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',7,1,NULL,'attachment','publish',NULL,0,'1','0','1',6),(18,'python抓取 豆瓣电影标签列表','18',1426764407,1426764407,'<!--markdown-->[原创]\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding:utf-8 -*-\r\n\r\n\r\nimport urllib\r\nimport urllib2\r\nimport re\r\nimport thread\r\nimport time\r\nimport MySQLdb\r\nimport os\r\n\r\nimport sys\r\nreload(sys)\r\nsys.setdefaultencoding(\'utf-8\')\r\n\r\nconstDebug = False\r\n\r\n\r\nkeyword = sys.argv[1]\r\nif not keyword:\r\n    print \'keyword is empty\'\r\n    exit()\r\n\r\n\r\n\r\nkeywordquote = urllib.quote_plus(keyword)\r\nperage = 20\r\nurl = \'http://movie.douban.com/tag/\'+str(keywordquote) #&start=0\r\n\r\n#print url\r\n\r\n#解码\r\n#print urllib.unquote_plus(\'%E7%A7%91%E5%B9%BB\')\r\n\r\n#加码\r\n#print urllib.quote_plus(\'科幻\')\r\n\r\n#测试模式\r\nif constDebug:\r\n    file = os.path.abspath(\'.\') + \'/tag_list.txt\'\r\n    with open(file) as f:\r\n        html = f.read()\r\n\r\n    unicodehtml = html.decode(\"utf-8\")\r\n\r\n\r\n\r\ndef url_get_html(url):\r\n    \'\'\'\r\n    headers = {\r\n        \'User-Agent\':\'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6\'\r\n    }\r\n    \'\'\'\r\n\r\n    opener = urllib2.build_opener(urllib2.ProxyHandler({\'http\':\'121.41.84.140:80\'}), urllib2.HTTPHandler(debuglevel=1))\r\n    urllib2.install_opener(opener)\r\n\r\n    headers = {\r\n               \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2327.5 Safari/537.36\",\r\n               \"Connection\":\'keep-alive\',\r\n               \"Cache-Control\":\"max-age=0\",\r\n               \"Referer\": \'http://www.baidu.com\'\r\n             }\r\n\r\n    #request = urllib2.Request(url)\r\n    request = urllib2.Request(\r\n        url = url,\r\n        headers = headers\r\n    )\r\n\r\n    print url\r\n\r\n    response = urllib2.urlopen(request)\r\n    html = response.read()\r\n    #return  html.decode(\"utf-8\")\r\n    return  html\r\n\r\n#非测试模式\r\nif not constDebug:\r\n    # 获取总的页数\r\n    unicodehtml = url_get_html(url)\r\n\r\n\r\n#print unicodehtml\r\n#exit()\r\n\r\n#获取总页数\r\ntotalr = re.compile(r\'data-total-page=\"(.*?)\"\', re.S)\r\nmatchs = totalr.findall(unicodehtml)\r\n\r\ntotal = 0\r\nif matchs:\r\n    total = int(matchs[0])\r\n\r\n\r\ndef match_content(htmls):\r\n    #内容匹配,  匹配 详细页,标题,缩略图,简介，评分,评价人数，\r\n\r\n    movies = []\r\n\r\n    #先匹配整个一部电影\r\n    patternstr = \'<tr\\s*class=\"item\">\\s*\'\r\n    #缩略图\r\n    patternstr += \'<td\\s*width=\"100\"\\s*valign=\"top\">\\s*<a.*?>\\s*<img\\s*src=\"(.*?)\".*?/>\\s*</a>\\s*</td>\\s*\'\r\n\r\n    #详细页,标题 标题还要替换一次\r\n    patternstr += \'<td\\s*valign=\"top\">\\s*<div class=\"pl2\">\\s*<a\\s*href=\"(.*?)\".*?>[\\s|\\r\\n]*(.*?)[\\s|\\r\\n]*</a>[\\s|\\r\\n|\\n]*\'\r\n\r\n    #简介\r\n    patternstr += \'(.*?)\'\r\n    \'\'\'\r\n    #评分\r\n    patternstr += \'\\s*<span\\s*class=\"rating_nums\">(.*?)</span>\'\r\n\r\n    #评价人数\r\n    patternstr += \'\\s*<span\\s*class=\"pl\">\\((.*?)\\)</span>\\s*</div>\\s*</div>\'\r\n    \'\'\'\r\n    patternstr += \'</td>\\s*\'\r\n    patternstr += \'</tr>\'\r\n    all = re.compile(r\'\'+ patternstr +\'\', re.S)\r\n    allm = all.findall(htmls)\r\n    #print allm\r\n    #exit()\r\n    for item in allm:\r\n        #print item[0] #缩略图地址\r\n        #print item[1] #详细页\r\n\r\n        # 标题\r\n        titletmp = re.sub(re.compile(r\'[\\r\\n|\\n|\\s*]\'), \'\', item[2])\r\n        titletmp = re.sub(re.compile(r\'<.*?>\'), \'\', titletmp)\r\n        #print titletmp\r\n\r\n        # 内容\r\n        introm = re.compile(r\'<p\\s*class=\"pl\">(.*?)</p>\', re.S)\r\n        introarr = introm.findall(item[3])\r\n        introstr = introarr[0]\r\n\r\n        # 评分\r\n        score = \'0\'\r\n        scorem = re.compile(r\'<span\\s*class=\"rating_nums\">(.*?)</span>\', re.S)\r\n        scorearr = scorem.findall(item[3])\r\n        if scorearr:\r\n            score = scorearr[0]\r\n\r\n        # 评分人数\r\n        score_num = \'0\'\r\n        scorenumm= re.compile(\'<span\\s*class=\"pl\">\\((.*?)\\)</span>\', re.S)\r\n        scorenumarr = scorenumm.findall(item[3])\r\n        if scorenumarr:\r\n            score_num = re.sub( re.compile(u\'[\\u4e00-\\u9fa5]+\'), \'\', scorenumarr[0] )\r\n\r\n        #print score_num\r\n        #exit()\r\n\r\n        # 评分\r\n        #print item[4]\r\n\r\n        # 评价人数\r\n        # score_num = re.sub( re.compile(u\'[\\u4e00-\\u9fa5]+\'), \'\',item[5] )\r\n        #print reviewnum\r\n\r\n        movies.append([titletmp, item[0], item[1], introstr, score, score_num])\r\n        #exit()\r\n    return movies\r\n\r\n\r\n# 连接数据库\r\ndbconn = MySQLdb.connect(host=\"localhost\", user=\"root\", passwd=\"\", db=\"scrapy\",charset=\"utf8\")\r\ncursor = dbconn.cursor()\r\n\r\n#取tagid\r\nksql = \"SELECT * FROM douban_tag WHERE tag_name=\'%s\'\" % (keyword)\r\n#print ksql\r\ntagid = 0\r\ntry:\r\n    cursor.execute(ksql)\r\n    data = cursor.fetchone()\r\n    tagid = data[0]\r\nexcept:\r\n    print \"Error: unable to fecth data\"\r\n\r\nfile = os.path.abspath(\'.\') + \'/tag_list_sql.txt\'\r\n\r\ndef insert_data( ms , start = 0):\r\n    global dbconn,cursor,tagid, tag_name\r\n    for m in ms:\r\n        #for i in range(0, 6):\r\n        #    print m[i]\r\n        #m[4] if m[4] is not None  else 0\r\n        #m[5] if m[5] is not None  else 0\r\n\r\n        for i in range(0, 6):\r\n            if not m[i]:\r\n                m[i] = 0\r\n\r\n        \'\'\'\r\n        if not m[4]:\r\n            m[4] = 0\r\n        if not m[5]:\r\n            m[5] = 0\r\n        \'\'\'\r\n\r\n        sql = \"INSERT INTO douban_movie( tag_id, tag_name, title, thumb_url, detail_url, intro, score, score_num, start) \"\r\n        sql += \" VALUES (\'%d\', \'%s\', \'%s\', \'%s\', \'%s\', \'%s\', \'%s\', \'%s\', \'%d\')\" % ( tagid, keyword, m[0], m[1], m[2], m[3], m[4], m[5], start)\r\n\r\n        try:\r\n            cursor.execute(sql)\r\n            dbconn.commit()\r\n        except Exception, e:\r\n            dbconn.rollback()\r\n\r\n            #写入日志\r\n            file_object = open(file, \'a+\')\r\n            file_object.write(sql+\'\\r\\n\')\r\n            file_object.close()\r\n\r\n            print \"MySQL Error %s: %s\" % (e.args[0], e.args[1])\r\n\r\n\r\n\r\n#提取单页内容数组\r\nms = match_content(unicodehtml)\r\n\r\n#加入数据库\r\ninsert_data( ms )\r\n\r\n\r\nif constDebug:\r\n    msnext = match_content(unicodehtml)\r\n    insert_data(msnext)\r\n    exit()\r\n\r\n\r\nif not constDebug:\r\n    print total\r\n    #入口 循环页面匹配\r\n    for i in range(334, total):\r\n        start = i*20\r\n        tmpurl = url + \'?start=\' + str(start)\r\n        #print url\r\n        #break\r\n        htmlconent = url_get_html(tmpurl)\r\n        msnext = match_content(htmlconent)\r\n        insert_data(msnext, start)\r\n        print i,start,tmpurl\r\n\r\ncursor.close()\r\n#关闭数据库连接\r\ndbconn.close()\r\n\r\n\r\n\r\n#print movies\r\n\'\'\'\r\n#标题， start\r\ntitle = re.compile(r\'<div class=\"pl2\">.*?<a href=\"(.*?)\".*?>(.*?)</a>\', re.S)\r\ntitlematch = title.findall(htmls)\r\n\r\nfor item in titlematch:\r\n    #处理\\r\\n及html字符\r\n    titletmp = re.sub(re.compile(r\'[\\r\\n|\\n|\\s*]\'), \'\', item[1])\r\n    titletmp = re.sub(re.compile(r\'<.*?>\'), \'\', titletmp)\r\n\r\n    movies.append([item[0],titletmp])\r\n\r\n#缩略图 start\r\nthumb = re.compile(r\'\', re.S)\r\n\'\'\'\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(19,'每一个程序员都应当了解的11句话','19',1426765140,1426765361,'<!--markdown-->英文原文：11 Rules All Programmers Should Live By\r\n### 1. 技术只是解决问题的选择，而不是解决问题的根本\r\n\r\n　　我们可以因为掌握了最新的 JavaScript 框架 ahem、Angular 的 IoC 容器技术或者某些编程语言甚至操作系统而欢欣雀跃，但是这些东西并不是作为程序员的我们用来解决问题的根本——它们只是用于帮助我们解决问题的简单工具。\r\n\r\n　　我们必须非常谨慎，不要对某项正好喜欢或者正好很火的特定技术走火入魔。否则，我们将进入这样的思维怪圈：把掌握的那项技术比做是锤子，在思考问题时，会自然的把所有的问题都想象成是锤子可以解决的钉子。\r\n\r\n### 2. 聪明是代码清晰的敌人\r\n\r\n　　当编写代码时，我们应当努力做到代码清晰易理解。\r\n\r\n　　虽然这句话并不总是正确的，但在一般情况下，聪明确实是代码清晰的敌人。\r\n\r\n　　事实证明，当我们写一段自认为非常了不起的代码的时候，这些代码在别人眼里可能会是一头雾水。\r\n\r\n　　所以当你在编写某段聪明高效的代码的时候牢牢记住这个原则是很有必要的。\r\n\r\n　　如果你对如何编写整洁清晰的代码很感兴趣的话，我强烈推荐你看罗伯特·C·马丁的书《The Clean Coder: A Code of Conduct for Professional Programmers》。\r\n\r\n### 3. 写尽可能少的代码\r\n\r\n　　这句话看起来有一些矛盾。程序员的工作不就是编写代码么？\r\n\r\n　　嗯，是的但也不是。\r\n\r\n　　我们的工作需要我们编写代码，但是我们在尝试解决问题的时候应当做到尽量编写更少的代码。\r\n\r\n　　这并不意味着我们需要尽量把代码写得更紧凑或者把所有的变量都使用单个字母。它的意思是我们应当尝试用更精简的算法来实现所需要实现的功能。\r\n\r\n　　通常情况下，我们在代码中所添加的各种很酷的特性是非常诱人的，这还能让我们的代码看起来更“健壮”和“灵活”，能够处理各种不同类型的情况。但是，在更多的时候，我们尝试更多可能有用的特性或者预防可能在未来存在的问题的做法是错误的。这些额外的代码可能不具备任何的价值，但是却可能造成更多的伤害。因为代码越多，出现未知错误的机会就越多，代码的维护也更加的麻烦。\r\n\r\n　　优秀的软件工程师写尽可能少的代码。\r\n\r\n　　伟大的软件工程师删除尽可能多的代码。\r\n\r\n### 4. 注释是代码表述的最后选择\r\n\r\n　　鲍勃·马丁曾经说过：“当你在为一段代码写注释的时候，你应当对自己糟糕的表达能力而反思。”\r\n\r\n　　这并不意味着我们以后就不要写注释了。但在大多数情况下这种情况是可以避免的，你可以选择用更好的命名方式来取代它。\r\n\r\n　　只有在使用命名都无法表述清楚某个方法或者变量的目的时，注释才是最后的选择。事实上，表达无法轻易在代码表达的东西才是注释的真正作用。\r\n\r\n　　举个例子，注释可以告诉你在代码中的那些奇怪的操作命令并不是一个错误，而是故意的，那是因为在底层操作系统存在着某个 bug。\r\n\r\n　　虽然在一般情况下，许多注释还是非常有用的，但是却存在着误导的风险。\r\n\r\n　　在其它代码更新后，与某些更新前代码相关的注释常常会得不到同样的更新，这就导致了某些注释会变得非常的危险，它们很可能会把你引导到一个错误的方向。\r\n\r\n　　你检查过与代码密切相关的每一段注释么？是否确保代码都是在按照注释所说的那样做？如果你都照着这样做了，那么注释的意义又何在呢？如果你没有这样做，你又怎么知道注释说的都是真的？\r\n\r\n　　所以，注释的作用并不象所宣扬的那么好，这种东西切勿滥用。\r\n\r\n### 5. 在编写代码之前你应当清楚你的代码要做什么\r\n\r\n　　这看起来是理所当然的，但实际情况却不是。\r\n\r\n　　现实工作中你有多少次是在没有经过充分了解到你的代码要干些什么就开始着手编程的？反正对于我来说，是不计其数了，所以我把这条记录下来用来随时提醒我。\r\n\r\n　　测试驱动开发(TDD)的实践在这里可以帮助你，因为你需要在编写代码之前了解这些代码将要用于什么地方，虽然这仍然不能阻止你创建错误的东西，但是它仍然非常重要。所以当你完完全全了解需要构建的需求和功能时，再动手编程。\r\n\r\n### 6. 提交完成代码之前先自行测试\r\n\r\n　　不要在完成编程工作后，就把代码扔给 QA，然后就坐等消息了。这样会浪费每一个参加处理不必要 Bug 和问题的人的时间。你应当在报告编程工作完成之前，花费几分钟时间运行测试场景进行自我检测。当然，在你把代码提交给 QA 之前不一定会发现每一个 Bug，但至少你可以杜绝一些我们每个人都可能犯下的愚蠢低级错误。\r\n\r\n　　很多的软件开发人员认为测试代码只是 QA 人员的工作。这是不对的。保持质量是我们每个人的责任。\r\n\r\n### 7. 每天都要学一些新东西\r\n\r\n　　有句名言“刀不磨要生锈，人不学要落后。”这句话是很有道理的，因为无论是否获取到新的知识，你每天都会遗忘掉一些以前的东西。 \r\n\r\n　　每天学些一些新东西并不会花费掉你很多的时间。试着每天用 15 分钟时间去读书，然后你就会发现每天你都会有一点点的进步，在未来的某个时候，你会发现这种进步是巨大的。因此，为了在今后获得丰厚回报你必须从现在开始就进行投资。另外，今天的技术发展日新月异，如果你不改善自己的技巧，学习新的东西，你很快就会被甩开。\r\n\r\n### 8. 写代码应该成为一种乐趣\r\n\r\n　　这是非常正确的。或许，你进入这个行业仅仅是因为它的薪水可观。选择一份报酬丰厚的工作这并没有错，但是还有更好的选择，比如医生或者律师。事实上很多人选择做软件开发还有一个原因，那就是他们喜欢写代码。在你被工作压力所累的时候，不要忘了你选择这份职业的初衷。\r\n\r\n　　编写代码可以带来很大的乐趣。多年的时间里，很多人可能都已经遗忘了这一点，那么从现在起，重新唤回以前的那份热情吧，从身边的项目开始，把你的观念和意识转换到以前你开始学习编程的那个时刻。\r\n\r\n### 9. 你不需要无所不知\r\n\r\n　　在你学到了很多知识的时候，你仍然有很多东西不知道。\r\n\r\n　　意识到这点很重要，因为它可以驱使你去了解更多更多的东西。\r\n\r\n　　不知道问题的所有答案没有关系，不了解某个东西说出来并寻求帮助也无关紧要。在很多情况下，你可以选择现学现用——相信我，我就是这么走过来的。\r\n\r\n　　我的观点是，不要企图去学习所有的知识，因为这是一个不可能完成的任务。你需要关注和掌握的是能够帮助你快速学习的技巧。\r\n\r\n### 10. 最佳的实践视环境而定\r\n\r\n　　测试驱动开发最好的方法是先编写测试代码？\r\n\r\n　　我们应该保持结对编程的习惯？\r\n\r\n　　如果不使用 IoC 容器是否会低人一等？\r\n\r\n　　所有这些问题的答案是“看情况。”这取决于所处的实际环境。\r\n\r\n　　人们试图把最佳的实践通过喉咙等方式传输给你，他们会告诉你，他们平时都是这样应用的。所以，你也应该这样做——这其实并不正确。\r\n\r\n　　在写代码的时候，我也借鉴过不少别人的成功经验。但是，这些借鉴都是有条件的。\r\n\r\n　　知识是死的，人是活的。最好的实践需要视环境而定。\r\n\r\n### 11. 努力做到化繁为简\r\n\r\n　　所有的的问题都可以进行分解。而最优雅的解决方案通常都非常简单。但是，要变得简单并不容易，这需要许多的工作。\r\n\r\n　　比如，这篇文章的目的是从复杂的软件开发工作和日常生活中提取经验，通过归纳，以较简洁的方式呈现给大家，而这并不是一件容易的事情。\r\n\r\n　　在解决问题时，可以先找到一个较为复杂的笨方法。在此基础上进行努力改进和提炼，使它在正确的基础上变得简单。这需要花费很多时间和努力，而人类不正是因为这个过程才慢慢变得聪明么？',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(20,'php接口','20',1426821120,1426821293,'<!--markdown-->```PHP\r\n\r\n#!/usr/bin/env php \r\n<?php\r\n\r\n\r\n$url=\"xxxxx\";\r\n\r\n$key = \'20f98131b012c3dde419aa7f02f44903\';\r\n$timestamp = time();\r\n$random = rand(1000, 9999);\r\n$arr = array($key, $timestamp, $random);\r\nsort($arr);\r\n$signature = sha1(implode(\'\', $arr));\r\n\r\n#print $signature \r\n#$url .= \'?signature=\'.$signature.\'&timestamp=\'.$timestamp.\'&random=\'.$random;\r\n#print $url;\r\n\r\n$arr = array(\r\n        \'signature\'=>$signature,\r\n        \'timestamp\'=>$timestamp,\r\n        \'random\'=>$random,\r\n        \'number\'=>$argv[1]\r\n);\r\n\r\n$url = $url.\'?\'.http_build_query($arr);\r\nprint $url;\r\n$ch = curl_init();\r\ncurl_setopt($ch, CURLOPT_URL, $url);\r\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\r\ncurl_setopt($ch, CURLOPT_USERAGENT, \"CURL Example beta\");\r\n$data = curl_exec($ch);\r\ncurl_close();\r\n\r\nprint_r($data);\r\n\r\n```\r\n\r\n模拟请求\r\nphp xx.php 1\r\n\r\n处理请求\r\n```php\r\n<?php\r\n\r\n/**\r\n * yx 查询编号或手机号是否存在接口\r\n */\r\n\r\nclass yxAction extends LsAPIAction\r\n{\r\n    const APP_KEY = \'20f98131b012c3dde419aa7f02f44903\';\r\n    const API_URL = \'http://api.365jia.cn/ports/yx\';\r\n\r\n    public function processMain()\r\n    {\r\n        $signature = $this->getRequestParameter(\'signature\');\r\n        $timestamp = $this->getRequestParameter(\'timestamp\');\r\n        $random = $this->getRequestParameter(\'random\'); // 4位随机数\r\n        $number = $this->getRequestParameter(\'number\');\r\n\r\n        if(empty($number)){\r\n            echo \'Denied!!\';\r\n            exit();\r\n        }\r\n\r\n        $arr = array($timestamp, $random, self::APP_KEY);\r\n        sort($arr);\r\n        $key = implode(\'\', $arr);\r\n        if( $signature ==  sha1($key) ){\r\n            if(preg_match(\'/^\\d+$/\', $number)){\r\n                $c = new Criteria();\r\n                //是否手机号\r\n                $reg = \"/^0?(13[0-9]|15[012356789]|18[012356789]|14[57])[0-9]{8}$/\";\r\n                if( preg_match($reg, $number) ) {\r\n                    $c->add(SpecialVoteCommonPeer::OTHER7, $number);\r\n                }else{\r\n                    $c->add(SpecialVoteCommonPeer::NUM, $number);\r\n                }\r\n                $ret = SpecialVoteCommonPeer::doSelectOne($c);\r\n                if(!empty($ret)){\r\n                    echo \'True\';\r\n                    exit;\r\n                }\r\n            }\r\n        }\r\n\r\n        echo \'Denied!!\';\r\n        exit();\r\n    }\r\n}\r\n\r\n\r\n```\r\n',0,1,NULL,'post','hidden',NULL,0,'1','1','1',0),(21,'centos安装redis及php扩展redis安装','21',1426855680,1426919970,'<!--markdown-->### redis简介\r\nredis是一款很不错的高性能的key-value数据库;它的出现在很大程度上弥补了很多像memcached这类的keyvalue存储的不足,它的特点有:支持持久化.半持久化数据保存,支持主从同步,value值支持多种类型等等;更多具体知识内容可以参照:http://redisbook.readthedocs.org/en/latest/  http://blog.jobbole.com/44476/这两篇,写的还是很不错的!!!!!\r\n\r\n### redis安装\r\n1. 下载Redis\r\n```shell\r\npwd\r\nwget http://download.redis.io/releases/redis-2.8.7.tar.gz\r\n```\r\n\r\n2编译安装Redis\r\n```shell\r\ntar xf redis-2.8.7.tar.gz\r\ncd redis-2.8.7\r\nmake\r\nmake install\r\n```\r\n\r\n3创建redis的配置文件\r\n```shell\r\nmkdir /etc/redis\r\ncp redis.conf /etc/redis/redis.conf\r\n```\r\n\r\n4. 调整下内存分配使用方式并使其生效\r\n```shell\r\necho \"vm.overcommit_memory=1\">>/etc/sysctl.conf\r\n#此参数可用的值为0,1,2\r\n  #0表示当用户空间请求更多的内存时，内核尝试估算出可用的内存\r\n  #1表示内核允许超量使用内存直到内存用完为止\r\n  #2表示整个内存地址空间不能超过swap+(vm.overcommit_ratio)%的RAM值\r\nsysctl-p\r\n```\r\n\r\n5. 修改redis配置文件(只列出大多数需要修改的项)\r\n```\r\nvim /etc/redis/redis.conf \r\ndaemonize   yes          #redis以守护进程的方式运行，no表示不以守护进程的方式运行(会占用一个终端)\r\ntimeout 300              #客户端闲置多长时间后断开连接，默认为0关闭此功能\r\nloglevel  verbose        #设置redis日志级别\r\nlogfile stdout           #设置日志文件的输出方式,如果以守护进程的方式运行redis并且日志输出设置为stdout,那么日志信息就输出到/dev/null里面去了\r\n```\r\n\r\n6. 启动redis并且制定redis的配置文件\r\n```\r\nredis-server /etc/redis/redis.conf\r\nnetstat -nltp\r\ntcp        0      0 0.0.0.0:6379                0.0.0.0:*                   LISTEN      325/redis-server *  \r\n```\r\n\r\n7. 登陆redis测试是否可用\r\n```\r\ncd redis-2.8.13/src\r\nredis-cli\r\n    set name run\r\n    get name   \r\n```\r\n\r\n8. 拷贝执行程序\r\n```\r\ncp redis-benchmark redis-cli redis-check-dump redis-server redis-sentinel redis-check-aof  /webserver/redis\r\n```\r\n9. 关闭redis服务\r\n```\r\n redis-cli shutdown\r\n```  \r\nredis服务关闭后，缓存数据会自动dump到硬盘上，硬盘地址为redis.conf中的配置项dbfilename dump.rdb所设定\r\n强制备份数据到磁盘，使用如下命令\r\n```\r\nredis-cli save 或者 redis-cli -p 6380 save（指定端口）\r\n```\r\n\r\n\r\n### PHPredis扩展安装\r\n1. 下载扩展包\r\n```\r\nwget https://github.com/nicolasff/phpredis/archive/master.zip\r\n```\r\n\r\n2 解压安装redis扩展\r\n```\r\nunzip master.zip\r\ncd phpredis-master\r\n/webserver/php/bin/phpize \r\n ./configure -with-php-config=/webserver/php/bin/php-config\r\nmake && make install\r\n```\r\n提示有 /webserver/php/lib/php/extensions/no-debug-non-zts-20121212/说明成功\r\nredis.so编译在这\r\n\r\n3. 配置PHP的配置文件,添加redis扩展\r\n```\r\nvim /webserver/php/etc/php.ini\r\nextension=\"redis.so\"\r\n```\r\n4重启httpd服务让扩展生效\r\n```\r\n/etc/init.d/php-fpm restart\r\n```\r\n5查看是否成功\r\n```\r\nphp -i | grep redis\r\n```\r\n\r\n\r\n### redis配置文件主要参数解析参考\r\n```\r\ndaemonize yes  #---默认值no，该参数用于定制redis服务是否以守护模式运行。---\r\npidfile /usr/local/webserver/redis/run/redis.pid  #默认值/var/run/redis.pid，指定redis服务的进程号文件路径，以守护模式运行时需要配置本参数；\r\nport 6379   #默认值6379，指定redis服务的端口\r\n# bind 127.0.0.1  #绑定ip，默认是本机所有网络设备；\r\ntimeout 0   #客户端空闲n秒后断开连接；默认是 0 表示不断开。\r\nloglevel notice  ###设置服务端的日志级别，有下列几种选择：\r\n    debug：记录详细信息，用于开发或调试；\r\n    verbose：提供很多有用的信息，但是又不像debug那么详尽，默认就是这一选项；\r\n    notice：适度提醒，多用于产品环境；\r\n    warning：仅显示重要的警告信息；\r\nlogfile stdout   ##指定日志的输出路径，默认值stdout，表示输出到屏幕，守护模式时则输出到/dev/null；\r\n如果要输出日志到syslog中，可以启动syslog-enabled yes，默认该选项值为no。\r\n# syslog-enabled no\r\ndatabases 16   ###指定数据库的数量，默认为16个，默认使用的数据库是DB 0。\r\n----以下为快照相关的设置:------\r\n#   save <seconds> <changes>  ##指定多长时间刷新快照至磁盘，这个选项有两个属性值，只有当两个属性值均满足时才会触发；可以设置多种级别，例如默认的参数文件中就设置了：\r\nsave 900 1：每900秒(15分钟)至少一次键值变更时被触发；\r\nsave 300 10：每300秒(5分钟)至少10次键值变更时被触发；\r\nsave 60 10000：每60秒至少10000次键值变更时被触发；\r\nsave 900 1\r\nsave 300 10\r\nsave 60 10000\r\nrdbcompression yes  ##默认值yes，当dump数据库时使用LZF压缩字符串对象，如果CPU资源比较紧张，可以设置为no，选择不压缩；\r\nrdbchecksum yes\r\n# The filename where to dump the DB  数据库文件名\r\ndbfilename dump.rdb  ##默认值dump.rdb，dump到文件系统中的文件名\r\ndir /usr/local/webserver/redis/db  ##默认值./，即当前目录，dump出的数据文件的存储路径；\r\n----以下为复制相关的设置，复制默认是不启用的，因此在默认的参数文件下列表参数均被注释----\r\n# slaveof <masterip> <masterport>  ##指定主端ip和端口，用于创建一个镜像服务\r\n# masterauth <master-password>  ##如果master配置了密码的话，此处也需做设置；\r\nslave-serve-stale-data yes  ##默认值yes。当slave丢失与master端的连接，或者复制仍在处理，那么slave会有下列两种表现：\r\n当本参数值为yes时，slave为继续响应客户端请求，尽管数据已不同步甚至没有数据(出现在初次同步的情况下)；\r\n当本参数值为no时，slave会返回\"SYNC with master in progreee\"的错误信息；\r\nslave-read-only yes  ##默认从Redis是只读模式\r\n# repl-ping-slave-period 10  ###默认值10，指定slave定期ping master的周期；\r\n# repl-timeout 60  ##默认值60，指定超时时间。注意本参数包括批量传输数据和ping响应的时间。\r\n------以下为安全相关的设置------\r\n# requirepass foobared  ###指定一个密码，客户端连接时也需要通过密码才能成功连接；\r\n# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52  ###重定义命令，例如将CONFIG命令更名为一个很复杂的名字：\r\n# rename-command CONFIG \"\"  取消这个命令；\r\n-----以下为资源限制方面的设置------\r\n# maxclients 10000  ##指定客户端的最大并发连接数，默认是没有限制，直到redis无法创建新的进程为止，设置该参数值为0也表示不限制，如果该参数指定了值，当并发连接达到指定值时，redis会关闭所有新连接，并返回\'max number of clients reached\'的错误信息；\r\n# maxmemory <bytes>  ###设置redis最大可使用内存。当达到最大内存后，redis会尝试按照设置的回收策略删除键值。如果无法删除键值，或者保留策略设置为不清除，那么redis就会向发出内存的请求返回错误信息。当把redis做为一级LRU的缓存时本参数较为有用。\r\n# maxmemory-policy volatile-lru  ###默认值volatile-lru，指定清除策略，有下列几种方法：\r\nvolatile-lru -> remove the key with an expire set using an LRU algorithm\r\nallkeys-lru -> remove any key accordingly to the LRU algorithm\r\nvolatile-random -> remove a random key with an expire set\r\nallkeys->random -> remove a random key, any key\r\nvolatile-ttl -> remove the key with the nearest expire time (minor TTL)\r\nnoeviction -> don\'t expire at all, just return an error on write operations\r\n# maxmemory-samples 3    ###默认值3，LRU和最小TTL策略并非严谨的策略，而是大约估算的方式，因此可以选择取样值以便检查。\r\n-----以下为APPEND的配置----\r\nONLY模式的设置，默认情况下redis采用异步方式dump数据到磁盘上，极端情况下这可能会导致丢失部分数据(比如服务器突然宕机)，如果数据比较重要，不希望丢失，可以启用直写的模式，这种模式下redis会将所有接收到的写操作同步到appendonly.aof文件中，该文件会在redis服务启动时在内存中重建所有数据。注意这种模式对性能影响非常之大。\r\nappendonly no  ##默认值no，指定是否启用直写模式；\r\n# appendfilename appendonly.aof  ###直写模式的默认文件名appendonly.aof\r\nappendfsync：调用fsync()方式让操作系统写数据到磁盘上，数据同步方式，有下列几种模式：\r\n    always：每次都调用，比如安全，但速度最慢；\r\n    everysec：每秒同步，这也是默认方式；\r\n    no：不调用fsync，由操作系统决定何时同步，比如快的模式；\r\n    no-appendfsync-on-rewrite：默认值no。当AOF fsync策略设置为always或everysec，后台保存进程会执行大量的I/O操作。某些linux配置下redis可能会阻塞过多的fsync()调用。\r\n    auto-aof-rewrite-percentage：默认值100\r\n    auto-aof-rewrite-min-size：默认值64mb\r\n# appendfsync always\r\nappendfsync everysec\r\n# appendfsync no\r\n-----以下为高级配置相关的设置----\r\nhash-max-zipmap-entries：默认值512，当某个map的元素个数达到最大值，但是其中最大元素的长度没有达到设定阀值时，其HASH的编码采用一种特殊的方式(更有效利用内存)。本参数与下面的参数组合使用来设置这两项阀值。设置元素个数；\r\nhash-max-zipmap-value：默认值64，设置map中元素的值的最大长度；这两个\r\nlist-max-ziplist-entries：默认值512，与hash类似，满足条件的list数组也会采用特殊的方式以节省空间。\r\nlist-max-ziplist-value：默认值64\r\nset-max-intset-entries：默认值512，当set类型中的数据都是数值类型，并且set中整型元素的数量不超过指定值时，使用特殊的编码方式。\r\nzset-max-ziplist-entries：默认值128，与hash和list类似。\r\nzset-max-ziplist-value：默认值64\r\nactiverehashing：默认值yes，用来控制是否自动重建hash。Active rehashing每100微秒使用1微秒cpu时间排序，以重组Redis的hash表。重建是通过一种lazy方式，写入hash表的操作越多，需要执行rehashing的步骤也越多，如果服务器当前空闲，那么rehashing操作会一直执行。如果对实时性要求较高，难以接受redis时不时出现的2微秒的延迟，则可以设置activerehashing为no，否则建议设置为yes，以节省内存空间。\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(22,'php redis手册,工具,技巧','22',1426947000,1427016656,'<!--markdown-->### 手册地址\r\n转 [https://github.com/run100/phpredis][1]\r\n\r\n以上是redis命令操作\r\n\r\n### redis客户端连接工具　\r\nredis desktop manager,自行下载\r\n\r\n### 技巧\r\n\r\n```\r\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);   // don\'t serialize data\r\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);    // use built-in serialize/unserialize\r\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY);   // use igBinary serialize/unserialize\r\n\r\n$redis->setOption(Redis::OPT_PREFIX, \'myAppName:\'); // use custom prefix on all keys\r\n\r\n/* Options for the SCAN family of commands, indicating whether to abstract\r\n   empty results from the user.  If set to SCAN_NORETRY (the default), phpredis\r\n   will just issue one SCAN command at a time, sometimes returning an empty\r\n   array of results.  If set to SCAN_RETRY, phpredis will retry the scan command\r\n   until keys come back OR Redis returns an iterator of zero\r\n*/\r\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_NORETRY);\r\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\r\n```\r\n\r\n\r\n  [1]: https://github.com/run100/phpredis',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(23,'php session存入redis实例','23',1427017260,1456740391,'<!--markdown-->主要是利用redis的数据类型字符串string,get、set、delete方法\r\n要注意下gc,gc可以利用redis的key值过期时间\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n```php\r\nif(!defined(\'REDIS_HOST\')){\r\n    define(\'REDIS_HOST\', \'127.0.0.1\');\r\n    define(\'REDIS_PORT\', \'6379\');\r\n}\r\n\r\n\r\nclass sessRedisCls\r\n{\r\n    static $redisHandle;\r\n\r\n    public static function getRedisConn($alive_check = 0){\r\n        static $redis;        \r\n\r\n        $redis = new Redis();\r\n        $redis->connect(REDIS_HOST, REDIS_PORT);\r\n\r\n        return $redis;\r\n    }\r\n\r\n    public function getKey($id){\r\n        return \'session_redis_\'.$id;\r\n    }\r\n\r\n\r\n    public function __construct(){}\r\n\r\n    public function open($path, $name){\r\n\r\n        if(is_resource(self::$redisHandle)){\r\n            return self::$redisHandle;\r\n        }\r\n\r\n        self::$redisHandle = self::getRedisConn(false);\r\n        if(!self::$redisHandle){\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public function close(){\r\n        #return true;\r\n        if(self::$redisHandle){\r\n            return self::$redisHandle->close();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public function read($id){\r\n     \r\n        //$redis = self::getRedisConn(false);\r\n        $key = $this->getKey($id);\r\n\r\n        return self::$redisHandle->get($key);\r\n    }\r\n\r\n    public function write($id, $data){\r\n       \r\n        $key = self::getKey($id);\r\n        self::$redisHandle->set($key, $data);\r\n        self::$redisHandle->expire($key, ini_get(\'session.gc_maxlifetime\'));\r\n        return;\r\n           \r\n    }\r\n\r\n\r\n    public function destory($id){\r\n\r\n\r\n        \r\n        self::$redisHandle->delete($this->getKey($id));\r\n        return;\r\n            \r\n    }\r\n\r\n    public function gc($lifetime){\r\n        $i = 10;\r\n        \r\n        self::$redisHandle->keys(\'session_redis*\');        \r\n        return true;\r\n    }\r\n\r\n    public static  function  register(){\r\n        $session = new self();\r\n\r\n        session_set_save_handler(\r\n            array($session, \'open\'),\r\n            array($session, \'close\'),\r\n            array($session, \'read\'),\r\n            array($session, \'write\'),\r\n            array($session, \'destory\'),\r\n            array($session, \'gc\')\r\n        );\r\n    }\r\n\r\n	\r\n}\r\n```\r\n\r\n调取实现user1.php\r\n```\r\ninclude_once __DIR__.DIRECTORY_SEPARATOR.\'session.php\';\r\n\r\n$sessCls = new sessRedisCls();\r\n$sessCls::register();\r\n\r\nsession_start();\r\n\r\necho session_id();\r\necho \"\\r\\n\";\r\n$_SESSION[\'name\'] = \'run\';\r\n\r\necho $_SESSION[\'name\'];\r\necho \"\\r\\n\";\r\n```\r\n\r\n用浏览器访问user1.php\r\n```\r\n27acqe1daqntr8qlpc7not8sb7 run\r\n```\r\n\r\n调取实现user2.php\r\n\r\n```\r\necho $_SESSION[\'name\'];\r\necho \"\\r\\n\";\r\n```\r\n得到\r\n```\r\nrun\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(24,'php redis简单队列实现 ','24',1427018109,1427018109,'<!--markdown-->主要利用redis　表类型List入队到队列尾部,从队列前出队列\r\n操作\r\n```\r\n$redis = new Redis();\r\n$redis->connect(\'127.0.0.1\', \'6379\');\r\n\r\n$key = \'queue\';\r\n\r\nif($argv[1] == \'in\'){\r\n    $i = 0;\r\n    while(True){\r\n        try{\r\n            $val = \'value_\'.$i;\r\n            $redis->lpush(\'queue\', $val);\r\n            sleep(rand()%3);\r\n\r\n        }catch(Exception $e){\r\n            print_r($e->getMessage()).\"\\r\\n\";\r\n        }\r\n        $i++;\r\n    }\r\n\r\n}\r\n\r\nif($argv[1] == \'out\'){\r\n    while(True){\r\n        try{\r\n            echo $redis->lpop(\'queue\').\"\\r\\n\";\r\n        }catch(Exception $e){\r\n            echo $e->getMessage().\"\\r\\n\";\r\n        }\r\n        sleep(rand()%3);\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n我放在一个文件里了，执行\r\n入队列\r\n```\r\nphp queue.php  in\r\n```\r\n\r\n\r\n出队列\r\n```\r\nphp queue.php  out\r\n```\r\n\r\n可以测试下\r\n\r\n还有其他一些操作\r\n```\r\n$key = \'queue\';\r\n\"lLen\".var_dump($redisCls->lLen($key));\r\necho \"\\r\\n\";\r\n\"lRange\".var_dump($redisCls->lRange($key, 30, 40));\r\necho \"\\r\\n\";\r\n\"lIndex\".var_dump($redisCls->lIndex($key, 2));\r\necho \"\\r\\n\";\r\n\"lSize\".var_dump($redisCls->lSize($key));\r\necho \"\\r\\n\";\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(25,'随笔','suibi',1427037840,1450058228,'<!--markdown-->### 10.17\r\n【10种公认最有效的减脂运动】1.十二分钟的自由泳；2.每日1万步的行走；3.一次坚持七秒的拉伸运动；4.慢跑20分钟以上；5.二十分钟的半身浴；6.五秒钟按压耳部穴位5下；7.三十分钟的足底按摩；8.一个小时脚尖提起站立；9.跳1小时的舞；10.吃饭时每口嚼20次\r\n\r\n### 9.29\r\n学习任何一门技术的过程都是：模仿---使用---发挥。\r\n\r\n### 9.23\r\n要想坚持下来对程序感觉兴趣，必须要有化整为零的能力，一步一个脚印，不急不臊\r\n常用的算法要坚持下来使用\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 8.24\r\n当你的才华还撑不起你的野心的时候，你就应该静下心来学习；当你的能力还驾驭不了你的目标时，就应该沉下心来，历练；梦想，不是浮躁，而是沉淀和积累，只有拼出来的美丽，没有等出来的辉煌，机会永远是留给最渴望的那个人，学会与内心深处的你对话，问问自己，想要怎样的人生，静心学习，耐心沉淀，送给自己！\r\n\r\n\r\n### 6.4\r\n了解 熟练 精通 温故而知新\r\n\r\n### 5.7\r\n时间很快,别人都开始docker了,差距太大，一定要保持专注(编程,c,linux,apple等)，去除一切花时间的恶习(手机,新闻,NBA,GAME等)\r\n最重要还是投入编号，专注\r\n\r\n### 3.29\r\nphp学习资料\r\n[http://www.php100.com/html/dujia/2015/0105/8267.html][1]\r\n\r\n\r\n[http://www.php100.com/html/dujia/2015/0106/8277.html][2]\r\n\r\n\r\n### 3.25\r\n时间挺快，任务挺重，加油\r\nfping,nc\r\n\r\n### 3.22\r\n主要是做了 php,redis的一些实现\r\npear,php扩展, 重新编译了下php\r\n\r\n\r\n  [1]: http://www.php100.com/html/dujia/2015/0105/8267.html\r\n  [2]: http://www.php100.com/html/dujia/2015/0106/8277.html',6,1,NULL,'page','publish',NULL,0,'1','1','1',0),(109,'链接','links',1450075200,1455673785,'<!--markdown-->linux命令查找\r\n[https://www.jincon.com][1]\r\n[http://res.crossin.me/wechat/][2]\r\n[http://linux.51yip.com/search/lsof][3]\r\n\r\n[http://stackoverflow.com/tags][4]\r\n[https://www.reddit.com/r/programming][5]\r\n[https://www.quora.com/][6]\r\n[https://news.ycombinator.com/newest][7]\r\n\r\n\r\n  [1]: https://www.jincon.com\r\n  [2]: http://res.crossin.me/wechat/\r\n  [3]: http://linux.51yip.com/search/lsof\r\n  [4]: http://stackoverflow.com/tags\r\n  [5]: https://www.reddit.com/r/programming\r\n  [6]: https://www.quora.com/\r\n  [7]: https://www.quora.com/',1,1,NULL,'page','publish',NULL,0,'1','1','1',0),(27,'centos,mongodb安装，php扩展配置','27',1427106900,1427106934,'<!--markdown-->mongodb主要可以用于分析系统，日志系统等\r\n\r\n### centos安装mongo服务器\r\n下载官网地址 \r\n[http://www.mongodb.org/downloads][1]\r\n\r\n安装比较简单\r\n```\r\ntar -zxvf mongodb.tar.gz\r\ncd /${src}/mongodb\r\nmkdir -p /usr/local/mongodb\r\ncp -R * /usr/local/mongodb\r\n```\r\ndata及log目录\r\n```\r\nmkdir -p /home/data/mongodata\r\nmkdir -p /home/logs/mongo\r\ntouch /home/logs/mongodb/mongodb.log\r\n```\r\n\r\n启动\r\n```\r\n/usr/local/mongodb/bin/mongod --port 27017 --fork  --dbpath=/home/logs/mongodb --logpath=/home/logs/mongodb/mongodb.log --logappend --journal\r\n```\r\n\r\n另外一种启动方式\r\n新建配置文件\r\n```\r\nvi /usr/local/mongodb/mongodb.conf\r\n\r\nport=27017\r\ndbpath=/home/data/mongodb/mongodb_data/\r\nlogpath=/home/logs/mongodb/mongodb.log\r\npidfilepath=/usr/local/mongodb/mongo.pid\r\nfork=true\r\nlogappend=true\r\nshardsvr=true\r\ndirectoryperdb=true\r\n#auth=true\r\n\r\n```\r\n\r\n利用配置文件启动\r\n```\r\n./mongod --config /usr/local/webserver/mongodb.conf  #启动MongoDB\r\n./mongo 127.0.0.1:27017/admin --eval \"db.shutdownServer()\"  #关闭MongoDB\r\n```\r\n\r\n加入开机启动\r\n```\r\nvim /etc/rc.local\r\n```\r\n加上\r\n```\r\n/usr/local/webserver/mongodb/bin/mongod --config /usr/local/webserver/mongodb/mongodb.conf\r\n```\r\n\r\n### mongodb,php扩展安装\r\n下载地址\r\n\r\nhttps://github.com/mongodb/mongo-php-driver\r\n```\r\nunzip mongo-php-driver-master.master\r\ncd mongo-php-driver-master\r\n\r\n/usr/local/php/bin/phpize\r\n./configure --with-php-config=/usr/local/php/bin/php-config\r\nsudo make && make install\r\n\r\n```\r\n\r\n添加扩展\r\n```\r\nvi /usr/local/php/etc/php.ini\r\nextension=mongo.so\r\n```\r\n查看扩展\r\n```\r\nphp -i | grep mongo\r\nmongo\r\nmongo.allow_empty_keys => 0 => 0\r\nmongo.chunk_size => 261120 => 261120\r\nmongo.cmd => $ => $\r\nmongo.default_host => localhost => localhost\r\nmongo.default_port => 27017 => 27017\r\nmongo.is_master_interval => 15 => 15\r\nmongo.long_as_object => 0 => 0\r\nmongo.native_long => 1 => 1\r\nmongo.ping_interval => 5 => 5\r\n```\r\n\r\n\r\n\r\n\r\n\r\n  [1]: http://www.mongodb.org/downloads',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(28,'php pear写常驻程式(dameon),守护进程','28',1427197740,1427199130,'<!--markdown-->守护进程在unix中，有nohup,或执行命令时加&,用jobs来查看,或者在执行时按下ctrl+z,然后打bg(background 的意思)就能看到程序在运行,很多的定时的任务，都是通过crond来写的,比较难以控制。\r\n\r\n在php中,所以可以使用pear的dameon来写守护程序。简单的说就是利用php的cli属性来写 背景运作的程式\r\n像apache,mysql打印完后，回到命令行，实际上已经运行了。\r\n<!--more-->\r\n\r\n\r\n主要用到php的pcntl,pcntl_fork, pcntl_wait, pcntl_waitpid的功能。需要重新编译安装php,编译时加上--enable-pcntl。\r\n下载php的pear库，利用System_Daemon 设定damon的环境,定义程序动作名称，把信息写入log档案, 最重要是有一个标准的架构可以把快速写好的php script变成运行的dameon\r\n```\r\npear install -f System_Daemon\r\n```\r\n\r\n```php\r\n#!/usr/local/webserver/php/bin/php -q\r\n\r\n<?php\r\nerror_reporting(E_ALL ^ E_NOTICE);\r\n\r\ndefine(\'SF_DEBUG\', true);\r\n\r\nif(!isset($argv[1])){\r\n\r\n}\r\n\r\n$srcDir = realpath(dirname(__FILE__).\'/../\');\r\n\r\ndefine(\'SF_ROOT_DIR\', $srcDir );\r\n\r\ndefine(\'PEAR_DIR\', SF_ROOT_DIR . \'/pear\');\r\ndefine(\'PEAR_SRC\', PEAR_DIR . \'/share/pear\');\r\ndefine(\'PEAR_DATA_DIR\', PEAR_DIR . \'/data\');\r\n\r\n\r\n#echo PEAR_DIR,PEAR_SRC,PEAR_DATA_DIR;\r\n\r\nset_include_path(get_include_path().\":\".PEAR_SRC);\r\n\r\n\r\necho \"UID \".posix_getuid().\"\\r\\n\";\r\n\r\nif (posix_getuid() != 0) {\r\n  die(\"This script must be run as root\\n\");\r\n}\r\n\r\n$user = posix_getpwnam(\'daemon\');\r\n\r\n#print_r($user);\r\n\r\nrequire_once \"System/Daemon.php\";\r\n\r\n#System_Daemon::writeAutoRun();\r\n\r\nSystem_Daemon::setOption(\"appName\", \"check_daemon\");\r\nSystem_Daemon::setOption(\"authorEmail\", \"727271755@qq.com\");\r\n\r\n// System_Daemon::setOption(\"appDir\", dirname(__FILE__));\r\n#System_Daemon::log(System_Daemon::LOG_INFO, \"Daemon not yet started so \".\"this will be written on-screen\");\r\n\r\necho  System_Daemon::getOption(\"logLocation\"); exit;\r\n// Spawn Deamon!\r\n// 开始 Daemon 的部份\r\nSystem_Daemon::start();\r\n\r\n// 写入记录\r\n// System_Daemon::getOption(); 取得环境\r\n// 像是 System_Daemon::getOption(\"logLocation\") 取log位置\r\nSystem_Daemon::log(System_Daemon::LOG_INFO, \"Daemon: \'\".\r\n    System_Daemon::getOption(\"appName\").\r\n    \"\' spawned! This will be written to \".\r\n    System_Daemon::getOption(\"logLocation\"));\r\n\r\n// Your normal PHP code goes here. Only the code will run in the background\r\n// so you can close your terminal session, and the application will\r\n// still run.\r\n//\r\nif(!file_exists(\'/tmp/darkhero_md5.txt\'))\r\n    touch(\'/tmp/darkhero_md5.txt\');\r\nwhile(1){\r\n    if(file_exists(\'/tmp/darkhero.txt\') and md5_file(\'/tmp/darkhero.txt\') != file_get_contents(\'/tmp/darkhero_md5.txt\')){\r\n        System_Daemon::log(System_Daemon::LOG_INFO, \"文件更新，\");\r\n        $md5_string = md5_file(\'/tmp/darkhero.txt\');\r\n        file_put_contents(\'/tmp/darkhero_md5.txt\',$md5_string);\r\n    }\r\n    usleep(100);\r\n}\r\n\r\nSystem_Daemon::stop();\r\n\r\n```\r\n\r\n```\r\nchmod a+x dameon.php\r\nsudo ./check.php\r\n[Apr 23 13:09:58] info: Daemon not yet started so this will be written on-screen\r\n[Apr 23 13:09:58] notice: Starting check_daemon daemon, output in: \'/var/log/check_daemon.log\'\r\n```\r\n\r\ndameon.php在背后运作　\r\n再跑一次\r\n```\r\n[Apr 23 13:12:27] info: Daemon not yet started so this will be written on-screen\r\n[Apr 23 13:12:27] notice: Starting check_daemon daemon, output in: \'/var/log/check_daemon.log\'\r\n[Apr 23 13:12:27] emerg: check_daemon daemon is still running. Exiting [l:1250]\r\n[Apr 23 13:12:27] info: Process was not daemonized yet, just halting current process\r\n```\r\n\r\n因为System_Daemon 在/var/run/check_daemon/产生check_daemon.pid来确保daemon只会有一个在运行\r\n另外 System_Daemon 在 /var/log/ 建立了一个以 appName 为名的 log 档案..\r\n\r\n```\r\ntail -f /var/log/check_daemon.log\r\n```\r\n\r\n然后测试改变\r\n```shell\r\necho \'asdfasdfadsf\' > /tmp/darkhero.txt\r\n```\r\n\r\n再次查看log就会有改变\r\n\r\n停止的话使用命令\r\n```\r\nsudo killall -9 daemon.php\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(29,'8个与安全相关的PHP函数','29',1427294400,1427294699,'<!--markdown-->  安全问题是编程语言中需要考虑的重要部分，几乎在任何一种实际的语言中都会提供一些函数，模块，或其它确保安全的功能。在现代互联网中，我们经常要从世界各地的用户中获得输入数据。但是，我们都知道“永远不能相信那些用户输入的数据”。所以在各种的Web开发语言中，都会提供保证用户输入数据安全的函数。今天，我们就来看一看作为最著名的开源语言PHP中提供的这样的函数。\r\n    <!--more-->\r\n  \r\n\r\n\r\n 在PHP中，有些非常有用并且方便的函数，它们可以帮助你的网站防止出现像SQL注入攻击，XSS攻击等问题。我们看看这些在PHP中可以保证项目安全的函数，下面列出的这些函数只是我发现的对你项目有帮助的，可能会不全。\r\n### 1. mysql_real_escape_string() \r\n这个函数对于在PHP中防止SQL注入攻击很有帮助，它对特殊的字符，像单引号和双引号，加上了“反斜杠”，确保用户的输入在用它去查询以前已经是安全的了。但你要注意你是在连接着数据库的情况下使用这个函数。但现在mysql_real_escape_string()这个函数基本不用了，所有新的应用开发都应该使用像PDO这样的库对数据库进行操作，也就是说，我们可以使用现成的语句防止SQL注入攻击。\r\n### 2. addslashes()\r\n这个函数和上面的mysql_real_escape_string()很相似。但要注意当设置文件php.ini中的magic_quotes_gpc的值为“on”时，不要使用这个函数。默认情况下， magic_quotes_gpc 为 on，对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。不要对已经被 magic_quotes_gpc 转义过的字符串使用 addslashes()，因为这样会导致双层转义。你可以通过PHP中get_magic_quotes_gpc()函数检查这个变量的值。\r\n### 3. htmlentities()\r\n这个函数对过滤用户输入数据非常有用，它可以把字符转换为 HTML 实体。比如，当用户输入字符“<”时，就会被该函数转化为HTML实体<，因此防止了XSS和SQL注入攻击。\r\n### 4. htmlspecialchars()\r\n HTML中的一些字符有着特殊的含义，如果要体现这样的含义，就要被转换为HTML实体，这个函数会返回转换后的字符串，比如，‘&’amp会转为‘&’。\r\n### 5. strip_tags()\r\n这个函数可以去除字符串中所有的HTML，JavaScript和PHP标签，当然你也可以通过设置该函数的第二个参数，让一些特定的标签出现。\r\n### 6. md5()\r\n一些开发者存储的密码非常简单，这从安全的角度上看是不好的，md5()函数可以产生给定字符串的32个字符的md5散列，而且这个过程不可逆，即你不能从md5()的结果得到原始字符串。\r\n ### 7. sha1()\r\n这个函数和上面的md5()相似，但是它使用了不同的算法，产生的是40个字符的SHA-1散列（md5产生的是32个字符的散列）。\r\n### 8. intval()\r\n不要笑，我知道这不是一个和安全相关的函数，它是在将变量转成整数类型。但是，你可以用这个函数让你的PHP代码更安全，特别是当你在解析id，年龄这样的数据时。\r\n ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(30,'PHP文件操作的简单介绍','30',1427294940,1427295165,'<!--markdown-->文件操作一直是Web程序员头疼的地方，而文件操作在CMS这样的系统中又是必须的。如今，PHP文件操作的函数内容已经非常强大，文件这部分也是学习PHP非常重要的一部分，希望大家不要忽略。这篇文章会简单介绍一下PHP的几个基本文件操作，最后附有PHP文件函数汇总，供大家参考和学习。\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n### 1. 打开文件：fopen(\"文件名\",\"模式\");\r\n模式参数：\r\nr：只读，将文件指针指向文件头。\r\nr+：读/写，将文件指针指向文件头。\r\nw：只写，打开并清空文件的内容。如果文件不存在，则创建文件。\r\nw+：读/写，打开并清空文件的内容。如果文件不存在，则创建文件。\r\na：追加，打开并向文件的末端进行写操作。如果文件不存在，则创建新文件。 \r\na+：读/追加，通过向文件末端写内容，来保持文件内容。\r\n\r\n\r\n###  2. 关闭文件：fclose();\r\n使用文件完毕，要显式的告诉PHP已经使用完文件，例如：\r\n$file=fopen(\"test.txt\",\"r\");  //关闭一个已打开的文件指针\r\n//some code be executed  \r\nfclose=($file);  \r\n\r\n\r\n###  3. 检测是否已达到文件的末端：feof();\r\n例如：if(feof($file)){ echo \"end of file\";}\r\n\r\n\r\n###  4. 逐行读取文件：fgets();\r\n例如：\r\n$file=fopen(\"test.txt\",\"r\");  \r\nwhile(!feof($file)){  \r\necho fgets($file).\"< br/>\";  \r\n}  \r\nfclose($file); \r\n\r\n\r\n###  5. 逐字符读取文件：fgetc()\r\n\r\n\r\n### 6. 读取任意二进制数据：fread()\r\n\r\n\r\n###  7. 判断文件读取的状态\r\n每个文件句柄都有一个文件指针，根据fopen函数的mode参数，文件指针最初位于文件的开头，或者文件的末尾。feof()可以判断文件是否已经到末尾；filesize()函数返回文件的大小。\r\n\r\n\r\n###  8. 写入文件和权限判断\r\nfwrite() 函数执行文件写入\r\nis_readable()//判断文件是否可读\r\nis_writeable()//判断文件是否可写\r\nis_writable()//判断文件是否可写\r\nfile_exists()//是否存在这个文件\r\n\r\n代码举例：\r\n```php\r\n$filename = \'test.txt\';  \r\n$somecontent;\r\n// 首先我们要确定文件存在并且可写 \r\nif (is_writable($filename)) {  \r\n// 在这个例子里，我们将使用添加模式打开$filename，  因此，文件指针将会在文件的开头，那就是当我们使用fwrite()的时候，$somecontent将要写入的地方。  \r\n\r\n    if (!$handle = fopen($filename, \'a\')) {  \r\n       echo \"不能打开文件 $filename\";  \r\n       exit;  \r\n    }  \r\n    // 将$somecontent写入到我们打开的文件中。  \r\n    if (fwrite($handle, $somecontent) === FALSE) {  \r\n       echo \"不能写入到文件 $filename\";  \r\n       exit;  \r\n    }  \r\n\r\n   echo \"成功地将 $somecontent 写入到文件$filename\";  \r\n   fclose($handle);  \r\n} \r\n\r\nelse{  \r\n      echo \"文件 $filename 不可写\"; \r\n}\r\n```\r\n\r\n### 9. 将文件读取到一个数组 \r\n$array=file(\"text.txt\"),$array[0]就是第一行文本，依次类推。如果要翻转整个数组，例如：$arr=array_reverse($array);则最后一行文本就是$arr[0]\r\n\r\n### 10. 访问目录\r\n目录访问建议使用前向斜线\"/\"，兼容windows和unix系统。主要函数包括：\r\nbasename()//返回不包括路径信息的文件名\r\ndirname()//返回文件名的目录部分\r\nrealpath()//接受相对路径，返回文件的绝对路径\r\npathinfo()//提取给定路径的目录名，基本文件名和扩展名\r\nopendir()//打开目录，返回资源句柄\r\nreaddir()//读取目录项\r\nrewinddir()//将读取指针返回开头\r\nclosedir()//关闭读取句柄\r\nchdir()//改变当前脚本执行期间的当前工作目录\r\nmkdir()//创建目录\r\nrmdir()删除目录\r\n\r\n\r\n### 附：PHP文件函数大全 \r\n\r\nbasename — 返回路径中的文件名部分 \r\nchgrp — 改变文件所属的组 \r\nchmod — 改变文件模式 \r\nchown — 改变文件的所有者 \r\nclearstatcache — 清除文件状态缓存 \r\ncopy — 拷贝文件 \r\ndelete — 参见 unlink() 或 unset() \r\ndirname — 返回路径中的目录部分 \r\ndisk_free_space — 返回目录中的可用空间 \r\ndisk_total_space — 返回一个目录的磁盘总大小 \r\ndiskfreespace — disk_free_space()的别名 \r\nfclose — 关闭一个已打开的文件指针 \r\nfeof — 测试文件指针是否到了文件结束的位置 \r\nfflush — 将缓冲内容输出到文件 \r\nfgetc — 从文件指针中读取字符 \r\nfgetcsv — 从文件指针中读入一行并解析 CSV 字段 \r\nfgets — 从文件指针中读取一行 \r\nfgetss — 从文件指针中读取一行并过滤掉 HTML 标记 \r\nfile_exists — 检查文件或目录是否存在 \r\nfile_get_contents — 将整个文件读入一个字符串 \r\nfile_put_contents — 将一个字符串写入文件 \r\nfile — 把整个文件读入一个数组中 \r\nfileatime — 取得文件的上次访问时间 \r\nfilectime — 这个PHP文件函数取得文件的 inode 修改时间 \r\nfilegroup — 取得文件的组 \r\nfileinode — 取得文件的 inode \r\nfilemtime — 取得文件修改时间 \r\nfileowner — 取得文件的所有者 \r\nfileperms — 取得文件的权限 \r\nfilesize — 取得文件大小 \r\nfiletype — 取得文件类型 \r\nflock — 轻便的咨询文件锁定 \r\nfnmatch — 用模式匹配文件名 \r\nfopen — 打开文件或者 URL \r\nfpassthru — 输出文件指针处的所有剩余数据 \r\nfputcsv — 将行格式化为 CSV 并写入文件指针 \r\nfputs — fwrite()的别名 \r\nfread — 读取文件（可安全用于二进制文件） \r\nfscanf — 从文件中格式化输入 \r\nfseek — 在文件指针中定位 \r\nfstat — 通过已打开的文件指针取得文件信息 \r\nftell — 返回文件指针读/写的位置 \r\nftruncate — 将文件截断到给定的长度 \r\nfwrite — 写入文件（可安全用于二进制文件） \r\nglob — 寻找与模式匹配的文件路径 \r\nis_dir — 该PHP文件函数判断给定文件名是否是一个目录 \r\nis_executable — 判断给定文件名是否可执行 \r\nis_file — 判断给定文件名是否为一个正常的文件 \r\nis_link — 判断给定文件名是否为一个符号连接 \r\nis_readable — 判断给定文件名是否可读 \r\nis_uploaded_file — 判断文件是否是通过 HTTP POST 上传的 \r\nis_writable — 判断给定的文件名是否可写 \r\nis_writeable — is_writable()的别名 \r\nlink — 建立一个硬连接 \r\nlinkinfo — 获取一个连接的信息 \r\nlstat — 给出一个文件或符号连接的信息 \r\nmkdir — 新建目录 \r\nmove_uploaded_file — 将上传的文件移动到新位置 \r\nparse_ini_file — 解析一个配置文件 \r\npathinfo — 返回文件路径的信息 \r\npclose — 关闭进程文件指针 \r\npopen — 打开进程文件指针 \r\nreadfile — 输出一个文件 \r\nreadlink — 返回符号连接指向的目标 \r\nrealpath — 返回规范化的绝对路径名 \r\nrename — 重命名一个文件或目录 \r\nrewind — 倒回文件指针的位置 \r\nrmdir — 删除目录 \r\nset_file_buffer — stream_set_write_buffer()的别名 \r\nstat — 给出文件的信息 \r\nsymlink — 建立符号连接 \r\ntempnam — 建立一个具有唯一文件名的文件 \r\ntmpfile — 建立一个临时文件 \r\ntouch — 设定文件的访问和修改时间 \r\numask — 改变当前的 umask \r\nunlink — 删除文件',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(31,'MongoDB PHP Driver的连接处理解析','31',1427377200,1427377865,'<!--markdown-->1.3版本的PHP MongoDB driver重写了连接处理库，和以前版本相比，在持久连接和连接池方面，都有了重大的变化。\r\n\r\n\r\n<!--more-->\r\n\r\n### 1.2版本的连接管理\r\n1.2版本的驱动引入了连接池，在执行任何查询时，都会从连接池中请求一个连接，完成之后再归还给连接池。这里的完成是指持有该连接的变量离开了它的作用域，下面是一个示例。\r\n\r\n```php\r\n$m = new MongoClient();    // ← 从连接池请求连接\r\n$c = $m->demo->test;\r\n$c->insert( array( \'test\' => \'yes\' ) );\r\n?>\r\n```\r\n\r\n$m离开作用域，连接归还给连接池\r\n\r\n在函数中:\r\n```\r\nfunction doQuery()\r\n{\r\n        $m = new MongoClient();    // ← 从连接池请求连接\r\n        $c = $m->demo->test;\r\n        $c->insert( array( \'test\' => \'yes\' ) );\r\n} // ← $m离开作用域，连接归还给连接池\r\n```\r\n\r\n在某些情况下，系统可能会产生大量的连接，比如在ORMs/ODMs的某个复杂结构中引用连接对象，如下例子：\r\n```\r\n{\r\n        $conns[] = new MongoClient();\r\n}// ← 现在有5个连接\r\n```\r\n\r\n### 1.3版本的连接管理\r\n\r\n在1.3版本中，连接管理做了很大改动。每个worker进程(线程、PHP-FPM或Apache worker)中，驱动把连接管理和Mongo*对象分离，降低驱动的复杂度。下面以单个节点的MongoDB实例来说明驱动如何处理连接。\r\n\r\n当一个worker进程启动，MongoDB驱动会为之初始化连接管理器管理连接，并且默认没有连接。\r\n\r\n在第一个请求调用new MongoClient();时，驱动创建一个新连接，并且以一个哈希值标识这个连接。这个哈希值包括以下参数：主机名、端口，进程ID和可选的replica set名，如果是密码验证的连接，则还包括数据库名、用户名和密码的哈希值（对于密码验证的连接，我们后面再详细讨论）。调用MongoClient::getConnections()方法，可以查看连接对应的哈希值：\r\n\r\n```\r\n$m = new MongoClient( \'mongodb://localhost:27017/\' );\r\nvar_dump( $m->getConnections()[0][\'hash\'] );\r\n```\r\n输出:\r\n```\r\nstring(22) \"whisky:27017;-;X;22835\"\r\n```\r\n\r\n输出中的\"-\"表示该连接不属于某个replica set，\"X\"是没有用户名、数据库和密码时的占位符，22835是当前进程的进程ID。\r\n\r\n然后该连接会在连接管理器中注册\r\n\r\n在需要连接的任何时候，包括插入、删除、更新、查找或执行命令，驱动都会向管理器请求一个合适的连接来执行。请求连接时会用到new MongoClient()的参数和当前进程的ID。每个worker进程/线程，连接管理器都会有一个连接列表，而每个PHP worker同一时刻，只会运行一个请求，因此和每个MongoDB之间只需要一个连接，不断重用，直到PHP worker终止或显式调用MongoClient::close()关闭连接。\r\n\r\n### Replica sets\r\n在存在复制集的环境中，情形有点不一样。new MongoClient()的连接字符串中，需要指定多个hosts，并标示当前正在实用复制集:\r\n```\r\n$m = new MongoClient(\"mongodb://whisky:13000,whisky:13001/?replicaSet=seta\");\r\n```\r\n\r\n其中的replicaSet参数不能省略，否则驱动会认为你是准备连接三个不同的mongos进程。\r\n\r\n在实例化时，驱动会检查复制集的拓扑结构。下面例子的输出，显示在调用new MongoClient()之后，复制集中所有可见的数据节点都会在管理器中注册一个连接:\r\n```\r\n$m = new MongoClient( \'mongodb://whisky:13001/?replicaSet=seta\' );\r\nforeach ( $m->getConnections() as $c )\r\n{\r\n    echo $c[\'hash\'], \"\\n\";\r\n}\r\n```\r\n\r\n输出：\r\n\r\n```\r\nwhisky:13001;seta;X;32315 whisky:13000;seta;X;32315\r\n```\r\n\r\n\r\n虽然连接字符串中没有whisky:13000节点，但是管理器中已经注册了两个连接 \r\n\r\n管理器不仅包含连接的哈希值和TCP/IP socket，还保存哪个节点是主节点，以及每个节点的“距离\"。下面的脚本显示了这些额外的信息；\r\n\r\n```\r\n$m = new MongoClient( \'mongodb://whisky:13001/?replicaSet=seta\' );\r\nforeach ( $m->getConnections() as $c )\r\n{\r\n    echo $c[\'hash\'], \":\\n\",\r\n        \" - {$c[\'connection\'][\'connection_type_desc\']}, \",\r\n        \"{$c[\'connection\'][\'ping_ms\']} ms\\n\";\r\n}\r\n```\r\n\r\n输出：\r\n```\r\nwhisky:13001;seta;X;5776: - SECONDARY, 1 ms whisky:13000;seta;X;5776: - PRIMARY, 0 ms\r\n```\r\n\r\n驱动把操作分为两种类型：写操作，包括插入、更新、删除和命令；读操作，包括find和findOne。默认情况下，如果没有设置读偏好参数，管理器会一直返回主节点的连接。读偏好参数可以通过setSlaveOkay()设置，也可以在连接字符串中设置：\r\n```\r\n$m = new MongoClient(\"mongodb://whisky:13000,whisky:13001/?replicaSet=seta&readPreference=secondaryPreferred\");\r\n```\r\n\r\n加上这些参数后，连接字符串变得特别长，因此PHP驱动允许将选项放在数组中，作为第二个参数传入：\r\n```\r\n$options = array(\r\n        \'replicaSet\' => \'seta\',\r\n        \'readPreference\' => \'secondaryPreferred\',\r\n);\r\n$m = new MongoClient(\"mongodb://whisky:13000,whisky:13001/\", $options);\r\n```\r\n\r\n### 验证的连接\r\n\r\n如果MongoDB启用验证功能，那么连接的哈希值会包含验证相关的哈希值。这样不同脚本，使用不同的用户名、密码连接同一个MongoDB上的不同的数据库时，能够相互区分，而不会误用连接。下面示例使用admin用户名连接admin数据库，然后观察hash值的变化：\r\n```\r\n$m = new MongoClient( \'mongodb://admin:admin@whisky:27017/admin\' );\r\nvar_dump( $m->getConnections()[0][\'hash\'] );\r\n\r\n```\r\n输出:\r\n```\r\nstring(64) \"whisky:27017;-;admin/admin/bda5cc70cd5c23f7ffa1fda978ecbd30;8697\"\r\n```\r\n\r\n以前示例中的\"X\"部分已经替换为一个包含数据库名admin、用户名admin和哈希值bda5cc70cd5c23f7ffa1fda978ecbd30，该哈希值是根据用户名、数据库名和密码哈希值计算得来。\r\n\r\n为了验证能够正确工作，需要在连接字符串中包含数据库名，否则会默认为admin。\r\n\r\n在建立连接后要使用数据库，需要先选择该数据库，如：\r\n```\r\n$collection = $m->demoDb->collection; $collection->findOne();\r\n```\r\n\r\n如果选择的数据库是连接字符串中指定的数据库，或者连接字符串中的数据库是admin，那么一切都会正常运行。否则，驱动会创建一个新的连接，从而防止验证被绕过，如下所示：\r\n```\r\n$m = new MongoClient( \'mongodb://user:user@whisky:27017/test\' );\r\n\r\n$db = $m->test2;\r\n$collection = $db->collection;\r\nvar_dump( $collection->findOne() );\r\n```\r\n\r\n输出:\r\n```\r\nFatal error: Uncaught exception \'MongoCursorException\' with message \'whisky:27017: unauthorized db:test2 ns:test2.collection lock type:0 client:127.0.0.1\' in …/mongo-connect-5.php.txt:6\r\n```\r\n\r\n因为我们的连接并没有执行test2数据库的授权验证，因而失败。如果我们执行验证，就会正常运行：\r\n```\r\n$m = new MongoClient( \'mongodb://user:user@whisky:27017/test\' );\r\n\r\n$db = $m->test2;\r\n$db->authenticate(\'user2\', \'user2\' );\r\n$collection = $db->collection;\r\n$collection->findOne();\r\n\r\nforeach ( $m->getConnections() as $c )\r\n{\r\n    echo $c[\'hash\'], \"\\n\";\r\n}\r\n```\r\n\r\n输出:\r\n```\r\nwhisky:27017;-;test/user/602b672e2fdcda7b58a042aeeb034376;26983 whisky:27017;-;test2/user2/984b6b4fd6c33f49b73f026f8b47c0de;26983\r\n```\r\n\r\n现在管理器中有两个已验证的连接\r\n顺便提一句，如果你打开了E_DEPRECATED级别的错误提示，则会看到:\r\n```\r\nDeprecated: Function MongoDB::authenticate() is deprecated in …/mongo-connect-6.php.txt on line 5\r\n```\r\n\r\n驱动建议通过创建两个MongoClient对象完成该类任务：\r\n```\r\n$mTest1 = new MongoClient( \'mongodb://user:user@whisky:27017/test\', array( \'connect\' => false ) );\r\n$mTest2 = new MongoClient( \'mongodb://user2:user2@whisky:27017/test2\', array( \'connect\' => false ) );\r\n\r\n$mTest1->test->test->findOne();\r\n$mTest2->test2->test->findOne();\r\n\r\nforeach ( $mTest2->getConnections() as $c )\r\n{\r\n    echo $c[\'hash\'], \"\\n\";\r\n}\r\n```\r\n\r\n单个MongoDB服务器能支持的并发连接相当有限，如果使用PHP-FPM的话，每个worker进程有自己独立的连接池，那么很容易达到连接数的上限。因此，在生产环境中，不管有没有使用复制集，都要部署mongos，然后PHP-FPM连接mongos，这样可以减少mongod的连接数，并且PHP-FPM和mongos之间可以使用短连接(即每个请求结束时都显式调用close函数关闭MongoDB连接)。\r\n\r\n原文链接：http://derickrethans.nl/mongodb-connection-handling.html\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(32,'php数组','32',1427464800,1427464824,'<!--markdown-->php数组是php强大的特性之一，我们来看一看\r\n\r\n\r\n<!--more-->\r\n\r\n```php\r\n// 数组函数讲解\r\n \r\n//count\r\n//array_key_exists  检查给定的键名或索引是否存在于数组中\r\n//array_flip        交换数组中的键和值\r\n//in_array          检查数组中是否存在某个值\r\n//range             建立一个包含指定范围单元的数组 \r\n// shuffle          打乱数组\r\n// array_unique     移除数组中重复的值\r\n// array_reverse    返回一个单元顺序相反的数组 \r\n/* array_push       将一个或多个单元压入数组的末尾 还不如用 $array[] =（入栈） \r\narray_pop                 将数组最后一个单元弹出（出栈）\r\narray_shift               将数组开头的单元移出数组 \r\narray_unshift             在数组开头插入一个或多个单元 所有的数值键名将修改为从零开始重新计数，\r\n                                                     所有的文字键名保持不变。 \r\n                                                     返回 array 数组新的单元数目。 \r\n*/\r\n//sort              对数组排序\r\n//asort             对数组进行排序并保持索引关系\r\n//ksort             对数组按照键名排序\r\n// array_values     返回数组中所有的值\r\n// natsort —        用“自然排序”算法对数组排序\r\n// natcasesort  —   用“自然排序”算法对数组进行不区分大小写字母的排序\r\n// uasort —         使用用户自定义的比较函数对数组中的值进行排序并保持索引关联\r\n// usort            使用用户自定义的比较函数对数组中的值进行排序\r\n \r\n \r\n// array_multisort — 对多个数组或多维数组进行排序\r\n// array_slice —    从数组中取出一段\r\n// array_splice — 把数组中的一部分去掉并用其它值取代\r\n// array_combine — 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值\r\n// array_merge —    合并一个或多个数组如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。\r\n//                  然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。 \r\n \r\n//                 如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引\r\n// array_intersect — 计算数组的交集\r\n// array_diff — 计算数组的差集\r\n// array_rand — 从数组中随机取出一个或多个单元\r\n// array_sum — 计算数组中所有值的和\r\n// array array_keys ( array $input [, mixed $search_value [, bool $strict ]]\r\n// 如果指定了可选参数  search_value，则只返回该值的键名。否则 input 数组中的所有键名都会被返回。\r\n// 自 PHP 5 起，可以用  trict 参数来进行全等比较（===）。\r\n \r\n// array_search —        在数组中搜索给定的值，如果成功则返回相应的键名\r\n// array_count_values    统计数组中所有的值出现的次数\r\n// array_filter —        用回调函数过滤数组中的单元\r\n// array_walk            对数组中的每个成员应用用户函数(一般情况用户函数接受两个参数如用户函数有第三个参数可以用第三个函数传递)\r\n// array_map —          将回调函数作用到给定数组的单元上array_map() 返回一个数组，该数组包含了 arr1 中的所有单元经过 callback 作用过之后的单元。\r\n//                      callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。 \r\n \r\n \r\n/*\r\n count 函数\r\n作用:计算数组的单元个数[或对象的属性个数]\r\n \r\n注:count函数的参数,可以是数组,也可以是\"非数组\"\r\n返回值分3种情况讨论\r\n1: 数组/对象, 返回数组的单元个数/对象的属性个数\r\n2: NULL ,返回0\r\n3: 非数组,也非NULL,通通返回1\r\n4.第二个参数代表是否递归计算多维数组的个数。\r\n*/\r\n \r\n \r\n$arr = array(\'a\',\'b\',\'c\',\'d\');\r\necho count($arr),\'<br />\'; // 4\r\n \r\n$arr = array(\'a\',\'b\',\'c\',array(\'d\',\'e\')); // 6\r\necho count($arr,true).\'<br/>\';\r\n \r\n/* array_key_exists 与isset区别\r\narray_key_exists 是对数组键的一个检查。\r\nisset当值为null是返回false\r\n*/\r\n$search_array = array(\'first\' => null, \'second\' => 4);\r\n// returns false\r\nvar_dump(isset($search_array[\'first\']));\r\n \r\n// returns true\r\narray_key_exists(\'first\', $search_array);\r\n \r\n// array_flip\r\n// 交换键值, 即值做键,键做值\r\n \r\n$arr = array(0=>\'a\',1=>\'b\',2=>\'b\',3=>\'c\');\r\nprint_r($arr);\r\nprint_r(array_flip($arr));  //当后面键名重复，后面会覆盖前面的\r\n \r\n//写一个函数判断某个值在不在数组中\r\nfunction inarr($arr,$val){\r\n    $find=false;\r\n    foreach ($arr as $v){\r\n        if($val===$v){\r\n            $find=true;\r\n        }\r\n        return $find;\r\n    }\r\n}\r\n$val=\'a\';\r\nvar_dump(inarr($arr, $val));\r\n//也可以用in_array\r\nvar_dump(in_array($val,$arr));\r\n \r\n//range() : 生成一个指定范围的数组\r\n$arr = range(1,10,2);  //第三个参数是步长\r\nprint_r($arr);\r\necho array_sum($arr);\r\n// shuffle打乱数组\r\nif(shuffle($arr)) {\r\n    echo \'打乱成功\';\r\n    print_r($arr);  // 数组本身被打乱了,因为shuffle函数,是引用传值\r\n}\r\n \r\n//写一个函数去重复的值\r\n$arr = array(\'a\',\'b\',\'a\',\'c\',\'d\',\'e\',\'f\',\'f\',\'f\');\r\nfunction uni($arr){\r\n    $temp=array();\r\n    foreach ($arr as $v){\r\n        if(!in_array($v, $temp)){\r\n            $temp[]=$v;\r\n        }else{\r\n            continue;\r\n        }\r\n    }\r\n    return $temp;\r\n}\r\n \r\nprint_r(uni($arr));\r\n \r\n//用系统函数\r\nprint_r(array_unique($arr));\r\n \r\n$arr = array(\'a\'=>\'春\',\'b\'=>\'夏\',\'c\'=>\'秋\',\'d\'=>\'冬\');\r\nprint_r(array_reverse($arr)); //此时,对于索引数组,索引没调过来,只调换的值\r\nprint_r(array_reverse($arr),true);   //索引也调换了\r\n \r\n/* 队列,就像人排队来新人,站队伍的后面  先进先出*/\r\n// 栈: 就像从枪口上子弹，后进先出\r\n/* 数组完全可以达到队列和栈的效果\r\n需要用到以下几个函数\r\narray_push\r\narray_pop\r\narray_shift\r\narray_unshift */\r\n/**\r\n 从后往前读数组,读出来的单元,追加到一个备用数组里\r\n **/\r\n$arr = array(\'a\'=>\'春\',\'b\'=>\'夏\',\'c\'=>\'秋\',\'d\'=>\'冬\');\r\nfunction rev2($arr) {\r\n    $rev = array();\r\n    while(count($arr)) {\r\n        $v = array_pop($arr); //弹出\r\n        array_push($rev,$v);  //最加\r\n    }\r\n    return $rev;\r\n}\r\n//用数组知识完成下题\r\n//把 \'1234567\'转换成\'1,234,567\'\r\n \r\nfunction formatstr($str){\r\n    $bak=array();\r\n    $arr=str_split($str);   //1,2,3,4,5,6,7\r\n    $i=0;\r\n    while(!!$cnt=count($arr)){\r\n        array_unshift($bak, array_pop($arr));  //将$arr数组末尾弹出加入到$bak数组中\r\n        $i++;\r\n        if($i%3==0&&$cnt!=1){   //$cnt!=1防止出现第一个字符就是，号\r\n            array_push($arr, \',\');\r\n        }\r\n        \r\n    }\r\n    return implode($bak);\r\n}\r\n$str = \'1234567\';\r\nprint_r(formatstr($str));\r\necho \'<br />\'; // 1,234,567\r\n// 用系统函数\r\n \r\nprint_r(number_format($str));\r\n \r\n \r\n//array_key 第三个参数匹配第二个参数类型要相同\r\n$lamp = array(\"a\"=>\"Linux\",\"b\"=>\"Apache\",\"c\"=>\"MySQL\",\"d\"=>\"PHP\" );\r\nprint_r( array_keys($lamp) );          //输出：Array ( [0] => a [1] => b [2] => c )\r\nprint_r( array_keys($lamp,\"Apache\") ); //使用第二个可选参数输出：Array ( [0] => b)\r\n \r\n$a = array(10, 20, 30, \"10\");          //声明一个数组，其中元素的值有整数10和字符串”10”\r\nprint_r( array_keys($a,\"10\",false) );  //使用第三个参数 (false)输出：Array ( [0] => 0 [1] => 3 )\r\n \r\n$a = array(10, 20, 30, \"10\");          //声明一个数组，其中元素的值有整数10和字符串”10”\r\nprint_r( array_keys($a,\"10\",true) );   //使用第三个参数 (true)输出：Array ( [0] => 3)\r\n \r\n$array = array( 1, \"php\", 1, \"mysql\", \"php\" );  //声明一个带有重复值的数组\r\n$newArray = array_count_values( $array );       //统计数组$array中所有值出现的次数\r\nprint_r( $newArray );                           //输出：Array([1] => 2 [php] => 2 [mysql] => 1)\r\n \r\n \r\n//回调数组函数\r\n/**\r\n 自定义函数myFun，为数组过滤设置条件\r\n @param int $var    数组中的一个元素值\r\n @return    bool            如果参数能被2整除则返回真\r\n */\r\nfunction myFun($var){   //过滤条件函数\r\n    if( $var % 2 == 0 )\r\n        return true;\r\n}\r\n \r\n$array = array(\"a\"=>1, \"b\"=>2, \"c\"=>3, \"d\"=>4, \"e\"=>5);\r\nprint_r(array_filter($array,\'myFun\'));\r\n/* 过滤后的结果输出Array ( [b] => 2 [d] => 4 )  */\r\n \r\n \r\n/**\r\n 定义一个可以作为回调的函数，名称为myfun1\r\n @param string  $value  一个字符串参数，接收数组的值\r\n @param string  $key        一个字符串参数，接收数组的键\r\n */\r\nfunction myfun1( $value, $key ) {     //函数要两个参数\r\n    echo \"The key $key has the value $value<br>\";\r\n}\r\n//定义一个数组$lamp\r\n$lamp = array( \"a\"=>\"Linux\", \"b\"=>\"Apache\", \"c\"=>\"Mysql\", \"d\"=>\"PHP\" );\r\narray_walk($lamp, \'myfun1\');   \r\nprint_r($lamp);\r\n \r\n/**\r\n 定义一个可以作为回调的函数，名称为myfun2\r\n @param string  $value  一个字符串参数，接收数组的值\r\n @param string  $key        一个字符串参数，接收数组的键\r\n @param string  $p      一个字符串参数，接收一个自定义的连接符号字符串\r\n */\r\nfunction myfun2( $value, $key, $p)  {\r\n    echo \"$key $p $value <br>\";\r\n}\r\n \r\n//使用array_walk函数传入三个参数\r\narray_walk( $lamp, \"myfun2\", \"has the value\" );\r\n \r\n/* 执行后输出如下结果：\r\na has the value Linux\r\nb has the value Apache\r\nc has the value MySQL\r\nd has the value PHP\r\n*/\r\n \r\n/**\r\n定义一个可以作为回调的函数，名称为myfun3,改变数组元素的值\r\n@param  string  $value  一个引用参数，接收数组变量，请注意&$value传入引用\r\n@param  string  $key        一个字符串参数，接收数组的键\r\n*/\r\nfunction myfun3( &$value, $key ) {\r\n$value = \"Web\";       //将改变原数组中每个元素的值\r\n}\r\n \r\n    //使用array_walk函数传入两个参数，其中第一个参数为引用\r\n    array_walk( $lamp,\"myfun3\" );\r\n \r\n    print_r( $lamp );          //输出：Array ( [a] => Web [b] => Web [c] => Web [d] => Web )\r\n \r\n    function myfun4($v) {\r\n        if ($v === \"MySQL\") {                   //如果数组中元素的值恒等于MySQL条件成功\r\n            return \"Oracle\";                    //返回Oracle\r\n        }\r\n        return $v;                              //不等于MySQL的元素都返回传入的值，即原型返回\r\n    }\r\n     \r\n    //声明一个有4个元素的数组$lamp\r\n    $lamp = array( \"Linux\", \"Apache\", \"MySQL\", \"PHP\" );\r\n     \r\n    //使用array_map()函数传入一个函数名和一个数组参数\r\n    print_r( array_map( \"myfun4\", $lamp ) );\r\n     \r\n    /*上面程序执行后输出Array ( [0] => Linux [1] => Apache [2] => Oracle [3] => PHP ) */\r\n    /**\r\n     声明一个函数使用多个参数, 回调函数接受的参数数目应该和传递给array_map()函数的数组数目一致\r\n     自定义一个函数需要两个参数，两个数组中的元素依次传入\r\n     @param mixed   $v1 数组中前一个元素的值\r\n     @param mixed   $v2 数组中下一个元素的值\r\n     @return    string      提示字符串\r\n    */\r\n    function myfun5( $v1, $v2 ) {\r\n        if ($v1 === $v2) {                      //如果两个数组中的元素值相同则条件成功\r\n            return \"same\";                      //返回same, 说明两个数组中对应的元素值相同\r\n        }\r\n        return \"different\";                     //如果两个数组中对应的元素值不同，返回different\r\n    }\r\n     \r\n    $a1 = array(\"Linux\", \"PHP\", \"MySQL\");       //声明数组$a1,有三个元素\r\n    $a2 = array(\"Unix\", \"PHP\", \"Oracle\");       //数组$a第二个元素值和$a中第二个元素的值相同\r\n     \r\n    print_r( array_map( \"myfun5\", $a1, $a2) );  //使用array_map()函数传入多个数组\r\n     \r\n    /*上面程序执行后输出：Array ( [0] => different [1] => same [2] => different ) */\r\n     \r\n    //当自定义函数名设置为 null 时的情况\r\n    $a1 = array(\"Linux\", \"Apache\");             //声明一个数组$a1, 有两个元素\r\n    $a2 = array(\"MySQL\", \"PHP\");                //声明另一个数组$a2,也有两个元素\r\n     \r\n    print_r( array_map( null, $a1, $a2) );      //通过第一个参数设置为NULL，构造一个数组的数组\r\n     \r\n    /*   上面程序执行后输出：Array (\r\n     [0] => Array ( [0] => Linux [1] => MySQL )\r\n            [1] => Array ( [0] => Apache [1] => PHP ) )\r\n    */\r\n     \r\n    $input = array( \"Linux\", \"Apache\", \"MySQL\", \"PHP\" );\r\n    //原数组中的第二个元素后到数组结尾都被删除\r\n    array_splice($input, 2);\r\n    print_r($input);                        //输出：Array ( [0] => Linux [1] => Apache )\r\n     \r\n    $input = array(\"Linux\", \"Apache\", \"MySQL\", \"PHP\");\r\n    //从第二个开始移除直到数组末尾倒数第1个为止中间所有的元素\r\n    array_splice($input, 1, -1);\r\n    print_r($input);                        //输出：Array ( [0] => Linux [1] => PHP )\r\n \r\n     \r\n     \r\n    $a1 = array( \"OS\", \"WebServer\", \"DataBase\", \"Language\" ); //声明第一个数组作为参数1\r\n    $a2 = array( \"Linux\", \"Apache\", \"MySQL\", \"PHP\");          //声明第二个数组作为参数2\r\n     \r\n    print_r( array_combine( $a1, $a2 ) );                     //使用arrray_combine()将两个数组合并\r\n     \r\n    /* 输出：Array ( [OS] => Linux [WebServer] => Apache [DataBase] => MySQL [Language] => PHP ) */\r\n     \r\n     \r\n     \r\n    $a1 = array( \"a\"=>\"Linux\", \"b\"=>\"Apache\" );\r\n    $a2 = array( \"c\"=>\"MySQL\", \"b\"=>\"PHP\" );  \r\n    print_r( array_merge( $a1, $a2 ) ); //输出： Array ( [a] => Linux [b] => PHP [c] => MySQL )\r\n     \r\n    //仅使用一个数组参数则键名以0开始进行重新索引\r\n    $a = array( 3=>\"PHP\", 4=>\"MySQL\" );\r\n     \r\n    print_r( array_merge( $a ) );       //输出：Array ( [0] => PHP [1] => MySQL )\r\n     \r\n     \r\n     \r\n    $lamp = array( \"a\"=>\"Linux\", \"b\"=>\"Apache\", \"c\"=>\"MySQL\", \"d\"=>\"PHP\" );\r\n    echo array_rand( $lamp,1 );             //随机从数组$lamp中取1个元素的键值，例如b\r\n    echo $lamp[array_rand($lamp)].\"<br>\";     //通过随机的一个元素的键值获取数组中一个元素的值\r\n     \r\n    $key = array_rand( $lamp,2 );           //随机从数组$lamp中取2个元素的键值赋给数组$key\r\n     \r\n    echo $lamp[$key[0]].\"<br>\";           //通过数组$key中第一个值获取数组$lamp中一个元素的值\r\n    echo $lamp[$key[1]].\"<br>\";           //通过数组$key中第二个值获取数组$lamp中另一个元素的值\r\n     \r\n     \r\n     \r\n     \r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(33,'lnmp架构下php安全配置分享','33',1427548320,1427549783,'<!--markdown-->以往的lamp网站向着lnmp发展, 笔者工作环境使用lnmp多年, 在这里很高兴和大家分享一下多年的lnmp网站的php安全配置，至于lamp安全后续与大家分享，其实内容上八成相同，这边着重讲php安全配置，看内容.\r\n\r\n\r\n<!--more-->\r\n\r\n###  1. 使用open_basedir限制虚拟主机跨目录访问\r\n```php\r\n[HOST=blog.chromev.com]\r\nopen_basedir=/data/site/blog.chromev.com/:/tmp/\r\n```\r\n如上配置的意思是blog.chromev.com下的php程序被限制在open_basedir配置的两个目录下, 不可以访问到其他目录。如果没有做以上的配置，那么blog.chromev.com与www.chromev.com的程序可以互相访问.\r\n如果其中一个站点有漏洞被黑客植入了webshell，那么他可以通过这个站点拿下同一台服务器的其他站点，最后挂木马.\r\n**注意：目录最后一定要加上/. 比如你写/tmp，你的站点同时存在/tmp123等等以/tmp开头的目录，那么黑客也可以访问到这些目录，另外, php5.3以上支持这个写法，5.2不支持。**\r\n\r\n###  2禁用不安全PHP函数\r\n```\r\ndisable_functions = show_source,system,shell_exec,passthru,exec,popen,proc_open,proc_get_status,phpinfo\r\n```\r\n\r\n禁止php执行以上php函数,以上php程序可以执行linux命令, 比如可以执行ping、netstat、mysql等等.如果你的系统有提权bug,后果你懂得.\r\n\r\n### 3. 关注软件安全资讯\r\n积极关注linux内核、php安全等信息并及时采取错误\r\n\r\n### 4. php用户只读\r\n这 个方法是我最推崇的方法，但是执行之前一定要和php工程师商量. 为什么？例如站点www.chromev.com根目录用户与组为nobody，而运行php的用户和组为phpuser。目录权限为755，文件权限为 644. 如此，php为只读，无法写入任何文件到站点目录下。也就是说用户不能上传文件，即使有漏洞, 黑客也传不了后门, 更不可能挂木马.  这么干之前告知程序员将文件缓存改为nosql内存缓存（例如memcached、redis等），上传的文件通过接口传到其他服务 器（静态服务器）。\r\n\r\n**备注：程序生成本地缓存是个非常糟糕的习惯，使用文件缓存速度缓慢、浪费磁盘空间、最重要一点是一般情况下服务器无法横向扩展**\r\n\r\n### 5.关闭php错误日志\r\n```\r\ndisplay_errors = On\r\n改为\r\ndisplay_errors = Off\r\n```\r\n程序一旦出现错误，详细错误信息便立刻展示到用户眼前，其中包含路径、有的甚至是数据库账号密码. 注入渗透密码基本上都是通过这个报错来猜取。生产环境上强烈关闭它\r\n\r\n### 6.php上传分离\r\n将文件上传到远程服务器，例如nfs等。当然也可以调用你们写好的php接口. 即使有上传漏洞，那么文件也被传到了静态服务器上。木马等文件根本无法执行.\r\n\r\n举个例子：\r\nphp站点blog.chromev.com，目录/data/site/blog.chromev.com\r\n静态文件站点static.chromev.com，目录/data/site/static.chromev.com\r\n\r\n文件直接被传到了/data/site/static.chromev.com，上传的文件无法通过blog.chromev.com来访问，只能使用static.chromev.com访问，但是static.chromev.com不支持php.\r\n\r\n### 7关闭php信息\r\n```\r\nexpose_php = On\r\n改为\r\nexpose_php = Off\r\n```\r\n\r\n不轻易透露自己php版本信息，防止黑客针对这个版本的php发动攻击.\r\n\r\n### 8. 禁止动态加载链接库\r\n\r\n```\r\ndisable_dl = On;\r\n改为\r\nenable_dl = Off;\r\n```\r\n\r\n### 9. 禁用打开远程url\r\n```\r\nallow_url_fopen = On\r\n改为\r\nallow_url_fopen = Off\r\n```\r\n\r\n其实这点算不上真正的安全, 并不会导致web被入侵等问题,但是这个非常影响性能, 笔者认为它属于狭义的安全问题.\r\n\r\n以下方法将无法获取远程url内容\r\n```\r\n$data = file_get_contents(\"http://www.baidu.com/\")；\r\n```\r\n\r\n以下方法可以获取本地文件内容\r\n```\r\n$data = file_get_contents(\"1.txt\");\r\n```\r\n\r\n如果你的站点访问量不大、数据库也运行良好，但是web服务器负载出奇的高，请你直接检查下是否有这个方法。笔者遇到过太多这个问题，目前生产环境已全线禁用，如果php工程师需要获取远程web的内容，建议他们使用curl.\r\n\r\n原文 http://my.oschina.net/766/blog/156792\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(34,'symfony2框架系列教程1  What is Symfony2 ？','34',1427720820,1427721150,'<!--markdown-->从今天起开始symfony2教程，下个月的目标是学习c和symfony2,用symfony2做一两个项目，那什么是symfony2呢\r\n\r\n**symfony2交流群 139731083**\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n\r\n\r\n**Symfoy2 是什么？**\r\n\r\nPHP世界里又一广受关注的web MVC框架？ Fabien Potencier 却不这么说！\r\n\r\nFabien Potencier这样定义Symfoy2 是个什么东西：　\r\n\r\n　　首先，Symfony2 是一个独立，松散的，有组织严密的PHP组件集合，它可以为你解决一些web开发中遇到的一般性问题。\r\n\r\n　　其次，基于这些组件，Symfoy2 也可以作为一个独立的web框架使用。\r\n\r\n那么Symfony2 是一个MVC框架吗？\r\n\r\nFabien Potencier 说Symfony2从来没有把自己定义为一个MVC框架！\r\n\r\n那它是什么？ Fabien Potencier 我们从来不关心MVC模式，关心的只有各个关注点的分离（separation of concerns）。\r\n\r\n但是Symfony2 还是提供了部分的MVC模式的实现：比如Controller部分，View部分却没有Mode部分不过你可以通过和它紧密继承的ORM（Doctrine2和Propel）实现。\r\n\r\n \r\n\r\n从这个角度看Symfony的确也没有逃出web MVC框架的圈子啊！！！\r\n\r\nFabien Potencier 又说Symfony2从来就没有想靠这些ORM来使自己成为另一个MVC的追随者，我们的目标更远大！\r\n\r\n \r\n\r\n告诉你吧， Symfony2 是一个HTTP框架或者说是一个Request/Response 框架。我们紧盯的目标不是MVC模式，而是HTTP协议，我们是更低级的更基础的框架。\r\n\r\n我们为什么要这么说呢？ 有根据的！\r\n\r\n近几年随着web的发展，有时候你只需要创建一组REST API，所有的逻辑都放到浏览器端，服务器端只提供数据就是一种web了。不信你看 backbone.js ！\r\n\r\n再说了，MVC模式只不过是Web 应用程序的其中一种实现方式罢了。\r\n\r\n剥去所有框架模式的皮，你看看那个web程序不是处理一个接收到的Request然后返回一个Response啊？\r\n\r\n我们Symfony2 抓住的就是web程序的根本！ 再说我们众多的HTTP流媒体有哪个会选择使用MVC呢？\r\n\r\n总之，我们Symfony2比MVC更靠近根本，我们更底层，更通用！！！\r\n\r\n \r\n\r\n说起Symfony2，Fabien Potencier说我们有着更加远大的目标，怎么解释呢？\r\n\r\nSymfony2 将继续专注于Pack技术的研究和创新！我们相信她会继续推动web的向前发展。\r\n\r\n先看看Symfony2 中我们已经包含的创新吧！\r\n\r\n从Bundles，HTTP 缓存，分布式，依赖注入，模板引擎，声明式配置，资产管理，稳定的API到web分析器等等一系列技术都对web的发展起到了巨大的推动作用。\r\n\r\n \r\n\r\n“ 要知道一个独立的框架永远不可能成为PHP世界里的一个标准，所以Symfony2 在探寻另外一条路！”\r\n\r\n“ 共享无处不在。”\r\n\r\n“ 我们不能重复制造轮子。”\r\n\r\n因此，我们紧密的集成了Monolog，Composer，Doctrine，Propel，Assetic，Twig，Swiftmailer等伟大产品。\r\n\r\n更重要的是我们想跟大家分享我们的工作！\r\n\r\n所以，我们最终选择了走组件（components）化这条路！\r\n\r\n我们将为一切web项目提供建筑模块，无论是个人项目还是商业项目，更或者是开源项目！\r\n\r\n \r\n\r\n据说在Symfony2 的代码中可能会有标志为@api的类或者方法，它意味着一个方法从名字到参数以及返回值都不会因为Symfony2发展版本而变化，所以，如果\r\n\r\n你的项目只使用了这些，那么你就不用担心Symfony2的版本升级问题。\r\n\r\n \r\n\r\n看看Symfony2 现在拥有的组件吧：\r\n```\r\nDependencyInjection\r\nEventDispatcher\r\nHttpFoundation\r\nDomCrawler\r\nClassLoader\r\nCssSelector\r\nHttpKernel\r\nBrowserKit\r\nTemplating\r\nTranslation\r\nSerializer\r\nValidator\r\nSecurity\r\nRouting\r\nConsole\r\nProcess\r\nConfig\r\nFinder\r\nLocale\r\nYaml\r\nForm\r\n```\r\nFabien 简单介绍了几个bundle：\r\n\r\n### 1. ClassLoader：\r\n\r\n　　实现了PSR-o 标准（自动加载具有命名空间的类，适用于PHP5.3以上）的自动加载器，同时它也能按照PEAR命名规则加载类。它非常灵活可以基于子命名空间在不同的目录中查询要加载的类。你甚至可以为一个命名空间指定多个目录。\r\n```\r\nrequire_once __DIR__.\'/src/Symfony/Component/ClassLoader/UniversalClassLoader.php\';\r\n \r\nuse Symfony\\Component\\ClassLoader\\UniversalClassLoader;\r\n \r\n$loader = new UniversalClassLoader();\r\n$loader->registerNamespaces(array(\r\n    \'Symfony\'          => array(__DIR__.\'/src\', __DIR__.\'/symfony/src\'),\r\n    \'Doctrine\\\\Common\' => __DIR__.\'/vendor/doctrine-common/lib\',\r\n    \'Doctrine\\\\DBAL\'   => __DIR__.\'/vendor/doctrine-dbal/lib\',\r\n    \'Doctrine\'         => __DIR__.\'/vendor/doctrine/lib\',\r\n    \'Monolog\'          => __DIR__.\'/vendor/monolog/src\',\r\n));\r\n$loader->registerPrefixes(array(\r\n    \'Twig_\' => __DIR__.\'/vendor/twig/lib\',\r\n));\r\n$loader->register();\r\n```\r\n\r\n如果你想获取更加高的执行效率，可以选择使用APC缓存版Universal类加载器。\r\n    \r\n\r\n### 2.Console 命令行工具\r\n\r\n在创建web应用程序时使用命令行工具很方便，你可以想如下代码一样创建自己的命令行工具：\r\n\r\n```\r\nuse Symfony\\Component\\Console\\Application;\r\nuse Symfony\\Component\\Console\\Input\\InputInterface;\r\nuse Symfony\\Component\\Console\\Input\\InputArgument;\r\nuse Symfony\\Component\\Console\\Input\\InputOption;\r\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\r\n \r\n$console = new Application();\r\n$console\r\n    ->register(\'ls\')\r\n    ->setDefinition(array(\r\n        new InputArgument(\'dir\', InputArgument::REQUIRED, \'Directory name\'),\r\n    ))\r\n    ->setDescription(\'Displays the files in the given directory\')\r\n    ->setCode(function (InputInterface $input, OutputInterface $output) {\r\n        $dir = $input->getArgument(\'dir\');\r\n \r\n        $output->writeln(sprintf(\'Dir listing for <info>%s</info>\', $dir));\r\n    })\r\n;\r\n$console->run();\r\n```\r\n\r\n### 3.YAML  一种现在很流行的配置格式。\r\n```\r\nuse Symfony\\Component\\Yaml\\Yaml;\r\n \r\n$array = Yaml::parse($file);\r\n \r\nprint Yaml::dump($array);\r\n```\r\n\r\n### 4. Finder 优秀文件资源的操作接口。\r\n```\r\nuse Symfony\\Component\\Finder\\Finder;\r\n \r\n$finder = new Finder();\r\n \r\n$iterator = $finder\r\n  ->files()\r\n  ->name(\'*.php\')\r\n  ->depth(0)\r\n  ->size(\'>= 1K\')\r\n  ->in(__DIR__);\r\n \r\nforeach ($iterator as $file) {\r\n    print $file->getRealpath().\"\\n\";\r\n}\r\n```\r\n\r\n### 5.Process 进程组件，你可以用来在一个外部进程中执行命令！下面例子是执行一个简单的目录列表命令并返回结果：\r\n\r\n```\r\nuse Symfony\\Component\\Process\\Process;\r\n \r\n$process = new Process(\'ls -lsa\');\r\n$process->setTimeout(3600);\r\n$process->run();\r\nif (!$process->isSuccessful()) {\r\n    throw new RuntimeException($process->getErrorOutput());\r\n}\r\n \r\nprint $process->getOutput();\r\n```\r\n\r\n\r\n### 6. HttpFoundation \r\n该组件只是在PHP的相关web内容上面增加了一个面向对象层，包括Request，Response，Uploaded files,Cookies,Sessions...\r\n```\r\nuse Symfony\\Component\\HttpFoundation\\Request;\r\nuse Symfony\\Component\\HttpFoundation\\Response;\r\n \r\n$request = Request::createFromGlobals();\r\necho $request->getPathInfo();\r\n```\r\n你用它可以很容易的创建自己的Request 和 Response：\r\n```\r\n$request = Request::create(\'/?foo=bar\', \'GET\');\r\necho $request->getPathInfo();\r\n\r\n\r\n$response = new Response(\'Not Found\', 404, array(\'Content-Type\' => \'text/plain\'));\r\n$response->send();\r\n```\r\n\r\n\r\n### 7.Routing \r\n路由组件和Request对象是相互配合着把Request转换为Response。\r\n```\r\nuse Symfony\\Component\\HttpFoundation\\Request;\r\nuse Symfony\\Component\\Routing\\Matcher\\UrlMatcher;\r\nuse Symfony\\Component\\Routing\\RequestContext;\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n \r\n$routes = new RouteCollection();\r\n$routes->add(\'hello\', new Route(\'/hello\', array(\'controller\' => \'foo\')));\r\n \r\n$context = new RequestContext();\r\n \r\n// this is optional and can be done without a Request instance\r\n$context->fromRequest(Request::createFromGlobals());\r\n \r\n$matcher = new UrlMatcher($routes, $context);\r\n \r\n$parameters = $matcher->match(\'/hello\');\r\n```\r\n\r\n### 8. 事件EventDispatcher\r\n```\r\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\r\nuse Symfony\\Component\\EventDispatcher\\Event;\r\n \r\n$dispatcher = new EventDispatcher();\r\n \r\n$dispatcher->addListener(\'event_name\', function (Event $event) {\r\n    // ...\r\n});\r\n \r\n$dispatcher->dispatch(\'event_name\');\r\n```\r\n\r\n下面使用Symfony2 组件来创建一个简单的框架：\r\n```\r\n$routes = new RouteCollection();\r\n$routes->add(\'hello\', new Route(\'/hello\', array(\'_controller\' =>\r\n    function (Request $request) {\r\n        return new Response(sprintf(\"Hello %s\", $request->get(\'name\')));\r\n    }\r\n)));\r\n \r\n$request = Request::createFromGlobals();\r\n \r\n$context = new RequestContext();\r\n$context->fromRequest($request);\r\n \r\n$matcher = new UrlMatcher($routes, $context);\r\n \r\n$dispatcher = new EventDispatcher();\r\n$dispatcher->addSubscriber(new RouterListener($matcher));\r\n \r\n$resolver = new ControllerResolver();\r\n \r\n$kernel = new HttpKernel($dispatcher, $resolver);\r\n \r\n$kernel->handle($request)->send();\r\n```\r\n\r\nok， 这就是框架了！\r\n\r\n如果想添加一个HTTP反向代理以获取HTTP caching和ESI（Edge Side Includes）带来的好处，那么这样做！\r\n\r\n```\r\n$kernel = new HttpKernel($dispatcher, $resolver); \r\n \r\n$kernel = new HttpCache($kernel, new Store(__DIR__.\'/cache\'));\r\n```\r\n\r\n想对它做一下功能测试：\r\n```\r\n$client = new Client($kernel);\r\n$crawler = $client->request(\'GET\', \'/hello/Fabien\');\r\n \r\n$this->assertEquals(\'Fabien\', $crawler->filter(\'p > span\')->text());\r\n```\r\n\r\n想要一个好看的错误展示页面？\r\n```\r\n$dispatcher->addSubscriber(new ExceptionListener(function (Request $request) {\r\n    $msg = \'Something went wrong! (\'.$request->get(\'exception\')->getMessage().\')\';\r\n \r\n    return new Response($msg, 500);\r\n}));\r\n```\r\n\r\n\r\n总结一下，Symfony2 很强，像yii也有很多是借鉴symfony,包换zend',0,1,NULL,'post','publish',NULL,2,'1','1','1',0),(35,'Symfony2 学习笔记之系统路由','35',1427890080,1427890216,'<!--markdown-->漂亮的URL绝对是一个严肃的web应用程序必须做到的，这种方式使index.php?article_id=57这类的丑陋URL被隐藏，由更受欢迎的像 /read/intro-to-symfony 来替代。\r\n\r\n　　拥有灵活性更为重要，如果你要改变一个页面的URL，比如从/blog 到 /new 怎么办？\r\n　　有多少链接需要你找出来并更新呢？ 如果你使用Symfony的router，这种改变将变得很简单。\r\n\r\n　　Symfony2 router让你定义更具创造力的URL，你可以map你的应用程序的不同区域。\r\n　　创建复杂的路由并map到controllers并可以在模板和controllers内部生成URLs\r\n　　从bundles（或者其他任何地方）加载路由资源\r\n　　调试你的路由\r\n\r\n\r\n<!--more-->\r\n\r\n### 路由活动\r\n　　一个路径是一个从URL 模式到一个controller的绑定。\r\n　　比如假设你想匹配任何像 /blog/my-post 或者 /blog/all-about-symfony的路径并把它们发送到一个controller在那里可以查找并渲染blog实体。\r\n该路径很简单：\r\nYAML格式：\r\n```\r\n# app/config/routing.yml\r\nblog_show:\r\npattern: /blog/{slug}\r\ndefaults: {_controller: AcmeBlogBundle:Blog:show }\r\n```\r\n\r\nPHP代码格式：\r\n```\r\n// app/config/routing.php\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'blog_show\', new Route(\'/blog/{slug}\', array(\r\n         \'_controller\' => \'AcmeBlogBundle:Blog:show\',\r\n)));\r\n```\r\n\r\n　blog_show路径定义了一个URL模式，它像/blog/* 这里的通配符被命名为slug。对于URL/blog/my-blog-post，slug变量会得到值 my-blog-post。\r\n\r\n　　_controller参数是一个特定的键，它告诉Symfogy当一个URL匹配这个路径时哪个controller将要被执行。\r\n　　_controller字符串被称为逻辑名。它的值会按照特定的模式来指定具体的PHP类和方法。\r\n\r\n```\r\n// src/Acme/BlogBundle/Controller/BlogController.php\r\n\r\nnamespace Acme\\BlogBundle\\Controller;\r\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\r\n\r\nclass BlogController extends Controller\r\n{\r\n    public function showAction($slug)\r\n    {\r\n        $blog = // use the $slug variable to query the database\r\n\r\n        return $this->render(\'AcmeBlogBundle:Blog:show.html.twig\', array(\r\n            \'blog\' => $blog,\r\n        ));\r\n    }\r\n}\r\n```\r\n\r\n\r\n　现在当你再访问/blog/my-post 时，showAction controller将被执行并且$slug变量的值为my-post\r\n\r\n　　Symfogy2 的路由器目标：映射一个请求的URL到controller。\r\n\r\n\r\n### 路由：内部的秘密\r\n　　当一个请求发送到应用程序时，它包含一个客户端想要获取资源的地址。这个地址叫做URL或者URI。可能是/contact,/blog/read-me或者其它样式。\r\n　　GET /blog/my-blog-post\r\n　　Symfony2 路由系统的目标是解析这些URL并决定哪个controller应该被执行来回复该请求。\r\n　　整个路由过程可以分为：\r\n　　　　1.请求被Symfony2的前端控制器（app.php)处理。\r\n　　　　2.Symfony2核心（kernel)要求路由器检查请求。\r\n　　　　3.路由器匹配接收到的URL到一个特定的路径并返回有关信息，包括应该被执行的controller。\r\n　　　　4.Symfony2核心执行该controller，该controller最终会返回一个Response对象。\r\n　　路由器层就是一个把接收到的URL转换为要执行的特定controller的工具。\r\n\r\n创建路由\r\n　　Symfony会从一个单独的路由配置文件中加载你应用程序的所有路由。该文件通常为 app/config/routing.yml。 它可以被配置成包括XML或者PHP文件等文件。\r\nYAML格式：\r\n```\r\n# app/config/config.yml\r\nframework:\r\n    # ...\r\n    router:        { resource: \"%kernel.root_dir%/config/routing.yml\" }\r\n```\r\nPHP代码格式：\r\n```\r\n// app/config/config.php\r\n$container->loadFromExtension(\'framework\', array(\r\n    // ...\r\n    \'router\'        => array(\'resource\' => \'%kernel.root_dir%/config/routing.php\'),\r\n));\r\n```\r\n\r\n基础路由配置\r\n　　定义一个路由很简单，通常一个应用程序拥有很多路由。一个基础路由是由两部分组成：pattern部分和defaults数组部分。\r\n比如：\r\nYAML格式：\r\n```\r\n_welcome:\r\n    pattern:   /\r\n    defaults:  { _controller: AcmeDemoBundle:Main:homepage }\r\n```\r\n\r\n\r\nPHP代码格式：\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'_welcome\', new Route(\'/\', array(\r\n    \'_controller\' => \'AcmeDemoBundle:Main:homepage\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n　　该路由匹配首页(/)并映射到AcmeDemoBundle:Main:homepage controller。_controller字符串被Symfony2翻译成一个相应的PHP函数并被执行。\r\n\r\n### 带占位符路由\r\n　　当然，路由系统支持更多有趣的路由。许多路由会包含一个或者多个被命名的通配符占位符。\r\nYAML格式：\r\n```\r\nblog_show:\r\n    pattern:   /blog/{slug}\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:show }\r\n```\r\n\r\nPHP代码格式：\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'blog_show\', new Route(\'/blog/{slug}\', array(\r\n    \'_controller\' => \'AcmeBlogBundle:Blog:show\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n该模式将匹配任何类似/blog/*形式的URL。匹配占位符{slug}的值将会在controller中被使用。换句话说，如果URL是/blog/hello-world,\r\n则$slug变量值是hello-world， 该值将能在controller中被使用。该模式不会匹配像/blog, 因为默认情况下所有的占位符都是必须的。 当然可以通过在defaults数组中给这些占位符赋来改变它。\r\n\r\n### 必需和可选占位符\r\n　　我们来添加一个新的路由，显示所有可用的blog列表。\r\nYAML格式\r\n```\r\nblog:\r\n    pattern:   /blog\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:index }\r\n```\r\n\r\n到目前为止，我们的路由都是非常简单的路由模式。它们包含的非占位符将会被精确匹配。\r\n\r\n　　如果你想该路由能够支持分页，比如让/blog/2 显示第二页的blog,那就需要为之前的路由添加一个新的{page}占位符。\r\nYAML格式：\r\n\r\n```\r\nblog:\r\n    pattern:   /blog/{page}\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:index }\r\n```\r\n\r\nPHP代码格式：\r\n\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'blog\', new Route(\'/blog/{page}\', array(\r\n    \'_controller\' => \'AcmeBlogBundle:Blog:index\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n跟之前的{slug}占位符一样{page}占位符将会在你的controller内部可用，它的值可以用于表示要显示的blog值的页码。但是要清楚，因为占位符默认情况下都是必需的，该路由也将不再匹配之前的/blog URL，这时候你如果还像看第一页的话，就必须通过/blog/1 URL来访问了。要解决该问题，可以在该路由的defaults数组中指定{page}的默认值。\r\n\r\nYAML格式：\r\n```\r\nblog:\r\n    pattern:   /blog/{page}\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:index, page: 1 }\r\n```\r\n\r\nPHP\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'blog\', new Route(\'/blog/{page}\', array(\r\n    \'_controller\' => \'AcmeBlogBundle:Blog:index\',\r\n    \'page\' => 1,\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n通过添加page到defaults键， {page}占位符就不再是必需的。这时候 /blog将会被匹配并且page参数被设置为1，URL /blog/2 也会被匹配。\r\n\r\n### 添加要求约束\r\n\r\n看看下面这些路由：\r\nYAML格式：\r\n```\r\nblog:\r\n    pattern:   /blog/{page}\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:index, page: 1 }\r\n\r\nblog_show:\r\n    pattern:   /blog/{slug}\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:show }\r\n```\r\n\r\nPHP代码格式：\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'blog\', new Route(\'/blog/{page}\', array(\r\n    \'_controller\' => \'AcmeBlogBundle:Blog:index\',\r\n    \'page\' => 1,\r\n)));\r\n\r\n$collection->add(\'blog_show\', new Route(\'/blog/{show}\', array(\r\n    \'_controller\' => \'AcmeBlogBundle:Blog:show\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n\r\n你发现问题了吗？注意这两个路由都能匹配像/blog/* 类型的URL。Symfony只会选择第一个与之匹配的路由。\r\n\r\n　　换句话说，blog_show将永远不会被像/blog/* 类型的URL匹配。而像 /blog/my-blog-post这样的URL也会被blog路由匹配，并且page变量会获得my-blog-post这样的值。\r\n　　这肯定不可以，那么怎么办呢？答案是给路由添加约束要求requirements。\r\n　　在blog路由中占位符{page}理想状态下只匹配整数值。幸运的是正则表达可以很容易的满足这一要求。\r\nYAML格式：\r\n\r\n```\r\nblog:\r\n    pattern:   /blog/{page}\r\n    defaults:  { _controller: AcmeBlogBundle:Blog:index, page: 1 }\r\n    requirements:\r\n        page:  \\d+\r\n```\r\n\r\nPHP代码格式：\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'blog\', new Route(\'/blog/{page}\', array(\r\n    \'_controller\' => \'AcmeBlogBundle:Blog:index\',\r\n    \'page\' => 1,\r\n), array(\r\n    \'page\' => \'\\d+\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n\r\n　这里 \\d+ 约束是一个正则表达式，它指定了{page}只接受整数。这样像/blog/my-blog-post就不再被匹配了。这时候，它才会被blog_show路由匹配。因为参数的约束都是正则表达式，所以其复杂程度和灵活性都有你来决定了。\r\n\r\n　　假设home页使用两种语言则可以这样配置路由：\r\nYAML格式：\r\n\r\n```\r\nhomepage:\r\n    pattern:   /{culture}\r\n    defaults:  { _controller: AcmeDemoBundle:Main:homepage, culture: en }\r\n    requirements:\r\n        culture:  en|fr\r\n```\r\n\r\nPHP代码格式：\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'homepage\', new Route(\'/{culture}\', array(\r\n    \'_controller\' => \'AcmeDemoBundle:Main:homepage\',\r\n    \'culture\' => \'en\',\r\n), array(\r\n    \'culture\' => \'en|fr\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n### 添加HTTP 方法约束\r\n　　除了URL，你还可以匹配请求的方法（GET,HEAD,POST,PUT,DELETE等）。假设你有一个联系表单有两个controller，一个用于显示表单（使用GET请求）一个用于处理提交的表单（POST请求）。它的配置如下：\r\nYAML格式：\r\n```\r\ncontact:\r\n    pattern:  /contact\r\n    defaults: { _controller: AcmeDemoBundle:Main:contact }\r\n    requirements:\r\n        _method:  GET\r\n\r\ncontact_process:\r\n    pattern:  /contact\r\n    defaults: { _controller: AcmeDemoBundle:Main:contactProcess }\r\n    requirements:\r\n        _method:  POST\r\n```\r\n\r\nPHP\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'contact\', new Route(\'/contact\', array(\r\n    \'_controller\' => \'AcmeDemoBundle:Main:contact\',\r\n), array(\r\n    \'_method\' => \'GET\',\r\n)));\r\n\r\n$collection->add(\'contact_process\', new Route(\'/contact\', array(\r\n    \'_controller\' => \'AcmeDemoBundle:Main:contactProcess\',\r\n), array(\r\n    \'_method\' => \'POST\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n\r\n尽管这两个路由拥有同一个URL模式定义（/contact)，但是第一个路由只会匹配GET请求，而第二个只会匹配POST请求。这就意味着你可以通过同一个URL来显示表单并提交表单，而用不同的controller对他们进行处理。如果没有指定_method约束，那么该路由会匹配所有请求方法。跟其它约束一样，_method约束也接受正则表达式，如果只想匹配GET或者POST那么你可以用GET|POST\r\n\r\n### 高级路由例子：\r\n　　Symfony2中具备一切让你创建任何形式路由的条件。\r\nYAML格式：\r\n```\r\narticle_show:\r\n  pattern:  /articles/{culture}/{year}/{title}.{_format}\r\n  defaults: { _controller: AcmeDemoBundle:Article:show, _format: html }\r\n  requirements:\r\n      culture:  en|fr\r\n      _format:  html|rss\r\n      year:     \\d+\r\n```\r\n\r\nPHP代码格式：\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'homepage\', new Route(\'/articles/{culture}/{year}/{title}.{_format}\', array(\r\n    \'_controller\' => \'AcmeDemoBundle:Article:show\',\r\n    \'_format\' => \'html\',\r\n), array(\r\n    \'culture\' => \'en|fr\',\r\n    \'_format\' => \'html|rss\',\r\n    \'year\' => \'\\d+\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n上面的路由，在匹配时只会匹配{culture}部分值为en或者fr并且{year}的值为数字的URL。该路由还告诉我们，可以用在占位符之间使用区间代替斜线。\r\n\r\n它能够匹配如下URL：\r\n　　/articles/en/2010/my-post\r\n　　/articles/fr/2010/my-post.rss\r\n\r\n　　这其中有个特殊的路由参数 _format，在使用该参数时，其值变为请求格式。这种请求格式相当于Respose对象的Content-Type，比如json请求格式会翻译成一个Content-Type为application/json.该参数可以用于在controller中为每个_format渲染一个不同的模板。它是一个很强的方式来渲染同一个内容到不同的格式。\r\n\r\n\r\n### 特殊的路由参数：\r\n\r\n正如你所看到的，每一个路由参数或者默认值最终都是作为一个controller方法输入参数被使用。另外，有三个参数比较特别，它们每一个都在你的应用程序中增加一个唯一功能。\r\n　　_controller: 这个参数决定了当路由匹配时，哪个controller被执行。\r\n　　_format: 用于设置请求格式。\r\n　　_locale: 用于在session上设置本地化。\r\n\r\n### Controller的命名模式：\r\n\r\n　每一个路由必须有一个_controller参数，它决定了当路由匹配时哪个controller应该被执行。该参数使用单一的字符串模式，被称为logical controller name。\r\n通过它Symfony可以映射到一个特定的PHP方法和类。该模式有三部分，每一部分用冒号分割开：\r\n　　bundle:controller:action\r\n\r\n　　比如_controller 的值为 AcmeBlogBundle:Blog:show 意思是AcmeBlogBundle bundle中BlogController类里面的showAction方法。\r\n\r\n```\r\n// src/Acme/BlogBundle/Controller/BlogController.php\r\n\r\nnamespace Acme\\BlogBundle\\Controller;\r\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\r\n\r\nclass BlogController extends Controller\r\n{\r\n    public function showAction($slug)\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nSymfony会自动把它们的添加相应的后缀，Blog=>BlogController, show => showAction。\r\n\r\n　　你也可以使用它的完全限定名和方法来给_controller赋值，Acme\\BlogBundle\\Controller\\BlogController::showAction 但一般为了简洁灵活而是用逻辑名称。另外除了上面两种形式外，Symfony还支持第三种方式只有一个冒号分割符，如service_name:indexAction来为_controller赋一个作为服务使用的controller。\r\n\r\n### 路由参数和控制器参数\r\n\r\n路由参数非常重要，因为每一个路由参数都会转变成一个控制器参数被在方法中使用。　\r\n```\r\npublic function showAction($slug)\r\n{\r\n  // ...\r\n}\r\n```\r\n\r\n　　事实上，全部的defaults集合和表单的参数值合并到一个单独的数组中。这个数组中的每个键都会成为controller方法的参数。换句话说，你的controller方法的每一个参数，Symfony都会从路由参数中查找并把找到的值赋给给参数。上面例子中的变量 $culture, $year,$title,$_format,$_controller 都会作为showAction()方法的参数。因为占位符和defaults集合被合并到一起，即使$_controller变量也是一样。你也可以使用一个特殊的变量$_route 来指定路由的名称。\r\n\r\n \r\n\r\n### 包括外部路由资源\r\n\r\n所有的路由资源的都是通过一个单一的配置文件导入的。通常是app/config/routing.yml。当然你可能想从别处导入路由资源，比如你定义的bundle中的路由资源，你可以这样导入：\r\nYAML格式：\r\n\r\n```\r\n# app/config/routing.yml\r\nacme_hello:\r\n    resource: \"@AcmeHelloBundle/Resources/config/routing.yml\"\r\n```\r\n\r\n```\r\n// app/config/routing.php\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\n\r\n$collection = new RouteCollection();\r\n$collection->addCollection($loader->import(\"@AcmeHelloBundle/Resources/config/routing.php\"));\r\n\r\nreturn $collection;\r\n```\r\n\r\n在使用YAML导入资源时，键（比如acme_hello)是没有意义的，只是用来保证该资源唯一不被其它行覆盖。使用resources key加载给定的路由资源。在这个示例中资源是一个全路径文件，@AcmeHelloBundle是简写语法，它会被指向bundle路径。被导入的文件内容如下：\r\n\r\nYAML格式：\r\n```\r\n # src/Acme/HelloBundle/Resources/config/routing.yml\r\nacme_hello:\r\n     pattern:  /hello/{name}\r\n     defaults: { _controller: AcmeHelloBundle:Hello:index }\r\n```\r\n\r\n```\r\n// src/Acme/HelloBundle/Resources/config/routing.php\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'acme_hello\', new Route(\'/hello/{name}\', array(\r\n    \'_controller\' => \'AcmeHelloBundle:Hello:index\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n　这个文件中的路由会被解析并跟主要的路由文件内容一起被加载。\r\n\r\n\r\n### 给导入的路由资源添加前缀\r\n　　你可以为导入的路由资源选择一个前缀，比如说假设你想acme_hello路由有一个这样的 匹配模式：/admin/hello/{name} 而不是直接的 /hello/{name}\r\n那么你在导入它的时候可以为其指定prefix。\r\nYAML格式：\r\n```\r\n# app/config/routing.yml\r\nacme_hello:\r\n    resource: \"@AcmeHelloBundle/Resources/config/routing.yml\"\r\n    prefix:   /admin\r\n```\r\n\r\n```\r\n// app/config/routing.php\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\n\r\n$collection = new RouteCollection();\r\n$collection->addCollection($loader->import(\"@AcmeHelloBundle/Resources/config/routing.php\"), \'/admin\');\r\n\r\nreturn $collection;\r\n```\r\n\r\n当该外部路由资源加载的时候字符串 /admin 将被插入到匹配模式的前面。\r\n\r\n### 可视化并调试路由\r\n　　当你添加和个性化路由时，能够看到它并能获取一些细节信息将是非常有用的。一个好的查看你应用程序的路由的方法是通过router:debug 命令行工具。\r\n在你项目目录下执行如下命令：\r\n```\r\n$ php app/console router:debug\r\n```\r\n\r\n将会输出你应用程序的所有路由。你也可以在该命令后面添加某个路由的名字来获取单个路由信息\r\n```\r\n php app/console router:debug article_show\r\n```\r\n\r\n### 生成URL\r\n\r\n　　一个路由系统应该也能用来生成URL。事实上，路由系统是一个双向的系统，映射URL到controller+parameters 和 回对应到 一个URL。可以使用match()和generate（）方法来操作。比如：\r\n\r\n```\r\n$params = $router->match(\'/blog/my-blog-post\');\r\n// array(\'slug\' => \'my-blog-post\', \'_controller\' => \'AcmeBlogBundle:Blog:show\')\r\n\r\n$uri = $router->generate(\'blog_show\', array(\'slug\' => \'my-blog-post\'));\r\n// /blog/my-blog-post\r\n```\r\n\r\n要生成一个URL，你需要指定路由的名称（比如 blog_show)和任意的通配符（比如：slug=my-blog-post)作为参数。通过这些信息，可以生成任意的URL。\r\n\r\n```\r\nclass MainController extends Controller\r\n{\r\n    public function showAction($slug)\r\n    {\r\n      // ...\r\n\r\n      $url = $this->get(\'router\')->generate(\'blog_show\', array(\'slug\' => \'my-blog-post\'));\r\n    }\r\n}\r\n```\r\n\r\n那么如何从模板内部来生成URL呢？如果你的应用程序前端使用了AJAX请求，你也许想能够基于你的路由配置在javascript中生成URL，通过使用\r\n\r\nFOSJsRoutingBundle(https://github.com/FriendsOfSymfony/FOSJsRoutingBundle) 你可以做到：\r\n\r\n```\r\nvar url = Routing.generate(\'blog_show\', { \"slug\": \'my-blog-post\'});\r\n```\r\n\r\n### 生成绝对路径的URL\r\n　　默认的情况下，路由器生成相对路径的URL（比如 /blog).要生成一个绝对路径的URL，只需要传入一个true到generate方法作为第三个参数值即可。\r\n\r\n```\r\n$router->generate(\'blog_show\', array(\'slug\' => \'my-blog-post\'), true);\r\n// http://www.example.com/blog/my-blog-post\r\n```\r\n\r\n　当生成一个绝对路径URL时主机是当前请求对象的主机，这个是基于PHP提供的服务器信息自动决定的。当你需要为运行子命令行的脚本生成一个绝对URL时，你需要在Request对象上手动设置期望的主机头。\r\n\r\n```\r\n$request->headers->set(\'HOST\', \'www.example.com\');\r\n```\r\n\r\n### 生成带有查询字符串的URL\r\ngenerate()带有一个数组通配符值来生成URI。 但是如果你传入额外的值，它将被添加到URI作为查询字符串：\r\n```\r\n$router->generate(\'blog\', array(\'page\' => 2, \'category\' => \'Symfony\'));\r\n```\r\n\r\n### 从模板中生成URL\r\n　最常用到生成URL的地方是从模板中链接两个页面时，这来需要使用一个模板帮助函数：\r\nTwig格式：\r\n```\r\n<a href=\"{{ path(\'blog_show\', { \'slug\': \'my-blog-post\' }) }}\">\r\n  Read this blog post.\r\n</a>\r\n```\r\n\r\nPHP格式：\r\n```\r\n<a href=\"<?php echo $view[\'router\']->generate(\'blog_show\', array(\'slug\' => \'my-blog-post\')) ?>\">\r\n    Read this blog post.\r\n</a>\r\n```\r\n\r\n也可以生成绝对路径：\r\n\r\nTwig格式：\r\n```\r\n<a href=\"{{ url(\'blog_show\', { \'slug\': \'my-blog-post\' }) }}\">\r\n  Read this blog post.\r\n</a>\r\n\r\n<a href=\"<?php echo $view[\'router\']->generate(\'blog_show\', array(\'slug\' => \'my-blog-post\'), true) ?>\">\r\n    Read this blog post.\r\n</a>\r\n```\r\n\r\n###  强制路由使用HTTPS或者HTTP\r\n\r\n　　有时候为了安全起见，你需要你的站点必须使用HTTPS协议访问。这时候路由组件可以通过_scheme 约束来强迫URI方案。比如：\r\n\r\nYAML格式：\r\n```\r\nsecure:\r\n    pattern:  /secure\r\n    defaults: { _controller: AcmeDemoBundle:Main:secure }\r\n    requirements:\r\n        _scheme:  https\r\n```\r\n\r\n```\r\nuse Symfony\\Component\\Routing\\RouteCollection;\r\nuse Symfony\\Component\\Routing\\Route;\r\n\r\n$collection = new RouteCollection();\r\n$collection->add(\'secure\', new Route(\'/secure\', array(\r\n    \'_controller\' => \'AcmeDemoBundle:Main:secure\',\r\n), array(\r\n    \'_scheme\' => \'https\',\r\n)));\r\n\r\nreturn $collection;\r\n```\r\n\r\n　上面的路由定义就是强迫secure路由使用HTTPS协议访问。\r\n\r\n　　反之，当生成secure 的URL的时候，路由系统会根据当前的访问协议方案生成相应的访问协议。比如当前是HTTP，则会自动生成HTTPS访问；如果是HTTPS访问，那么就也会相应的生成HTTPS访问。\r\n\r\n```\r\n# 如果方案是 HTTPS\r\n{{ path(\'secure\') }}\r\n# 生成 /secure\r\n\r\n# 如果方案是 HTTP\r\n{{ path(\'secure\') }}\r\n# 生成 https://example.com/secure\r\n```\r\n\r\n当然你也可以通过设置_scheme为HTTP，来强制使用HTTP访问协议。除了上面说的强迫使用HTTPS协议访问的设置方法外，还有一种用于站点区域设置\r\n\r\n使用requires_channel 比如你想让你站点中/admin 下面的所有路由都必须使用HTTPS协议访问，或者你的安全路由定义在第三方bundle时使用。\r\n\r\n \r\n\r\n### 总结：\r\n\r\n　　路由系统是一个为将接收的请求URL映射到被调用来处理该请求的controller函数的系统。它既能够让你生成漂亮的URL同时又能保持你的应用程序功能跟这些URL解耦。路由系统是双向机制的，也就是说它们也可以用来生成URL。\r\n\r\n原文链接 http://www.cnblogs.com/Seekr/archive/2012/06/21/2557928.html\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(36,'sql.png','sql-png',1427923699,1427923699,'a:5:{s:4:\"name\";s:7:\"sql.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/4144739655.png\";s:4:\"size\";i:41165;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',37),(37,'Mysql中分页查询两个方法比较','37',1427923740,1427923837,'<!--markdown-->另外提醒下，这里是使用MyISAM会出现三和四的查询差别这么大，但是如果是使用InnoDB的话，就不会有这么大差别了。\r\n\r\n所以我得出的结论是如果数据库是InnoDB的话，我还是倾向于使用SQL_CALC_FOUND_ROWS\r\n\r\n\r\n<!--more-->\r\n\r\n\r\nmysql中分页查询有两种方式, 一种是使用COUNT(*)的方式,具体代码如下\r\n\r\n```\r\nSELECT COUNT(*) FROM foo WHERE b = 1; \r\nSELECT a FROM foo WHERE b = 1 LIMIT 100,10;\r\n```\r\n\r\n另外一种是使用SQL_CALC_FOUND_ROWS\r\n\r\n```\r\nSELECT SQL_CALC_FOUND_ROWS a FROM foo WHERE b = 1 LIMIT 100, 10;\r\nSELECT FOUND_ROWS();\r\n```\r\n第二种方式调用SQL_CALC_FOUND_ROWS之后会将WHERE语句查询的行数放在FOUND_ROWS()之中，第二次只需要查询FOUND_ROWS()就可以查出有多少行了。\r\n\r\n# 讨论这两种方法的优缺点：\r\n\r\n首先原子性讲，第二种肯定比第一种好。第二种能保证查询语句的原子性，第一种当两个请求之间有额外的操作修改了表的时候，结果就自然是不准确的了。而第二种则不会。但是非常可惜，一般页面需要进行分页显示的时候，往往并不要求分页的结果非常准确。即分页返回的total总数大1或者小1都是无所谓的。所以其实原子性不是我们分页关注的重点。\r\n\r\n下面看效率。这个非常重要，分页操作在每个网站上的使用都是非常大的，查询量自然也很大。由于无论哪种，分页操作必然会有两次sql查询，于是就有很多很多关于两种查询性能的比较：\r\n\r\nSQL_CALC_FOUND_ROWS真的很慢么？\r\n\r\n[http://hi.baidu.com/thinkinginlamp/item/b122fdaea5ba23f614329b14][1]\r\n\r\nTo SQL_CALC_FOUND_ROWS or not to SQL_CALC_FOUND_ROWS?\r\n\r\n[http://www.mysqlperformanceblog.com/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/][2]\r\n\r\n老王这篇文章里面有提到一个covering index的概念，简单来说就是怎样才能只让查询根据索引返回结果，而不进行表查询\r\n\r\n具体看他的另外一篇文章：\r\n\r\nMySQL之Covering Index\r\n\r\n[http://hi.baidu.com/thinkinginlamp/item/1b9aaf09014acce0f45ba6d3][3]\r\n\r\n\r\n# 实验\r\n\r\n结合这几篇文章，做的实验：\r\n表\r\n```\r\nCREATE TABLE IF NOT EXISTS `foo` (\r\n`a` int(10) unsigned NOT NULL AUTO_INCREMENT,\r\n`b` int(10) unsigned NOT NULL,\r\n`c` varchar(100) NOT NULL,\r\nPRIMARY KEY (`a`),\r\nKEY `bar` (`b`,`a`)\r\n) ENGINE=MyISAM;\r\n```\r\n\r\n\r\n注意下这里是使用b,a做了一个索引，所以查询select * 的时候是不会用到covering index的，select a才会使用到covering index\r\n```\r\n<?php\r\n \r\n$host = \'192.168.100.166\';\r\n$dbName = \'test\';\r\n$user = \'root\';\r\n$password = \'\';\r\n \r\n$db = mysql_connect($host, $user, $password) or die(\'DB connect failed\');\r\nmysql_select_db($dbName, $db);\r\n \r\n \r\necho \'==========================================\' . \"\\r\\n\";\r\n \r\n$start = microtime(true);\r\nfor ($i =0; $i<1000; $i++) {\r\n    mysql_query(\"SELECT SQL_NO_CACHE COUNT(*) FROM foo WHERE b = 1\");\r\n    mysql_query(\"SELECT SQL_NO_CACHE a FROM foo WHERE b = 1 LIMIT 100,10\");\r\n}\r\n$end = microtime(true);\r\necho $end - $start . \"\\r\\n\";\r\n \r\necho \'==========================================\' . \"\\r\\n\";\r\n \r\n$start = microtime(true);\r\nfor ($i =0; $i<1000; $i++) {\r\n    mysql_query(\"SELECT SQL_NO_CACHE SQL_CALC_FOUND_ROWS a FROM foo WHERE b = 1 LIMIT 100, 10\");\r\n    mysql_query(\"SELECT FOUND_ROWS()\");\r\n}\r\n$end = microtime(true);\r\necho $end - $start . \"\\r\\n\";\r\n \r\necho \'==========================================\' . \"\\r\\n\";\r\n \r\n$start = microtime(true);\r\nfor ($i =0; $i<1000; $i++) {\r\n    mysql_query(\"SELECT SQL_NO_CACHE COUNT(*) FROM foo WHERE b = 1\");\r\n    mysql_query(\"SELECT SQL_NO_CACHE * FROM foo WHERE b = 1 LIMIT 100,10\");\r\n}\r\n$end = microtime(true);\r\necho $end - $start . \"\\r\\n\";\r\n \r\necho \'==========================================\' . \"\\r\\n\";\r\n \r\n$start = microtime(true);\r\nfor ($i =0; $i<1000; $i++) {\r\n    mysql_query(\"SELECT SQL_NO_CACHE SQL_CALC_FOUND_ROWS * FROM foo WHERE b = 1 LIMIT 100, 10\");\r\n    mysql_query(\"SELECT FOUND_ROWS()\");\r\n}\r\n$end = microtime(true);\r\necho $end - $start . \"\\r\\n\";\r\n```\r\n\r\n返回的结果：\r\n![sql.png][4]\r\n\r\n\r\n和老王里面文章说的是一样的。第四次查询SQL_CALC_FOUND_ROWS由于不仅是没有使用到covering index，也需要进行全表查询，而第三次查询COUNT(*)，且select * 有使用到index，并没进行全表查询，所以有这么大的差别。\r\n\r\n# 总结\r\n\r\nPS： 另外提醒下，这里是使用MyISAM会出现三和四的查询差别这么大，但是如果是使用InnoDB的话，就不会有这么大差别了。\r\n\r\n所以我得出的结论是如果数据库是InnoDB的话，我还是倾向于使用SQL_CALC_FOUND_ROWS\r\n\r\n \r\n\r\n结论：SQL_CALC_FOUND_ROWS和COUNT(*)的性能在都使用covering index的情况下前者高，在没使用covering index情况下后者性能高。所以使用的时候要注意这个。\r\n\r\n原文链接  http://www.cnblogs.com/yjf512/archive/2012/10/09/2717102.html\r\n\r\n  [1]: http://hi.baidu.com/thinkinginlamp/item/b122fdaea5ba23f614329b14\r\n  [2]: http://www.mysqlperformanceblog.com/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/\r\n  [3]: http://hi.baidu.com/thinkinginlamp/item/1b9aaf09014acce0f45ba6d3\r\n  [4]: http://blog.chromev.com/usr/uploads/2015/04/4144739655.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(38,'click.jpg','click-jpg',1427959639,1427959639,'a:5:{s:4:\"name\";s:9:\"click.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/2046398787.jpg\";s:4:\"size\";i:10666;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',39),(39,'javascript click写法区别','39',1427959680,1427959838,'<!--markdown-->```\r\n1 <a href=\"javascript:alert(1);\">\r\n2 <a href=\"#\" onclick=\"alert(1)\">\r\n3 <a href=\"#\">\r\n  $(\'a\').click(function() {alert(1);})\r\n```\r\n大家来讨论下区别\r\n\r\n    \r\n1)第一种就是伪协议，和在浏览器地址栏里输入这些字符串是一样的结果。 实质就是浏览器来运行这个js代码， 和触发这个动作的事件、dom本省没有任何联系了\r\n\r\n2)这种写法，其实是把alert(1)这个当成字符串补入已经生成dom对象的click事件体系里\r\n\r\n![click.jpg][1]\r\n\r\n\r\n3)jq的绑定\r\n\r\n转自 **华仔** 大神\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/04/2046398787.jpg',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(40,'doctrine1.png','doctrine1-png',1427966879,1427966879,'a:5:{s:4:\"name\";s:13:\"doctrine1.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/04/822416307.png\";s:4:\"size\";i:91182;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',41),(41,'Symfony2学习笔记之数据库操作','41',1427967060,1427974877,'<!--markdown-->Doctrine是一个ORM（Object-relational mapper），提供php数据库和PHP对象的映射。他和其他的ORM一样都是为了保证持久层和逻辑层的分类而存在的。\r\n\r\n\r\n<!--more-->\r\n\r\n### 什么是Entity\r\n\r\nEntity是PHP的一个对象\r\nEntity对应的表需要有主键\r\nEntity中不能含有final属性或者final方法\r\n\r\n### 教程：\r\n[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/tutorials/getting-started.html][1]\r\n教程代码的github地址在：\r\n[https://github.com/doctrine/doctrine2-orm-tutorial][2]\r\n使用composer安装\r\n![doctrine1.png][3]\r\n\r\n### doctrine是可以根据Entity代码来生成数据表的\r\n路径\r\n```\r\nsymfony2test\\src\\Acme\\StoreBundle\\Entity\r\n```\r\n\r\n配置相关\r\n```\r\n;app/config/parameters.ini\r\n[parameters]\r\n    database_driver   = pdo_mysql\r\n    database_host     = localhost\r\n    database_name     = test_project\r\n    database_user     = root\r\n    database_password = password\r\n\r\n#生成包\r\nphp app/console generate:bundle --namespace=Acme/StoreBundle\r\n\r\n#创建数据库\r\nphp app/console doctrine:database:create\r\n\r\n```\r\n\r\n### 创建实体类\r\n```\r\nuse Doctrine\\ORM\\Mapping as ORM;\r\n\r\n/**\r\n * @ORM\\Entity\r\n * @ORM\\Table(name=\"product\")\r\n */\r\nclass Product\r\n{\r\n    /**\r\n     * @ORM\\Id\r\n     * @ORM\\Column(type=\"integer\")\r\n     * @ORM\\GeneratedValue(strategy=\"AUTO\")\r\n     */\r\n    protected $id;\r\n\r\n    /**\r\n     * @ORM\\Column(type=\"string\", length=100)\r\n     */\r\n    protected $name;\r\n\r\n    /**\r\n     * @ORM\\Column(type=\"decimal\", scale=2)\r\n     */\r\n    protected $price;\r\n\r\n    /**\r\n     * @ORM\\Column(type=\"text\")\r\n     */\r\n    protected $description;\r\n}\r\n```\r\n\r\n注意：你的类名称和属性不能映射到SQL受保护的关键字（比如：group 或者 user）。如果你的实体类名是Group，默认情况下你的表面也将是group，这会引起SQL错误。当使用另外的类库或者程序，它们使用了声明，你应该把@IgnoreAnnotation声明添加到该类上来告诉Symfony忽略它们。比如我们要阻止@fn 声明抛出异常，可以这样：\r\n\r\n```\r\n/**\r\n* @IgnoreAnnotation(\"fn\")\r\n*/\r\nclass Product\r\n```\r\n\r\n### 生成Getters和Setters\r\n\r\n```\r\n#方式一\r\nphp app/console doctrine:generate:entites Acme/StoreBundle/Entity/Product\r\n#方式二\r\napp/console generate:doctrine:entities AcmeStoreBundle\r\n#方式三\r\napp/console doctrine:generate:entities Acme\r\n```\r\n\r\n### 创建数据库表和模式\r\n```\r\napp/console doctrine:schema:update --dump-sql --force\r\n```\r\n说真的，这条命令是出奇的强大。它会基于你的entities的映射信息，来比较现在的数据库，并生成所需要等新数据库的更新SQl语句。换句话说，如果你想添加一个新的属性映射元数据到Product并运行该任务，它将生成一个alert table 语句来添加新的列到已经存在的product表中。\r\n\r\n　　一个更好的发挥这一优势的功能是通过migrations，它允许你生成这些SQL语句并存储到一个合并类，并能有组织的运行在你的生产环境中有效的跟踪和并安全的合并你的数据库。\r\n\r\n　　现在你的数据库中有了一个全功能的product表，它的每个列都会被映射到你指定的元数据。\r\n\r\n\r\n### 持久化对象到数据库\r\n现在我们有了一个Product实体和与之映射的product数据库表。你可以把数据持久化到数据库里。在Controller内，它非常简单。添加下面的方法到bundle的DefaultController中。\r\n\r\n```\r\n// src/Acme/StoreBundle/Controller/DefaultController.php\r\nuse Acme\\StoreBundle\\Entity\\Product;\r\nuse Symfony\\Component\\HttpFoundation\\Response;\r\n// ...\r\n\r\npublic function createAction()\r\n{\r\n    $product = new Product();\r\n    $product->setName(\'A Foo Bar\');\r\n    $product->setPrice(\'19.99\');\r\n    $product->setDescription(\'Lorem ipsum dolor\');\r\n\r\n    $em = $this->getDoctrine()->getEntityManager();\r\n    $em->persist($product);\r\n    $em->flush();\r\n\r\n    return new Response(\'Created product id \'.$product->getId());\r\n}\r\n```\r\n\r\n### 从数据库中读取对象\r\n```\r\npublic function showAction($id)\r\n{\r\n       $product = $this->getDoctrine()\r\n                 ->getRepository(\'AcmeStoreBundle:Product\'))\r\n                 ->find($id);\r\n        if(!$product){\r\n             throw $this->createNotFoundException(\'No product found for id \' .$id);\r\n        }\r\n       //do something,想把$product对象传递给一个template等。\r\n}\r\n```\r\n你一旦有了Repository,你就可以访问其所有分类的帮助方法了。\r\n```\r\n//通过主键查询（一般为\"id\")\r\n$product=$repository->find($id);\r\n\r\n//动态方法名基于列值查找\r\n$product=$repository->findOneById($id);\r\n$product=$repository->findOneByName(\'foo\');\r\n\r\n//查询所有产品\r\n$products=$repository->findAall();\r\n//基于任意列值查找一组产品\r\n$products = $repository->findByPrice(19.99);\r\n\r\n//按照名字和价格来获取一个匹配的对象\r\n$product=$repository->findOneBy(array(\'name\'=>\'foo\',\'price\'=>19.99));\r\n\r\n//查询匹配名字的所有产品并按照价格排序\r\n$products = $repository->findBy(\r\n        array(\'name\'=> \'foo\'),\r\n        array(\'price\'=>\'ASC\')\r\n);\r\n```\r\n\r\n### 更新对象\r\n```\r\npublic function updateAction($id)\r\n{\r\n    $em = $this->getDoctrine()->getEntityManager();\r\n    $product = $em->getRepository(\'AcmeStoreBundle:Product\')->find($id);\r\n\r\n    if (!$product) {\r\n        throw $this->createNotFoundException(\'No product found for id \'.$id);\r\n    }\r\n\r\n    $product->setName(\'New product name!\');\r\n    $em->flush();\r\n\r\n    return $this->redirect($this->generateUrl(\'homepage\'));\r\n}\r\n```\r\n\r\n更新一个对象包括三步：\r\n\r\n       1.从Doctrine取出对象\r\n       2.修改对象\r\n       3.在实体管理者上调用flush()方法\r\n\r\n　　注意调用 $em->persist($product) 在这里没有必要。我们回想一下，调用该方法的目的主要是告诉Doctrine来管理或者“watch\"$product对象。\r\n在这里，因为你已经取到了$product对象了，说明已经被管理了。\r\n\r\n\r\n### 删除对象：\r\n```\r\n$em->remove($product);\r\n$em->flush();\r\n```\r\n\r\n### 查询对象：\r\n```\r\n$repository->find($id);\r\n$repository->findOneByName(\'Foo\');\r\n```\r\n\r\n### 生命周期回调：\r\n\r\n　　有时候你可能需要在一个实体被创建，更新或者删除的前后执行一些行为。因为它们回调的方法处在一个实体不同的生命周期阶段，所以这些行为被称为\"生命周期回调“。如果你用声明元数据方式，开启一个生命周期回调，需要如下设置：\r\n\r\n```\r\n/**\r\n * @ORM\\Entity()\r\n * @ORM\\HasLifecycleCallbacks()\r\n */\r\nclass Product\r\n{\r\n    // ...\r\n}\r\n/**\r\n* @ORM\\PrePersist\r\n*/\r\npublic function setCreatedValue()\r\n{\r\n       $this->created = new \\DateTime();\r\n}\r\n```\r\n　现在在实体第一次被保存时，Doctrine会自动调用这个方法使created日期自动设置为当前日期。还有其它生命周期事件可用：\r\n\r\npreRemove\r\npostRemove\r\nprePersist\r\npostPersist\r\npreUpdate\r\npostUpdate\r\npostLoad\r\nloadClassMetadata\r\n\r\n生命周期回调和事件监听：\r\n　　注意到setCreatedValue()方法不需要接收任何参数。这是生命周期回调通常的做法和惯例。生命周期回调应该方法简单，更关注于实体内部传输数据。比如设置一个创建/更新字段，生成一个定量值等。如果你需要一些比较大的行为活动，像执行日志或者发送邮件，你应该注册一个扩展类作为事件监听器或接收器给它赋予访问所需资源的权利。\r\n\r\n \r\n\r\nDoctrine扩展：Timestampable， Sluggable\r\n　　Doctrine非常灵活，许多第三方扩展可以使用，让你很容易在你的实体上执行一些重复和通用的任务。包括Sluggable,Timestampable,Loggable,Translatable 和 Tree。\r\n\r\n\r\nDoctrine字段类型参考：\r\n　　Doctrine配备了大量可用的字段类型。它们每一个都能映射PHP数据类型到特定的列类型，无论你使用什么数据库。下面是Doctrine支持的数据类型：\r\n\r\n字符串：\r\n         string 短字符串\r\n         text 大型字符串\r\n数字：\r\n         integer\r\n         smallint\r\n         bigint\r\n         decimal\r\n         float\r\n日期和时间：\r\n         date\r\n         time\r\n         datetime\r\n其它类型：\r\n         boolean\r\n         object(序列化并存储到CLOB字段）\r\n         array(序列化并存储到CLOB字段）\r\n\r\n\r\n可选字段：\r\n　　每个字段都有一些可选项。包括type(默认string),name,length,unique 和nullable。\r\n比如：\r\n```\r\n/**\r\n *字符串字段长度为255 不能为空\r\n * (影响默认值的 \"type\", \"length\" 和 *nullable* 可选)\r\n *\r\n * @ORM\\Column()\r\n */\r\nprotected $name;\r\n\r\n/**\r\n * 字符串字段长度 150保存到 \"email_address\" 列\r\n * 并且有一个唯一索引.\r\n *\r\n * @ORM\\Column(name=\"email_address\", unique=true, length=150)\r\n */\r\nprotected $email;\r\n```\r\n\r\n一个可用的命令行列表将会被打印出来。有许多是以doctrine:开头的。你可通过运行help命令来查看它们的详细，比如,查看doctrine:database:create 任务，则需要运行：\r\n```\r\nphp app/console help doctrine:database:create\r\n```\r\n\r\ndoctrine:ensure-production-settings 用来查看当前还将配置是否对产品有效。这个一般在prod环境下运行：\r\n```\r\nphp app/console doctrine:ensure-production-settings --env=prod\r\n```\r\n\r\ndoctrine:mapping:import 允许Doctrine自己检查一个已有的数据库并创建映射信息。\r\ndoctrine:query:dql 和 doctrine:query:sql 允许你直接在命令行执行DQL或者SQL查询。\r\n\r\n\r\n# 高级用法\r\n\r\n### 使用EntityManager能对Entity进行增删改查的操作\r\n\r\n```\r\n增加：\r\n$product = new Product();\r\n$product->setName($newProductName);\r\n \r\n$entityManager->persist($product);\r\n$entityManager->flush();\r\n \r\n查询：\r\n$entityManager->find(\'Product\', $id)\r\n \r\n更新：\r\n$product = $entityManager->find(\'Product\', $id);\r\n$product->setName($newName);\r\n$entityManager->flush();\r\n \r\n删除：\r\n$product = $entityManager->find(\'Product\', $id);\r\n$product->remove();\r\n$entityManager->flush();\r\n```\r\n\r\n\r\n### 如何调试\r\n```\r\ndoctrine由于EntityManager结构复杂，所以使用var_dump()返回的数据及其庞大，并且可读性差。应该使用\r\n\r\nDoctrine\\Common\\Util\\Debug::dump()来打印信息。\r\n```\r\n\r\n\r\n## 表之间的关联如何体现在Entity上\r\n首先明确表和表的关联有几种：\r\n\r\n**一对一**\r\n\r\n**一对多**\r\n\r\n**多对一**\r\n\r\n**多对多**\r\n\r\n比如教程中举的例子，bug系统\r\n\r\nbug表和user表分别存储bug信息和user信息\r\n\r\n每个bug有个工程师engineer的属性，代表这个bug是由哪个工程师开发的，那么就有可能有多个bug是由一个工程师开发的。所以bug表对于user表就是多对一的关系。user表对于bug表就是一对多的关系。\r\n\r\nbug表和product表分别存储bug信息和出bug的产品信息\r\n\r\n一个bug可能有多个产品一起出现问题导致的，而一个产品也有可能有多个bug，所以bug表和product表就是多对多的关系。\r\n\r\n一对一的关系就比较简单了。\r\n\r\n### 一对多如何设置\r\n\r\n```\r\n#bug.php\r\n    /**\r\n     * @ManyToOne(targetEntity=\"User\", inversedBy=\"assignedBugs\")\r\n     **/\r\n    protected $engineer;\r\n \r\n#user.php\r\n    /**\r\n     * @OneToMany(targetEntity=\"Bug\", mappedBy=\"engineer\")\r\n     * @var Bug[]\r\n     **/\r\n    protected $assignedBugs = null;\r\n```\r\n\r\n这里ManyToOne和OneToMany是互相对应的，inversedBy和mappedBy也是互相对应的\r\n\r\n这样如果使用doctrine自动生成表结构：\r\n```\r\nmysql> show create table users;\r\n \r\n| users | CREATE TABLE `users` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci |\r\n \r\n \r\nmysql> show create table bugs;\r\n \r\n| bugs  | CREATE TABLE `bugs` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `engineer_id` int(11) DEFAULT NULL,\r\n  `reporter_id` int(11) DEFAULT NULL,\r\n  `description` varchar(255) COLLATE utf8_unicode_ci NOT NULL,\r\n  `created` datetime NOT NULL,\r\n  `status` varchar(255) COLLATE utf8_unicode_ci NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `IDX_1E197C9F8D8CDF1` (`engineer_id`),\r\n  KEY `IDX_1E197C9E1CFE6F5` (`reporter_id`),\r\n  CONSTRAINT `FK_1E197C9E1CFE6F5` FOREIGN KEY (`reporter_id`) REFERENCES `users` (`id`),\r\n  CONSTRAINT `FK_1E197C9F8D8CDF1` FOREIGN KEY (`engineer_id`) REFERENCES `users` (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci |\r\n```\r\n\r\n可以看出的是bugs生成了engineer_id属性，然后自动生成外键的索引。\r\n\r\n更多的entity和mysql的对应关系是：\r\n\r\n[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html][4]\r\n\r\n\r\n### 如何使用DQL进行查询\r\n对，你没有看错，这里是DQL而不是SQL。DQL是毛语言呢？Document Query Language，意思就是文档化的sql语句，为什么sql语句需要文档化呢？sql语句更倾向于表结构实现，所以在写sql语句的时候头脑中需要具现化的是表结构，而ORM的目的就是不需要开发者关注表结构，所以需要一个不基于表结构的查询语句，又能直接翻译成为SQL语句，这就是DQL。DQL可以直接对Entity进行增删改查，而不需要直接对表进行操作。\r\n\r\n比如下面的一个例子：\r\n```\r\n$dql = \"SELECT b, e, r FROM Bug b JOIN b.engineer e JOIN b.reporter r ORDER BY b.created DESC\";\r\n\r\n$query = $entityManager->createQuery($dql);\r\n$query->setMaxResults(30); \r\n$bugs=$query->getResult();\r\n```\r\n看这里的sql中From的就是“Bug”，这个是Entity的类，其实熟悉了sql，dql的查询语法也是一模一样的。\r\n\r\n考虑使用dql而不是sql除了和ORM目标一致外，还有一个好处，就是存储层和逻辑层的耦合分开了。比如我的存储层要从mysql换成mongodb，那么逻辑层是什么都不需要动的。\r\n\r\n### 使用Repository\r\n到这里就嘀咕，我经常进行的查询是根据字段查询列表啥的，难道每次需要我都拼接dql么？当然不用，doctrine为我们准备了repository的概念，就是查询库，里面封装了各种查询常用的方法。\r\n\r\n使用如下：\r\n```\r\n$product = $entityManager->getRepository(\'Product\')\r\n                         ->findOneBy(array(\'name\' => $productName));\r\n```\r\n\r\nRepository对应的操作有：\r\n```\r\nfind()\r\nfindAll()\r\nfindBy()\r\nfindOneBy()\r\nfindOneByXXX()\r\n```\r\n\r\n示例：\r\n```\r\n<?php// $em instanceof EntityManager\r\n$user = $em->getRepository(\'MyProject\\Domain\\User\')->find($id);\r\n \r\n<?php// $em instanceof EntityManager\r\n \r\n// All users that are 20 years old\r\n$users = $em->getRepository(\'MyProject\\Domain\\User\')->findBy(array(\'age\' => 20));\r\n \r\n// All users that are 20 years old and have a surname of \'Miller\'\r\n$users = $em->getRepository(\'MyProject\\Domain\\User\')->findBy(array(\'age\' => 20, \'surname\' => \'Miller\'));\r\n \r\n// A single user by its nickname\r\n$user = $em->getRepository(\'MyProject\\Domain\\User\')->findOneBy(array(\'nickname\' => \'romanb\'));\r\n \r\n \r\n<?php// A single user by its nickname\r\n$user = $em->getRepository(\'MyProject\\Domain\\User\')->findOneBy(array(\'nickname\' => \'romanb\'));\r\n \r\n// A single user by its nickname (__call magic)\r\n$user = $em->getRepository(\'MyProject\\Domain\\User\')->findOneByNickname(\'romanb\');\r\n```\r\n\r\ndoctrine还允许自己创建Repository，然后只需要在Entity中说明下repositoryClass就可以了。\r\n\r\n```\r\nclass UserRepository extends EntityRepository\r\n{\r\n    public function getAllAdminUsers()\r\n    {\r\n        return $this->_em->createQuery(\'SELECT u FROM MyDomain\\Model\\User u WHERE u.status = \"admin\"\')\r\n                         ->getResult();\r\n    }}\r\n```\r\n\r\n### 如何使用原生的sql语句来做查询？\r\n除了dql之外，doctrine也允许使用原生的sql语句来做查询。这篇教程有最详细的说明http://docs.doctrine-project.org/en/latest/reference/native-sql.html。\r\n主要是提供了createNativeQuery的方法\r\n```\r\n<?php\r\n// Equivalent DQL query: \"select u from User u where u.name=?1\"\r\n// User owns an association to an Address but the Address is not loaded in the query.\r\n$rsm = new ResultSetMapping;\r\n$rsm->addEntityResult(\'User\', \'u\');\r\n$rsm->addFieldResult(\'u\', \'id\', \'id\');\r\n$rsm->addFieldResult(\'u\', \'name\', \'name\');\r\n$rsm->addMetaResult(\'u\', \'address_id\', \'address_id\');\r\n \r\n$query = $this->_em->createNativeQuery(\'SELECT id, name, address_id FROM users WHERE name = ?\', $rsm);\r\n$query->setParameter(1, \'romanb\');\r\n \r\n$users = $query->getResult();\r\n```\r\n\r\n这里唯一让人不解的就是ResultSetMapping了，ResultSetMapping也是理解原生sql查询的关键。\r\n其实也没什么不解的了，ORM是不允许数据库操作返回的不是Object的，所以ResultSetMapping就是数据库数据和Object的结构映射。\r\n这个Mapping也可以在Entity中进行设置。\r\n\r\n### 如何使用QueryBuilder\r\n\r\nQueryBuilder是doctrine提供的一种在DQL之上的一层查询操作，它封装了一些api，提供给用户进行组装DQL的。\r\nQueryBuilder的好处就是看起来不用自己字符串拼装查询语句了。\r\n关于QueryBuilder的详细说明可以看这篇文章：[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html][5]\r\n\r\n```\r\n<?php\r\n// $qb instanceof QueryBuilder\r\n$qb = $em->createQueryBuilder();\r\n \r\n$qb->select(\'u\')\r\n   ->from(\'User\', \'u\')\r\n   ->where(\'u.id = ?1\')\r\n   ->orderBy(\'u.name\', \'ASC\');\r\n```\r\n\r\nQueryBuilder的接口有：\r\n```\r\n<?phpclass QueryBuilder{\r\n    // Example - $qb->select(\'u\')\r\n    // Example - $qb->select(array(\'u\', \'p\'))\r\n    // Example - $qb->select($qb->expr()->select(\'u\', \'p\'))\r\n    public function select($select = null);\r\n \r\n    // Example - $qb->delete(\'User\', \'u\')\r\n    public function delete($delete = null, $alias = null);\r\n \r\n    // Example - $qb->update(\'Group\', \'g\')\r\n    public function update($update = null, $alias = null);\r\n \r\n    // Example - $qb->set(\'u.firstName\', $qb->expr()->literal(\'Arnold\'))\r\n    // Example - $qb->set(\'u.numChilds\', \'u.numChilds + ?1\')\r\n    // Example - $qb->set(\'u.numChilds\', $qb->expr()->sum(\'u.numChilds\', \'?1\'))\r\n    public function set($key, $value);\r\n \r\n    // Example - $qb->from(\'Phonenumber\', \'p\')\r\n    public function from($from, $alias = null);\r\n \r\n    // Example - $qb->innerJoin(\'u.Group\', \'g\', Expr\\Join::WITH, $qb->expr()->eq(\'u.status_id\', \'?1\'))\r\n    // Example - $qb->innerJoin(\'u.Group\', \'g\', \'WITH\', \'u.status = ?1\')\r\n    public function innerJoin($join, $alias = null, $conditionType = null, $condition = null);\r\n \r\n    // Example - $qb->leftJoin(\'u.Phonenumbers\', \'p\', Expr\\Join::WITH, $qb->expr()->eq(\'p.area_code\', 55))\r\n    // Example - $qb->leftJoin(\'u.Phonenumbers\', \'p\', \'WITH\', \'p.area_code = 55\')\r\n    public function leftJoin($join, $alias = null, $conditionType = null, $condition = null);\r\n \r\n    // NOTE: ->where() overrides all previously set conditions\r\n    //\r\n    // Example - $qb->where(\'u.firstName = ?1\', $qb->expr()->eq(\'u.surname\', \'?2\'))\r\n    // Example - $qb->where($qb->expr()->andX($qb->expr()->eq(\'u.firstName\', \'?1\'), $qb->expr()->eq(\'u.surname\', \'?2\')))\r\n    // Example - $qb->where(\'u.firstName = ?1 AND u.surname = ?2\')\r\n    public function where($where);\r\n \r\n    // Example - $qb->andWhere($qb->expr()->orX($qb->expr()->lte(\'u.age\', 40), \'u.numChild = 0\'))\r\n    public function andWhere($where);\r\n \r\n    // Example - $qb->orWhere($qb->expr()->between(\'u.id\', 1, 10));\r\n    public function orWhere($where);\r\n \r\n    // NOTE: -> groupBy() overrides all previously set grouping conditions\r\n    //\r\n    // Example - $qb->groupBy(\'u.id\')\r\n    public function groupBy($groupBy);\r\n \r\n    // Example - $qb->addGroupBy(\'g.name\')\r\n    public function addGroupBy($groupBy);\r\n \r\n    // NOTE: -> having() overrides all previously set having conditions\r\n    //\r\n    // Example - $qb->having(\'u.salary >= ?1\')\r\n    // Example - $qb->having($qb->expr()->gte(\'u.salary\', \'?1\'))\r\n    public function having($having);\r\n \r\n    // Example - $qb->andHaving($qb->expr()->gt($qb->expr()->count(\'u.numChild\'), 0))\r\n    public function andHaving($having);\r\n \r\n    // Example - $qb->orHaving($qb->expr()->lte(\'g.managerLevel\', \'100\'))\r\n    public function orHaving($having);\r\n \r\n    // NOTE: -> orderBy() overrides all previously set ordering conditions\r\n    //\r\n    // Example - $qb->orderBy(\'u.surname\', \'DESC\')\r\n    public function orderBy($sort, $order = null);\r\n \r\n    // Example - $qb->addOrderBy(\'u.firstName\')\r\n    public function addOrderBy($sort, $order = null); // Default $order = \'ASC\'}\r\n```\r\n更多更复杂的查询可以查看上文的链接。\r\n\r\n### 查询结果是只能返回对象吗？\r\n\r\n当然不只，当你执行query的时候可以试试使用：\r\n```\r\n$result = $query->getResult();\r\n$single = $query->getSingleResult();\r\n$array = $query->getArrayResult();\r\n$scalar = $query->getScalarResult();\r\n$singleScalar = $query->getSingleScalarResult();\r\n```\r\n\r\ndoctrine查询操作总结\r\n现在总结下，doctrine2 做查询操作有下面几种方法\r\n\r\n**1 使用EntityManager直接进行find查询**\r\n**2 使用DQL进行createQuery($dql)进行查询**\r\n**3 使用QueryBuilder进行拼装dql查询**\r\n**4 使用Repository进行查询**\r\n**5 使用原生的sql进行createNativeQuery($sql)进行查询**\r\n\r\ndoctrine2的增加，删除，更新操作都需要使用Entity进行操作\r\n\r\n### 一个项目有几个实现路径：\r\n**1 Code First：先用代码写好Object(Entity)，然后根据Object生成数据库**\r\n2 Model First：先用工具写好UML，然后根据UML生成数据库和PHP代码\r\n3 Database First：先写好数据库的schema表，然后生成PHP代码\r\n\r\n\r\n### 如何做分页操作\r\n分页操作是经常使用到的，doctrine使用了Paginator类来做这个操作\r\n\r\n比如：\r\n```\r\n<?php\r\n// list_bugs_array.php\r\nuse Doctrine\\ORM\\Tools\\Pagination\\Paginator;\r\nrequire_once \"bootstrap.php\";\r\n \r\n$dql = \"SELECT b, e, r, p FROM Bug b JOIN b.engineer e \".\r\n       \"JOIN b.reporter r JOIN b.products p ORDER BY b.created DESC\";\r\n$query = $entityManager->createQuery($dql)\r\n               ->setFirstResult(0)\r\n               ->setMaxResults(1);\r\n \r\n$paginator = new Paginator($query, $fetchJoinCollection = true);\r\n \r\n$c = count($paginator);\r\necho \"count: $c\" . \"\\r\\n\";\r\n \r\n$bugs = $query->getArrayResult();\r\n \r\nforeach ($bugs as $item) {\r\n     print_r($item);\r\n}\r\nexit;\r\n```\r\n\r\n### 如何进行sql和dql的调试\r\n\r\n```\r\n$query->getDQL()\r\n$query->getSQL()\r\n```\r\n\r\n### 为什么在增删更新的时候有个flush操作\r\n\r\ndoctrine在增加，删除，更新的时候并不是直接进行操作，而是将操作存放在每个EntityManager的UnitOfWork。\r\n\r\n你可以使用\r\n```\r\n$entityManager->getUnitOfWork()\r\n$entityManager->getUnitOfWork()->size()\r\n$entityManager->getEntityState($entity)\r\n来控制UnitOfWork\r\n```\r\n\r\n### 如何注入Entity增加，删除，更新操作\r\n\r\ndoctrine提供了监听Event的功能，比如你要在Persist之前做一个日志处理，你就可以实现一个Listener，其中实现了prePersist方法 \r\n然后把Listener挂载到Entity上\r\n\r\n```\r\n<?php\r\nnamespace MyProject\\Entity;\r\n \r\n/** @Entity @EntityListeners({\"UserListener\"}) */\r\nclass User\r\n{\r\n    // ....\r\n}\r\n```\r\n\r\n### 如何实现事务？\r\n```\r\n<?php\r\n// $em instanceof EntityManager\r\n$em->getConnection()->beginTransaction(); // suspend auto-commit\r\ntry {\r\n    //... do some work\r\n    $user = new User;\r\n    $user->setName(\'George\');\r\n    $em->persist($user);\r\n    $em->flush();\r\n    $em->getConnection()->commit();\r\n} catch (Exception $e) {\r\n    $em->getConnection()->rollback();\r\n    $em->close();\r\n    throw $e;\r\n}\r\n```\r\n\r\n### 使用DQL只能进行查询操作吗？\r\n当然不只，我们可以使用execute()来对增删改查的DQL语句进行操作\r\n```\r\n<?php\r\n$q = $em->createQuery(\'delete from MyProject\\Model\\Manager m where m.salary > 100000\');\r\n$numDeleted = $q->execute();\r\n```\r\n\r\n### Entity可以设置哪些属性：\r\n\r\n参考文章：\r\n[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html][6]\r\n\r\n### 有哪些Cache机制\r\ndoctrine可以支持APC，Memcache，Xcache，Redis这几种缓存机制\r\n所有这些缓存机制都是基于一个抽象方法，这个抽象方法中有的接口有：\r\n```\r\nfetch($id)\r\ncontains($id)\r\nsave($id, $data, $lifeTime=false)\r\ndelete($id)\r\n```\r\n\r\n各自对应的初始化代码：\r\n```\r\nAPC：\r\n<?php\r\n$cacheDriver = new \\Doctrine\\Common\\Cache\\ApcCache();\r\n$cacheDriver->save(\'cache_id\', \'my_data\');\r\n \r\nMemCache：\r\n<?php\r\n$memcache = new Memcache();\r\n$memcache->connect(\'memcache_host\', 11211);\r\n \r\n$cacheDriver = new \\Doctrine\\Common\\Cache\\MemcacheCache();\r\n$cacheDriver->setMemcache($memcache);\r\n$cacheDriver->save(\'cache_id\', \'my_data\');\r\n \r\nXcache：\r\n<?php\r\n$cacheDriver = new \\Doctrine\\Common\\Cache\\XcacheCache();\r\n$cacheDriver->save(\'cache_id\', \'my_data\');\r\n \r\nRedis：\r\n<?php\r\n$redis = new Redis();\r\n$redis->connect(\'redis_host\', 6379);\r\n \r\n$cacheDriver = new \\Doctrine\\Common\\Cache\\RedisCache();\r\n$cacheDriver->setRedis($redis);\r\n$cacheDriver->save(\'cache_id\', \'my_data\');\r\n```\r\n\r\n还有一个命令clear-cache可以用来进行缓存的增删改查\r\n具体参考文章：[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/caching.html][7]\r\n\r\n\r\ndoctrine提供的工具有哪些\r\n参考文章：http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/tools.html\r\n\r\n![doctrinecmd.png][8]\r\n\r\n看看这些命令，大致可以完成的功能是：\r\n\r\n数据库schema生成php的Entity代码\r\n\r\nphp的Entity代码生成数据库schema\r\n\r\n缓存相关操作\r\n\r\n数据库schema相关操作\r\n\r\n\r\n# 总结\r\ndoctrine就是一个很庞大的ORM系统，它可以嵌入到其他框架中，比如symfony，比如Yii等。\r\nORM的最终目的就是将逻辑层和持久层分离，在这个层面来说，doctrine很好地完成了这个任务。\r\ndoctrine已经将你能考虑到的操作都进行封装好了，相信如果熟悉了之后，开发过程应该是会非常快的\r\n\r\n有了Doctrine，你可以集中精力到你的对象以及怎样把它应用于你的应用程序中，而不必担心数据库持久化。因为Doctrine允许你使用任何的PHP对象保存你的数据并依靠映射元数据信息来联系一个对象到特定的数据库表。\r\n\r\n　　尽管Doctrine围绕着一个简单的概念发展而来，但是它不可思议的强大。允许你创建复杂的查询和订阅事件，通过订阅事件你可以在整个持久化过程中执行一些不同的行为。\r\n\r\n参考文章\r\nhttp://www.cnblogs.com/Seekr/archive/2012/06/25/2560631.html\r\nhttp://www.cnblogs.com/yjf512/p/3375614.html\r\n\r\n\r\n  [1]: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/tutorials/getting-started.html\r\n  [2]: https://github.com/doctrine/doctrine2-orm-tutorial\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/04/822416307.png\r\n  [4]: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html\r\n  [5]: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html\r\n  [6]: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html\r\n  [7]: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/caching.html\r\n  [8]: http://blog.chromev.com/usr/uploads/2015/04/3055224622.png',0,1,NULL,'post','publish',NULL,1,'1','1','1',0),(42,'doctrinecmd.png','doctrinecmd-png',1427968579,1427968579,'a:5:{s:4:\"name\";s:15:\"doctrinecmd.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/3055224622.png\";s:4:\"size\";i:69918;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',41),(44,'pro.jpg','pro-jpg',1428748596,1428748596,'a:5:{s:4:\"name\";s:7:\"pro.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/3635797580.jpg\";s:4:\"size\";i:84466;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',45),(45,'优秀程序员思考、学习新技术的原则和方式','45',1428748680,1428748899,'<!--markdown-->最近了解了几个 MVC 的框架，其中有两个是公司内部的。发现这些东西都是类似的，从处理逻辑到页面渲染；从 service 到 layout；配置的实现无非就是 XML，或者 annotation……我有种感觉，兴许已经跳不出这个思维圈子了？\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n优秀的程序员如何思考、学习新技术的原则和方式\r\n![pro.jpg][1]\r\n　　如今的时代，是一个概念翻飞的时代，oschina 里的开源软件数量就已经超过了两万，五花八门的技术层出不穷，到底什么技术才是值得学习的？\r\n\r\n　　有位朋友说，他想学习一些关于 Android 上的开发技术，兴趣驱使。几个月过去了，他说他已经能做出许多小程序了，可是他现在回想起来，掌握一门技术是好，可兴趣之外还有什么呢？他说，“如果我的工作中不使用 Android 平台，我学它还有何用？”。\r\n\r\n　　学习技术到底是一件有意思的事，还是一件痛苦的事？读书的时候，我曾经买过侯捷翻译的《深入浅出 MFC》，对那时的我来说，似乎太困难了一点，我强迫自己看完了三分之一，实在是没有毅力继续往下读了。我在其中察觉不到快乐，这本书在当时似乎充满了生涩。\r\n\r\n　　如上这样的故事太多了，很多时候，程序员们（包括我在内）辛苦地学习，有的没有好的效果，有的过程充满痛苦，有的更是不知道我学它的目的是什么。\r\n\r\n ### 国内的教育体制，培养了这样一批人：\r\n\r\n　　他们努力、奋进，热爱技术，愿意投身软件行业，愿意写出高质量的代码，他们对业界的东西很感兴趣，他们愿意学习扎实的基础知识，他们渴求火热的新技术……\r\n\r\n　　几年以后，他们拥有广泛的视野，阅历宽阔、经验老到、言辞犀利，对行业动态了如指掌，显然，他们是行业的博学者。\r\n\r\n### 然而……\r\n\r\n　　他们却缺乏这样一种能力——思考。\r\n\r\n### 欠缺思考容易导致这样的现象：\r\n\r\n### 不会做设计\r\n\r\n　　遇到了问题，拿见到过的、学到了的熟悉的框架、方案、模式往上套，而不仔细分析其中的利弊，只是尽可能地寻找最接近当前问题的解决途径。\r\n\r\n　　有的是不会做系统设计。和少数所谓的“架构师”接触过，他们“只懂业务，不懂技术”，这样设计出来的系统只能满足功能性需求；而论坛上的一些具体问题的讨论话题，则暴露出一些跟帖讨论者“只谈技术，不提业务”，譬如“XXX 大容量的解决方案”、“秒杀系统的终极架构”，企图对某一类宽泛的问题，设计出一套放之四海皆准的通用解决方案。\r\n\r\n　　还有的则是不会做面向对象设计，缺少抽象和解耦的能力，这样的例子就更多了。朋友告诉我，他的单位有一位写 Ruby 的老员工，一个庞大的工程，代码里面居然只有一个上帝类，就搞定了所有的问题。\r\n\r\n### 不能坚持自己的观点\r\n\r\n　　这一点在面试中最容易观察到。应聘者有刚毕业的学生，也有工作超过 10 年的有丰富经验的从业者。他给出一个粗略的方案以后，在方案没有细化到一定程度以前，很难给出优劣的评论，但是，如果你轻轻地 challenge 一下，他就迅速放弃本来的构思，跑到你的思路上来。\r\n\r\n　　例如，SNS 系统中，服务端有消息要怎样通知到客户端，这样的一个问题，解决方案有很多种，比如客户端轮询、服务端 hold 住连接推送等，各有利弊。应聘者应当有自己的观点。\r\n\r\n### 不能细化一个问题解决方案\r\n\r\n　　怎样区分一个空谈家和一个实干家？给他一个具体的问题是最好的办法。在我刚工作的时候，我曾经很钦佩那些在活动中、讨论中高谈阔论的人，我觉得他们很能说。可是后来我逐渐发现，能说的人实在是太多太多了。细化设计、甚至落到编码，才是对一个程序员真实的检验。当然，如果你觉得做软件设计的人可以不熟悉编码、架构师可以不首先是一名高级程序员，那我们也没有什么可谈了:)。\r\n\r\n　　如果你会学习，你可以成长得很快；如果你不会思考，你永远只能跟在别人后面。\r\n\r\n　　在新技术的学习上我认为也应当多思考，不同的人有不同的学习动机。在非外界所迫的情况下，对于新技术的学习，我的观点可以概括为：\r\n\r\n### 它要解决什么问题，就是所谓的问题域，是我关心的吗？\r\n\r\n　　我没有去研究操作系统底层的实现，并非这没有价值，而是我没有兴趣，这就是问题域的影响（不过现在我有兴趣了，我想做一些这方面的事情）。\r\n\r\n### 和过往解决方案它的优势在哪里，是否显著？\r\n\r\n　　这是 competition，重复的技术是没有生存空间的（当然，你是微软的话除外:)），就像互联网同一个类型的网站，竞争到最后就那么两三家。就像 Groovy，我很喜欢它，但是有了 Scala 以后，我觉得兴许有一个要死掉（Groovy 创始人说，如果他早些知道 Scala 的话，就没有 Groovy 什么事了。具体的报道请去 Google 上搜他的 blog）。\r\n\r\n### 它的实现和带来的效果上看，有没有很有意思的思路，是值得借鉴和思考的？\r\n\r\n　　这是最难讲的一个问题。以去年初开始接触的 Node.js 为例，它可以做到把后端的聚合（譬如 portlet 之流）放到前端来，后端只保留一种类型的页面服务——页面模板，以及若干易于管理的 API 接口，大大简化了后端体系的复杂度，而且还能把压力分散到前端来，这是我早些年不曾见到的。\r\n\r\n　　这三个问题想过之后，觉得有价值，我才去学习。要不然，对我而言就是不想深入的东西，了解了解也就罢了。\r\n\r\n### 新技术学习的方式呢，我想说这么几点：\r\n\r\n### 寻找切入点\r\n\r\n　　我很喜欢 BlueDavy 的 blog 上的一句话：“理论不懂就实践，实践不会就学理论！”。\r\n\r\n　　最后最好是要落到动手实践上去的，但是倘若习惯从那些原理介绍的文字入手，未尝不是一种不好的选择。而且，现实情况会有一些约束，例如在了解几家互联网公司的云平台的时候（Amazon 的 EC2，M$的 Azure 等等），除非你是这几家公司的员工，否则是很难深入其中的。\r\n\r\n### 寻找自己的兴趣点\r\n\r\n　　学习应当是一件有意思的事情，当你的大脑排斥它的时候，我不相信可以很容易地掌握这门新技术。如果你找不到兴趣点，那么，不妨回到我前文对于新技术是否值得你学习的观点上去，既然你没有什么兴趣，你学它干嘛？西安软件培训\r\n\r\n### 善于比较\r\n\r\n　　比较是一种非常容易上手的思考方式，和什么比较？和相似技术比较，和操作系统、网络这些基础设施上面的例子比较，最后，和生活中的例子比较（譬如，JAVANIO 的实现是一个很好的例子）。\r\n\r\n### 不断获得回馈\r\n\r\n　　回馈是什么？做出一个 HelloWorld 的例子，就是一个极好的回馈；理解某一项实现原理，联想到其它类似的实现，产生一种恍然大悟的感觉，也是一种回馈。在学习的过程中，不断产生回馈，意味着你不断地收获成就感，这是继续下去的动力之一\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/04/3635797580.jpg',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(46,'PHP面向对象 抽象类与接口','46',1428922114,1428922114,'<!--markdown-->在学习PHP面向对象时，都会在抽象类与接口上迷惑，作用差不多为什么还那么容易混淆，何不留一去一？但是事实上两者的区别还是很大的，如果能够很好地运用PHP的两个方法，面向对象的程序设计将会更加合理、清晰高效。\r\n\r\n### 不同点\r\n对接口的使用方式是通过关键字implements来实现的，而对于抽象类的操作是使用类继承的关键字exotends实现的，使用时要特别注意。\r\n接口没有数据成员，但是抽象类有数据成员，抽象类可以实现数据的封装。\r\n接口没有构造函数，抽象类可以有构造函数。\r\n接口中的方法都是public类型，而抽象类中的方法可以使用private、protected或public来修饰。\r\n一个类可以同时实现多个接口，但是只能实现一个抽象类。\r\n\r\n### 相同点\r\n函数体内不能写任何东西，连两个大括号都不能写！！！如：function getName();这样就行了\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(47,'linux下shell编程基础知识','47',1428989820,1428990588,'<!--markdown-->记录常用的shell\r\n\r\n\r\n<!--more-->\r\n\r\n### 1、history    记录历史命令;\r\n预设记录1000条命令，存储在用户家目录 .bash_history 文件中；\r\n!!     执行上一条命令\r\n!n    n为数字，history里面显示的指令数字\r\n!cat    执行最近一次以cat开头的命令\r\n!$    上一条命令的最后一个参数\r\nman builtin    可以查询系统内置的所有命令；\r\n\r\n### 2、指令和文件名补全\r\nTab键    连续按2次列出所有的指令或文件名；\r\n\r\n### 3、别名alias\r\n自定义别名，把很长的经常使用的命令别名一个简单的命令\r\n\r\n```\r\n[root@yonglinux ~]# alias yong=\"cat /etc/sysconfig/network-scripts/ifcfg-eth0\"\r\n[root@yonglinux ~]# yong\r\nDEVICE=eth0\r\nHWADDR=00:0C:29:43:3D:32\r\nTYPE=Ethernet\r\nUUID=0b1f4512-cefa-4a9e-ae85-adb2ac2a9903\r\nONBOOT=yes\r\nNM_CONTROLLED=yes\r\nBOOTPROTO=static\r\nIPADDR=192.168.20.20\r\nNETMASK=255.255.255.0\r\nGATEWAY=192.168.20.2\r\n```\r\nunalias    解除别名\r\n别名永久生效的话，把命令写入到当前用户家目录 .bashrc里面；只对当前用户生效。\r\n\r\n### 4、通配符\r\n*    代表零个或多个任意字符\r\n?    代表1个任意字符\r\n\r\n### 5、输入输出重定向\r\n输出重定向 >\r\n把前面的输出不显示在当前屏幕上，输出到指定文件里面；\r\n追加重定向 >> 把内容追加到文件里面；\r\n输入重定向 <    把后面的文件作为前面命令的输入；\r\n2>        错误重定向（写脚本的时候会用到）\r\n**2>>     错误追加重定向**\r\n\r\n```\r\n[root@localhost ~]# ls -l /dev/stdin \r\nlrwxrwxrwx. 1 root root 15 4月   6 11:04 /dev/stdin -> /proc/self/fd/0\r\n[root@localhost ~]# ls -l /dev/stdout \r\nlrwxrwxrwx. 1 root root 15 4月   6 11:04 /dev/stdout -> /proc/self/fd/1\r\n[root@localhost ~]# ls -l /dev/stderr \r\nlrwxrwxrwx. 1 root root 15 4月   6 11:04 /dev/stderr -> /proc/self/fd/2\r\n```\r\n\r\n标准输入设备stdin用0表示；键盘；\r\n标准输出设备 stdout用1表示，显示器显示；\r\n标准输出错误 stderr用2表示，显示器显示；\r\n\r\n示例：直接ls 会在当前屏幕显示出来，正确和错误的信息；\r\n```\r\n[root@localhost ~]# ls /etc/passwd /etc/passwd1\r\nls: 无法访问/etc/passwd1: 没有那个文件或目录\r\n/etc/passwd\r\n[root@localhost ~]# ls /etc/passwd /etc/passwd1 >1.log 2>&1\r\n[root@localhost ~]# cat 1.log\r\n ls: 无法访问/etc/passwd1: 没有那个文件或目录\r\n /etc/passwd\r\n```\r\n\r\n正确输出1默认可以不用写，直接重定向到1.log里面，2代表错误输出，重定向到&1代表前面的1.log；有时候也可以>>追加到日志；\r\n```\r\n[root@localhost ~]# ls /etc/passwd /etc/passwd1 \r\n&>all.log\r\n[root@localhost ~]# cat all.log \r\nls: 无法访问/etc/passwd1: 没有那个文件或目录\r\n/etc/passwd\r\n```\r\n\r\n&表示所有，包括正确输出1和错误输出2，输出重定向到all.log里面；\r\n\r\n### 6、管道符 |\r\n把前面命令的输出结果作为后面命令的输入\r\n```\r\n[root@yonglinux ~]# cat /etc/passwd | wc -l\r\n25\r\n```\r\n\r\n### 7、作业控制\r\n当运行一个进程时，你可以使它暂停（按Ctrl+z），然后使用fg命令恢复它，利用bg命令使他到后台运行，你也可以使它终止（按Ctrl+c）\r\njobs    可以查看被暂停或在后台运行的任务\r\n```\r\n[root@yonglinux ~]# vmstat 1 > /tmp/1.log \r\n^Z\r\n[1]-  Stopped                 vi file\r\n[2]+  Stopped                 vmstat 1 > /tmp/1.log\r\n[root@yonglinux ~]# jobs\r\n[1]-  Stopped                 vi file\r\n[2]+  Stopped                 vmstat 1 > /tmp/1.log\r\n[root@yonglinux ~]# bg 2\r\n[2]+ vmstat 1 > /tmp/1.log &\r\n[root@yonglinux ~]# jobs\r\n[1]+  Stopped                 vi file\r\n[2]-  Running                 vmstat 1 > /tmp/1.log &\r\n```\r\n\r\n想要让进程在后台运行的话加 &，中间有空格，进程就在后台运行了。\r\nvmstat 1    用来观察系统状态的一个命令。\r\nfg 2 让后台运行的进程回到当前运行，ctrl+c 可以终止进程。\r\n+号显示的为优先级最高。\r\n\r\n另一种情况，关闭当前shell，重新打开另一个shell，使用jobs并不会显示在后台运行的进程。想要停止进程的话，需要知道pid，然后使用kill命令杀死进程。如遇到杀不死的进程，使用 kill -9 pid\r\n\r\n```\r\n[root@yonglinux ~]# ps aux | grep vmstat\r\nroot      1909  0.0  0.1   2016   548 pts/0    S    15:03   0:00 vmstat 1\r\nroot      1941  0.0  0.1   4356   732 pts/0    S+   15:08   0:00 grep vmstat\r\n[root@yonglinux ~]# kill 1909\r\n```\r\n\r\n\r\n### 8、变量，就是使用一个较简单的字符串来替代某些具有特殊意义的设定以及数据。\r\n通常shell预设的变量名为大写。可以使用echo查看变量；\r\n常用变量有:PATH、HOME、LANG、PWD、LOGNAME、HOSTNAME\r\n```\r\n[root@yonglinux ~]# echo $PATH\r\n/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin\r\n[root@yonglinux ~]# echo $HOME\r\n/root\r\n[root@yonglinux ~]# echo $PWD\r\n/root\r\n[root@yonglinux ~]# echo $LOGNAME\r\nroot\r\n[root@yonglinux ~]# echo $HOSTNAME\r\nyonglinux.com\r\n```\r\nenv   可以查看系统预设的所有环境变量；\r\nset    可以列出系统预设的全部变量，包括用户自己设定的变量；\r\n\r\n### 9自定义变量    变量名=变量内容    \r\n自定义变量只在当前shell下生效；bash命令打开一个新的shell，变量就不会生效，退出新shell后，回到当前shell，变量继续生效；\r\n```\r\n[root@yonglinux ~]# ABC=centos\r\n[root@yonglinux ~]# echo $ABC\r\ncentos\r\n[root@yonglinux ~]# bash\r\n[root@yonglinux ~]# echo $ABC\r\n[root@yonglinux ~]# exit\r\nexit\r\n[root@yonglinux ~]# echo $ABC\r\ncentos\r\n```\r\n\r\n### 10变量永久生效的方法：\r\n1）系统下所有用户登录都可以使用该变量\r\n在/etc/profile 配置文件中最后一行，添加\"export myname=YongLinux\"，然后执行source /etc/profile 生效；source命令的作用是，将目前设定的配置刷新，即不用注销再登录也能生效。\r\n```\r\n[root@yonglinux ~]# echo \"export myname=YongLinux\" >> /etc/profile\r\n[root@yonglinux ~]# source /etc/profile\r\n[root@yonglinux ~]# su - user1\r\n[user1@yonglinux ~]$ echo $myname \r\nYongLinux\r\n```\r\n\r\n2）只在当前用户下使用变量\r\n在用户的家目录下 .bashrc 配置文件，添加\"export myname=YongLinux\"，然后执行source .bashrc 生效；\r\n```\r\n[user1@yonglinux ~]$ pwd/home/user1\r\n[user1@yonglinux ~]$ echo \"export myname=YongLinux\" >> .bashrc\r\n[user1@yonglinux ~]$ source .bashrc\r\n[user1@yonglinux ~]$ echo $myname\r\nYongLinux\r\n```\r\n\r\n### 11自定义变量的规则\r\n1)、设定变量的格式“变量名=变量内容”等号两边不能有空格\r\n2)、变量名只能由英文、数字及下划线组成，而且不能以数字开头；\r\n3(、当变量内容带有特殊字符（空格 $），需要加单引号;\r\n```\r\n[root@yonglinux ~]# ABC=\'linux centos\'\r\n[root@yonglinux ~]# echo $ABC\r\nlinux centos\r\n```\r\n\r\n如变量内容中本身有单引号，需要加双引号；\r\n```\r\n[root@yonglinux ~]# ABC=\"Linux\'\"\r\n[root@yonglinux ~]# echo $ABC\r\nLinux\'\r\n```\r\n4)、如果变量内容需要引用其他运行结果，需要使用反引号\r\n```\r\n[root@yonglinux ~]# ABC=`pwd`\r\n[root@yonglinux ~]# echo $ABC\r\n/root\r\n```\r\n\r\n5) 变量内容可以累加其他变量的内容，需要加双引号。\r\n```\r\n[root@yonglinux ~]# AA=\"Angle\"\r\n[root@yonglinux ~]# echo $AA\r\nAngle\r\n[root@yonglinux ~]# AB=\"$AA\"BB\r\n[root@yonglinux ~]# echo $AB\r\nAngleBB\r\n```\r\n单引号和双引号的区别，用双引号时不会取消掉里面出现的特殊字符的本身作用（这里的$），而使用单引号则里面的特殊字符全部失去它本身的作用。\r\n\r\n### 12pstree    以树状图显示当前系统的进程\r\n当前shell下运行bash命令后，会进入一个新的shell，新shell为之前shell的子shell；\r\n```\r\n[root@yonglinux ~]# pstree | grep bash\r\n     |-login---bash\r\n     |-sshd---sshd---bash-+-grep\r\n[root@yonglinux ~]# bash\r\n[root@yonglinux ~]# pstree | grep bash\r\n     |-login---bash\r\n     |-sshd---sshd---bash---bash-+-grep\r\n```\r\n\r\n在父shell中设定一个变量后，进入子shell后变量不会生效；需要在子shell中生效要用exprot指令；export 声明全局变量，让该shell的子shell也知道；如果export后面不加任何变量名，则它会声明所有的变量。\r\n```\r\n[root@yonglinux ~]# echo $AA\r\nAngle\r\n[root@yonglinux ~]# bash\r\n[root@yonglinux ~]# echo $AA\r\n[root@yonglinux ~]# exit\r\nexit\r\n[root@yonglinux ~]# export AA\r\n[root@yonglinux ~]# bash\r\n[root@yonglinux ~]# echo $AA\r\nAngle\r\n```\r\n\r\n### 13、取消变量    unset 变量名\r\n\r\n### 14 系统环境变量与个人环境变量的配置文件\r\n/etc/profile   系统预设的几个重要的变量，例如PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL\r\n/etc/bashrc    预设umask以及PS1等变量。PS1就是我们登录linux 命令行最前面显示的字符；\r\n\\u   用户users\r\n\\h   主机名hostname\r\n\\W   当前目录pwd\r\n\\$   系统用户为#，普通用户显示$\r\n```\r\n[root@yonglinux ~]# echo $PS1[\\u@\\h \\W]\\$\r\n[root@localhost ~]# PS1=\'[\\h@\\u \\W]\\$\'\r\n[localhost@root ~]#\r\n```\r\n更改PS1的显示；\r\n\r\n### 15 每个用户的主目录下还有几个这样的隐藏文件：\r\n.bash_profile ：定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。\r\n.bashrc ：该文件包含专用于你的shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。例如你可以将用户自定义的alias或者自定义变量写到这个文件中。\r\n.bash_history ：记录命令历史用的。\r\n.bash_logout ：当退出shell时，会执行该文件。可以把一些清理的工作放到这个文件中。\r\n\r\n### 16 Linux shell中的特殊字符\r\n*    代表零个或多个任意字符\r\n?    代表一个任意字符\r\n#    代表注释说明的意思，#号后面的内容忽略掉；\r\n\\    脱意字符，将后面的特殊字符（* $）还原为普通字符；\r\n|    管道符，讲前面命令执行的结果作为后面命令的输入；\r\n$    引用变量\r\n;    分隔2个命令，2个命令都执行，不管前面命令是否错误 ls a.txt ; cat a.txt \r\n&    把命令放到后台运行\r\n&&    命令的连接符，第一个执行成功才会执行第二个；\r\n||    分隔命令，只有前面命令运行不成功，才会执行后面的命令；\r\n\r\n### 17 cut    截取某一个字段、字符\r\n-d    指定分隔符，分割字符用单引号 \' \' 括起来\r\n-f    指定第哪个区间\r\n-c    指定第几个字符；指定多个字符 -c 1,5 ;可以指定一个区间 -c 1-4 ;\r\n\r\n\r\n列出以：号分隔列出第7列的内容，只显示前3行；\r\n```\r\n/bin/bash\r\n/sbin/nologin\r\n/sbin/nologin\r\n[root@yonglinux ~]# head -3 passwd |cut -c 1-4\r\nroot\r\nbin:\r\ndaem\r\n```\r\n\r\n### 18  sort    排序输出    默认按首字母升序的顺序排列；\r\n-t    指定分隔符\r\n-k    指定以哪个区间进行排序\r\n-r    逆序排列\r\n-u    删除重复的\r\n-n    按照数字大小排序\r\n-f    忽略大小写\r\n按：号分隔，按第3列uid排序；\r\n\r\n```\r\n[root@localhost ~]# sort -t: -n -k 3 passwd |head -3\r\nroot:x:0:0:root:/root:/bin/bash\r\nROOT:x:1:1:bin:/bin:/sbin/nologin\r\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\r\n```\r\n\r\n### 19 wc    统计行数、单词数、字节数\r\nwc -l      统计行数\r\nwc -w    统计单词数\r\nwc -c     统计字符数（wc -m 一样的功能）\r\n```\r\n[root@yonglinux ~]# wc -l /etc/passwd\r\n24 /etc/passwd\r\n[root@yonglinux ~]# wc -w /etc/passwd\r\n32 /etc/passwd\r\n[root@yonglinux ~]# wc -c /etc/passwd\r\n1041 /etc/passwd\r\n[root@yonglinux ~]# wc /etc/passwd\r\n  24   32 1041 /etc/passwd\r\n```\r\n\r\n\r\n### 20 uniq    去除重复的行\r\n针对数字的话，需要先进行sort排序，再去除重复的行。\r\n-c    统计重复的行数，并写在最前面；\r\n\r\n```\r\n[root@yonglinux tmp]# uniq 1.txt \r\n111\r\n222\r\n111\r\n333\r\n[root@yonglinux tmp]# sort 1.txt | uniq -c\r\n      2 111\r\n      1 222\r\n      1 333\r\n[root@yonglinux tmp]# sort test.txt |uniq -c\r\n      2 12345      \r\n      1 67899      \r\n      2 abc      \r\n      1 helloworld\r\n```\r\n\r\n### 21 tee    重定向文件，并且同时还在屏幕上显示；\r\n\r\n类似与重定向 “>”, 但是比重定向多了一个功能，在把文件写入后面所跟的文件中的同时，还显示在屏幕上。\r\n```\r\n[root@yonglinux ~]# echo \'abcdefg\' | tee test.txt\r\nabcdefg\r\n```\r\n\r\n### 22  tr    替换字符\r\n常用来处理文档中出现的特殊符号，如DOS文档中出现的^M符号；\r\n-d    删除某个字符\r\n\r\n把小写字母变成大写字母\r\n```\r\n[root@yonglinux ~]# head -2 passwd | tr \'[a-z]\' \'[A-Z]\'\r\nROOT:X:0:0:ROOT:/ROOT:/BIN/BASH\r\nBIN:X:1:1:BIN:/BIN:/SBIN/NOLOGIN\r\n```\r\n替换一个字符\r\n```\r\n[root@yonglinux ~]# head -2 passwd | tr \'r\' \'R\'\r\nRoot:x:0:0:Root:/Root:/bin/bash\r\nbin:x:1:1:bin:/bin:/sbin/nologin\r\n```\r\n\r\n### 23 split    切割文档\r\n-b    依据大小来分割文档，单位为byte\r\n-l    依据行数来分割文档。\r\n\r\n示例一，按b大小分割\r\n```\r\n[root@yonglinux ~]# ls -lb passwd\r\n -rw-r--r--. 1 root root 1076 Apr  9 15:14 passwd\r\n[root@yonglinux ~]# split -b 500 passwd\r\n[root@yonglinux ~]# ls -l\r\n-rw-r--r--. 1 root root  500 Apr  9 15:17 xaa\r\n-rw-r--r--. 1 root root  500 Apr  9 15:17 xab\r\n-rw-r--r--. 1 root root   76 Apr  9 15:17 xac\r\n```\r\n\r\n示例二，按l行数分割\r\n```\r\n[root@yonglinux ~]# cat passwd |wc -l\r\n24\r\n[root@yonglinux ~]# split -l 8 passwd \r\n[root@yonglinux ~]# wc -l xa*\r\n   8 xaa   \r\n   8 xab   \r\n   8 xac  \r\n   24 total\r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(48,'c1.png','c1-png',1429175935,1429175935,'a:5:{s:4:\"name\";s:6:\"c1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/3907840293.png\";s:4:\"size\";i:6525;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',54),(49,'c2.png','c2-png',1429175975,1429175975,'a:5:{s:4:\"name\";s:6:\"c2.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/2708383220.png\";s:4:\"size\";i:52682;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',54),(50,'c3.png','c3-png',1429176153,1429176153,'a:5:{s:4:\"name\";s:6:\"c3.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/04/936772038.png\";s:4:\"size\";i:6312;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',54),(51,'c4.png','c4-png',1429176294,1429176294,'a:5:{s:4:\"name\";s:6:\"c4.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/2645820528.png\";s:4:\"size\";i:4230;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',4,1,NULL,'attachment','publish',NULL,0,'1','0','1',54),(52,'c5.png','c5-png',1429176327,1429176327,'a:5:{s:4:\"name\";s:6:\"c5.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/2466371299.png\";s:4:\"size\";i:9994;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',5,1,NULL,'attachment','publish',NULL,0,'1','0','1',54),(53,'c7.png','c7-png',1429176379,1429176379,'a:5:{s:4:\"name\";s:6:\"c7.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/2634483679.png\";s:4:\"size\";i:17741;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',6,1,NULL,'attachment','publish',NULL,0,'1','0','1',54),(54,'linux c 开发php扩展','54',1429176420,1429176720,'<!--markdown-->用C重写一个PHP的系统函数ip2long()解决ip2long在32位与64位系统下值不同的问题（该问题是因为32位与64位的整形范围不同导致的，具体原因请google）。\r\n我们新的ip2long固定返回32位有符号整数，范围-2147483648 到 2147483647，与32位系统相同。\r\n我们的扩展名称为 myip，函数名为 ip2long32\r\n扩展的功能与名称都OK了，现在按流程进行开发。\r\n\r\n\r\n<!--more-->\r\n\r\n### 1 查看php是否编译成功\r\n![c1.png][1]\r\n\r\n### 2 开发流程\r\n![c2.png][2]\r\n\r\n### 3 进入源码目录\r\ncd /home/users/chromev/php-5.5.7/ext\r\n```\r\n./ext_skel --extname=module [--proto=file] [--stubs=file] [--xml[=file]]\r\n           [--skel=dir] [--full-xml] [--no-help]\r\n\r\n  --extname=module   module is the name of your extension（模块名，会在当前目录创建一个该名称子目录）\r\n  --proto=file       file contains prototypes of functions to create（函数原型定义文件）\r\n  --stubs=file       generate only function stubs in file\r\n  --xml              generate xml documentation to be added to phpdo     c-cvs\r\n  --skel=dir         path to the skeleton directory(设置骨架生成的目录，不设置该项则默认在ext/extname下)\r\n  --full-xml         generate xml documentation for a self-contained extension\r\n                     (not yet implemented)\r\n  --no-help          don\'t try to be nice and create comments in the code\r\n                     and helper functions to test if the module compiled (生成的代码中不显示各种帮助注释)\r\n```\r\n执行生成框架\r\n```\r\n./ext_skel --extname=myip --proto=myip.pro\r\n```\r\n\r\n进入目录\r\n```\r\ncd myip\r\nls -al\r\n```\r\n![c3.png][3]\r\n\r\n\r\n### 4. 修改myip.pro,添加\r\n```\r\nint ip2long32(string ip)\r\n```\r\n这意味着我们的扩展中有一个函数，返回值为int型，输入为string。 \r\n\r\n\r\n### 5. 修改config.m4\r\nvim config.m4\r\n![c4.png][4]\r\n\r\n\r\n### 6. C编码\r\nvim myip.c\r\n![c5.png][5]\r\n图中就是扩展骨架工具根据我们提供的函数原型生成的对应函数，此处有几个需要注意的地方：\r\n\r\n   1). PHP_FUNCTION：是PHP核心定义的一个宏，与ZEND_FUNCTION相同，用于定义扩展函数，实际生成的函数名称为zif_ip2long32。\r\n\r\n   2). zend_parse_parameters：由于PHP为弱类型语言，而C是强类型，因此需要使用该函数用于接收PHP传入的参数，并进行一定的类型转换，将PHP的变量转为C语言能够辨认的类型。\r\n\r\n      zend_parse_parameters函数的原型如下：\r\n\r\n      zend_parse_parameters(int num_args TSRMLS_CC, char *type_spec, …);\r\n\r\nnum_args：传递给函数的参数个数。通常的做法是使用宏 ZEND_NUM_ARGS()。\r\n\r\n   3)TSRMLS_CC：\r\n          线程安全，总是传递TSRMLS_CC宏。 \r\n          详解：http://www.54chen.com/php-tech/what-is-tsrmls_cc.html    \r\n          type_spec：第三个参数是一个字符串，指定了函数期望的参数类型\r\n\r\n   4):需要随参数值更新的变量列表\r\n\r\n\r\n\r\n\r\n\r\n函数修改\r\n![c7.png][6]\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 7 编译，配置，测试\r\n在ext当前目录执行\r\n```\r\n     /usr/local/webserver/php/phpize\r\n     ./configure -with-php-config=/usr/local/webserver/php/bin/php-config\r\n     make && make install\r\n```\r\n出现　\r\n```\r\nInstalling shared extensions:     /usr/local/webserver/php/lib/php/extensions/no-debug-non-zts-20121212/\r\n```\r\n查看 \r\n```\r\nls /usr/local/webserver/php/lib/php/extensions/no-debug-non-zts-20121212/\r\n```\r\n是否存在 myip.so\r\n\r\n添加扩展\r\n```  \r\nvim php.ini\r\nextension_dir = \"/usr/local/webserver/php/lib/php/extensions/debug-non-zts-20090626/\"\r\nextension = myip.so\r\n```\r\n退出保存，并重启php，如果是使用Phpfpm的话可以执行如下命令：\r\n```\r\nkill -USR2 `cat /usr/local/webserver/php/var/run/php-fpm.pid`\r\n```\r\n看下扩展是否正常载入：\r\n```\r\nphp -m|grep myip\r\n```\r\n\r\n测试\r\n```\r\nphp -r \"var_dump(ip2long32(\'192.168.1.1\'));\"\r\nint(-1062731519)\r\n\r\nphp -r \"var_dump(ip2long(\'192.168.1.1\'));\"  \r\nint(3232235777)\r\n```\r\n如上所示，ip2long32输出的是32位有符号整数，而ip2long输出的是64位无符号整数，大功告成！\r\n\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/04/3907840293.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/04/2708383220.png\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/04/936772038.png\r\n  [4]: http://blog.chromev.com/usr/uploads/2015/04/2645820528.png\r\n  [5]: http://blog.chromev.com/usr/uploads/2015/04/2466371299.png\r\n  [6]: http://blog.chromev.com/usr/uploads/2015/04/2634483679.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(55,'程序员是碗青春饭，如何才能让自己不过时？','55',1430041320,1430041760,'<!--markdown-->### 程序员越来越值钱了\r\n\r\n　　今年是程序员的招聘大年，企业给出的offer平均比去年要多出30%到50%。如果不对老员工进行大幅度地加薪，将会出现大面积的严重倒挂现象，虽然出现这种自毁长城的可能性很小。\r\n\r\n　　试想一下，技术水平和业务熟练度都要高出不少的老员工，怎么可能忍受菜鸟的薪水比自己还要高。真遇到这种老板，可能第二天就会递辞职信。\r\n\r\n ![b1.jpg][1]\r\n\r\n　　程序员，是越来越值钱了。全面信息化的社会发展需求是一方面，另一方面则是来自政府政策方面的推动。习大大在打老虎的闲暇之余，还抽空到在乌镇召开的首届互联网大会致辞；李克强总理在两会期间提出“互联网＋”的概念，还放出话来要给人民降网费和流量费。不管是不是泡沫，程序员这一行将会是未来几年最热的职业，可能没有之一。\r\n\r\n \r\n\r\n### 我们是不是不应该太乐观\r\n\r\n　　虽然钱途貌似一片光明，可是计算机专业的学生同样也面临着两个非常严峻的问题。第一，技术更新换代非常快，必须保持比较高的学习强度才能保证自己不被淘汰。第二，对于科班出身的程序员来说，一个中专大专毕业的学生到社会上随便学一个android或ios的培训班就可以找到一份月薪非常可观的工作，读四年（名牌）大学的优势又在哪里呢\r\n\r\n**第一个问题我们可以从刘未鹏老师的《暗时间》里找到答案——**\r\n    重视知识的本质，对于程序员来说这一点尤其重要。程序员行业的知识芜杂海量，而且总是在增长变化。应对这个问题办法只能是 抓住不变量。 \r\n    大量的新技术其实只是一层皮，背后的支撑技术其实都是十来年不变的东西。底层知识永远都不过时；算法数据结构永远都不过时；分析问题和解决问题的能力永远都不过是；强大的学习能力和旺盛的求知欲永远都不过时；你大脑的思维方式永远都不过时。\r\n\r\n　　在学校的时候，我们总是觉得像《计算机组成原理》、《编译原理》、《算法与数据结构》之类的科目没有用，一心只想赶快动手编程，学一些最新最潮的东西。现在看来，当年的自己还是太年轻了。 \r\n\r\n**对于第二个问题，看完第一个问题的回答之后，你应该就大概猜到答案会是：基本功。**\r\n\r\n![b2.jpg][2]\r\n\r\n　　越是基础的东西越到后面越重要。不懂算法数据结构和网络基础的程序员只能当一辈子的码农，远远称不上是软件开发工程师，更别提负责更高层次的职能。就好像nba里的顶级球星，他们平时训练的时候不是找一帮人来打比赛，而是聘请专业的投篮教练或体能师给自己磨最基本的投篮动作和练体能。武侠小说的男主，遇到的名师都会在一开始的时候只让他们练基本功，可见基础的重要性。\r\n\r\n \r\n\r\n　　**更关键的是，越是基础的东西越难速成，所以很难在意识到其重要性的时候临时补救。**\r\n\r\n \r\n\r\n　　学生们要珍惜在大学里的时间，有的时候不妨试着硬着头皮、逼着自己学一点《计算机网络》之类的基础知识，在日后的工作当中总会给你带来意想不到的惊喜和收获。已经工作的程序员们，下班之后也可以看看《代码大全》之类的书，学一学好的代码规范，借鉴一些前人的经验教训，夯实基础，\r\n\r\n \r\n\r\n　　让自己永不过时。\r\n\r\n \r\n转载 http://www.cnblogs.com/levenyes/p/4457674.html\r\n\r\n \r\n\r\n \r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/04/375321874.jpg\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/04/3211201858.jpg',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(56,'b1.jpg','b1-jpg',1430041464,1430041464,'a:5:{s:4:\"name\";s:6:\"b1.jpg\";s:4:\"path\";s:34:\"/usr/uploads/2015/04/375321874.jpg\";s:4:\"size\";i:13796;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',55),(57,'b2.jpg','b2-jpg',1430041481,1430041481,'a:5:{s:4:\"name\";s:6:\"b2.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2015/04/3211201858.jpg\";s:4:\"size\";i:60547;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',55),(58,'c开发php扩展2','58',1430194824,1430194824,'<!--markdown-->### 为什么要开发PHP扩展\r\nPHP取得成功的一个主要原因之一是她拥有大量的可用扩展。web开发者无论有何种需求，这种需求最有可能在PHP发行包里找到。PHP发行包包括支持各种数据库，图形文件格式，压缩，XML技术扩展在内的许多扩展。\r\n编写php扩展理由之一是　网站并发量很高时，需要优化php,就可以把某些常用php类写成扩展\r\n\r\n\r\n<!--more-->\r\n\r\n### 必备工具\r\nautoconf / gcc / make / php5 / php5-dev\r\n\r\n\r\n![请输入图片描述][1]\r\n\r\n### 开发流程\r\n![请输入图片描述][2]\r\n\r\n### 进入源码目录\r\ncd /home/users/chromev/php-5.5.7/ext\r\n```\r\n./ext_skel --extname=module [--proto=file] [--stubs=file] [--xml[=file]]\r\n           [--skel=dir] [--full-xml] [--no-help]\r\n\r\n  --extname=module   module is the name of your extension（模块名，会在当前目录创建一个该名称子目录）\r\n  --proto=file       file contains prototypes of functions to create（函数原型定义文件）\r\n  --stubs=file       generate only function stubs in file\r\n  --xml              generate xml documentation to be added to phpdo     c-cvs\r\n  --skel=dir         path to the skeleton directory(设置骨架生成的目录，不设置该项则默认在ext/extname下)\r\n  --full-xml         generate xml documentation for a self-contained extension\r\n                     (not yet implemented)\r\n  --no-help          don\'t try to be nice and create comments in the code\r\n                     and helper functions to test if the module compiled (生成的代码中不显示各种帮助注释)\r\n```\r\n### ext_skel工具的使用\r\n```\r\n./ext_skel --extname=test\r\n```\r\n进入目录\r\n```\r\ncd test\r\n```\r\n\r\n### 修改config.m4 \r\n```\r\n PHP_ARG_ENABLE(test, whether to enable test support,\r\n Make sure that the comment is aligned:\r\n [  --enable-test           Enable test support])\r\n```\r\n\r\n### phpize的使用\r\n```\r\n/usr/local/webserver/php/phpize\r\n./configure -with-php-config=/usr/local/webserver/php/bin/php-config\r\nmake && make install\r\n```\r\n添加扩展\r\n```\r\nextension = test.so\r\n```\r\n\r\n### 测试\r\n```\r\nphp -r \"echo confirm_test_compiled(\'a\');\"\r\n```\r\n输出\r\n```\r\nCongratulations! You have successfully modified ext/test/config.m4. Module a is now compiled into PHP.\r\n```\r\n显示成功,这个是默认生成的函数\r\n```\r\nPHP_FUNCTION(confirm_test_compiled)\r\n{\r\n	char *arg = NULL;\r\n	int arg_len, len;\r\n	char *strg;\r\n\r\n	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &arg, &arg_len) == FAILURE) {\r\n		return;\r\n	}\r\n\r\n	len = spprintf(&strg, 0, \"Congratulations! You have successfully modified ext/%.78s/config.m4. Module %.78s is now compiled into PHP.\", \"test\", arg);\r\n	RETURN_STRINGL(strg, len, 0);\r\n}\r\n```\r\n\r\n### 添加一个新函数test_hello\r\n定义\r\n```\r\nvim php_test.h\r\nPHP_FUNCTION(test_hello); \r\n```\r\n\r\n实现\r\n```\r\nvim test.c\r\nconst zend_function_entry test_functions[] = {\r\n  PHP_FE(test_hello, NULL)\r\n  PHP_FE(confirm_test_compiled,	NULL)		/* For testing, remove later. */\r\n  PHP_FE_END	/* Must be the last line in test_functions[] */\r\n};\r\n\r\nPHP_FUNCTION(test_hello)\r\n{\r\n  long a,b; // 定义整型\r\n  char *c;　// 定义字符串\r\n  int c_len; // 定义整型长度\r\n  \r\n  /* 接收php传入参数 */\r\n  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"lls\", &a, &b, &c, &c_len) == FAILURE) {\r\n    return;\r\n  }\r\n  char *str;\r\n  /* 实现 */\r\n  int len = spprintf(&str, 0, \"%s : %d\\n\", c, a * b);\r\n  /* 返回字符串 */\r\n  RETURN_STRINGL(str, len, 0);\r\n}\r\n```\r\n\r\n### 编译\r\n```\r\nmake && make install\r\n```\r\n\r\n### 测试\r\n```\r\nphp -r \"echo test_hello(100, 200, \'100 * 200\');\" \r\n100 * 200 : 20000\r\n```\r\n\r\n完成,这是只是一些简单的，ZEND_API还是需要很长时间的练习。\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/04/3907840293.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/04/2708383220.png\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/04/2645820528.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(59,'linux find基本概念','59',1431346200,1431395106,'<!--markdown-->1、find命令的一般形式为；\r\n\r\nfind pathname -options [-print -exec -ok ...]\r\n\r\n2、find命令的参数；\r\n\r\npathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。\r\n\r\n-print： find命令将匹配的文件输出到标准输出。\r\n\r\n-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为\'command\' { } ;，注意{ }和；之间的空格。\r\n\r\n-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\r\n\r\n3、find命令选项\r\n\r\n-name\r\n\r\n按照文件名查找文件。\r\n\r\n-perm\r\n\r\n按照文件权限来查找文件。\r\n\r\n-prune\r\n\r\n使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。\r\n\r\n-user\r\n\r\n按照文件属主来查找文件。\r\n\r\n-group\r\n\r\n按照文件所属的组来查找文件。\r\n\r\n-mtime -n +n\r\n\r\n按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。\r\n\r\n-nogroup\r\n\r\n查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。\r\n\r\n-nouser\r\n\r\n查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。\r\n\r\n-newer file1 ! file2\r\n\r\n查找更改时间比文件file1新但比文件file2旧的文件。\r\n\r\n-type\r\n\r\n查找某一类型的文件，诸如：\r\n\r\nb - 块设备文件。\r\n\r\nd - 目录。\r\n\r\nc - 字符设备文件。\r\n\r\np - 管道文件。\r\n\r\nl - 符号链接文件。\r\n\r\nf - 普通文件。\r\n\r\n-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。\r\n\r\n-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。\r\n\r\n-mount：在查找文件时不跨越文件系统mount点。\r\n\r\n-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。\r\n\r\n-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。\r\n\r\n###### 另外,下面三个的区别:\r\n\r\n-amin n\r\n\r\n查找系统中最后N分钟访问的文件\r\n\r\n-atime n\r\n\r\n查找系统中最后n*24小时访问的文件\r\n\r\n-cmin n\r\n\r\n查找系统中最后N分钟被改变文件状态的文件\r\n\r\n-ctime n\r\n\r\n查找系统中最后n*24小时被改变文件状态的文件\r\n\r\n-mmin n\r\n\r\n查找系统中最后N分钟被改变文件数据的文件\r\n\r\n-mtime n\r\n\r\n查找系统中最后n*24小时被改变文件数据的文件\r\n\r\n4、使用exec或ok来执行shell命令\r\n\r\n使用find命令时，只要把想要的操作写在一个文件里，就可以用exec来配合find命令查找，很方便的\r\n\r\n在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。\r\n\r\nexec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。\r\n\r\n例如：为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中\r\n```\r\n# find . -type f -exec ls -l { } \\;\r\n\r\n-rw-r--r-- 1 root root 34928 2003-02-25 ./conf/httpd.conf\r\n\r\n-rw-r--r-- 1 root root 12959 2003-02-25 ./conf/magic\r\n\r\n-rw-r--r-- 1 root root 180 2003-02-25 ./conf.d/README\r\n```\r\n\r\n上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。\r\n\r\n在/logs目录中查找更改时间在5日以前的文件并删除它们：\r\n\r\n$ find logs -type f -mtime +5 -exec rm { } \\;\r\n\r\n记住：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。\r\n\r\n在下面的例子中， find命令在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。\r\n```\r\n$ find . -name \"*.conf\" -mtime +5 -ok rm { } \\;\r\n\r\n< rm ... ./conf/httpd.conf > ? n\r\n```\r\n按y键删除文件，按n键不删除。\r\n\r\n任何形式的命令都可以在-exec选项中使用。\r\n\r\n在下面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd*”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个sam用户。\r\n```\r\n# find /etc -name \"passwd*\" -exec grep \"sam\" { } \\;\r\n\r\nsam:x:501:501::/usr/sam:/bin/bash\r\n```\r\nfind命令的例子；\r\n\r\n1、查找当前用户主目录下的所有文件：\r\n\r\n下面两种方法都可以使用\r\n\r\n$ find $HOME -print\r\n\r\n$ find ~ -print\r\n\r\n2、让当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件；\r\n```\r\n$ find . -type f -perm 644 -exec ls -l { } \\;\r\n```\r\n3、为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径；\r\n```\r\n$ find / -type f -size 0 -exec ls -l { } \\;\r\n```\r\n4、查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们；\r\n```\r\n$ find /var/logs -type f -mtime +7 -ok rm { } \\;\r\n```\r\n5、为了查找系统中所有属于root组的文件；\r\n```\r\n$find . -group root -exec ls -l { } \\;\r\n\r\n-rw-r--r-- 1 root root 595 10月 31 01:09 ./fie1\r\n```\r\n6、find命令将删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件。\r\n\r\n该命令只检查三位数字，所以相应文件的后缀不要超过999。先建几个admin.log*的文件 ，才能使用下面这个命令\r\n```\r\n$ find . -name \"admin.log[0-9][0-9][0-9]\" -atime -7 -ok\r\n\r\nrm { } ;\r\n\r\n< rm ... ./admin.log001 > ? n\r\n\r\n< rm ... ./admin.log002 > ? n\r\n\r\n< rm ... ./admin.log042 > ? n\r\n\r\n< rm ... ./admin.log942 > ? n\r\n```\r\n7、为了查找当前文件系统中的所有目录并排序；\r\n```\r\n$ find . -type d | sort\r\n```\r\n8、为了查找系统中所有的rmt磁带设备；\r\n```\r\n$ find /dev/rmt -print\r\n```\r\nxargs\r\n\r\nxargs - build and execute command lines from standard input\r\n\r\n在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。\r\n\r\nfind命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。\r\n\r\n在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；\r\n\r\n而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。\r\n\r\n来看看xargs命令是如何同find命令一起使用的，并给出一些例子。\r\n\r\n下面的例子查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件\r\n```\r\n#find . -type f -print | xargs file\r\n\r\n./.kde/Autostart/Autorun.desktop: UTF-8 Unicode English text\r\n\r\n./.kde/Autostart/.directory: ISO-8859 text\r\n\r\n......\r\n```\r\n在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：\r\n```\r\n$ find / -name \"core\" -print | xargs echo \"\" >/tmp/core.log\r\n```\r\n上面这个执行太慢，我改成在当前目录下查找\r\n```\r\n#find . -name \"file*\" -print | xargs echo \"\" > /temp/core.log\r\n\r\n# cat /temp/core.log\r\n\r\n./file6\r\n```\r\n在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：\r\n```\r\n# ls -l\r\n\r\ndrwxrwxrwx 2 sam adm 4096 10月 30 20:14 file6\r\n\r\n-rwxrwxrwx 2 sam adm 0 10月 31 01:01 http3.conf\r\n\r\n-rwxrwxrwx 2 sam adm 0 10月 31 01:01 httpd.conf\r\n\r\n# find . -perm -7 -print | xargs chmod o-w\r\n\r\n# ls -l\r\n\r\ndrwxrwxr-x 2 sam adm 4096 10月 30 20:14 file6\r\n\r\n-rwxrwxr-x 2 sam adm 0 10月 31 01:01 http3.conf\r\n\r\n-rwxrwxr-x 2 sam adm 0 10月 31 01:01 httpd.conf\r\n```\r\n用grep命令在所有的普通文件中搜索hostname这个词：\r\n```\r\n# find . -type f -print | xargs grep \"hostname\"\r\n\r\n./httpd1.conf:# different IP addresses or hostnames and have them handled by the\r\n\r\n./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames\r\n\r\non your\r\n```\r\n用grep命令在当前目录下的所有普通文件中搜索hostnames这个词：\r\n```\r\n# find . -name * -type f -print | xargs grep \"hostnames\"\r\n\r\n./httpd1.conf:# different IP addresses or hostnames and have them handled by the\r\n\r\n./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames\r\n\r\non your\r\n```\r\n注意，在上面的例子中， 用来取消find命令中的*在shell中的特殊含义。\r\n\r\nfind命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。\r\n\r\nfind命令的参数\r\n\r\n下面是find命令一些常用参数的例子，有用到的时候查查就行了，像上面前几个贴子，都用到了其中的的一些参数，也可以用man或查看论坛里其它贴子有find命令手册\r\n\r\n1、使用name选项\r\n\r\n文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。\r\n\r\n可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。\r\n\r\n不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合*.txt的文件，使用~作为 \'pathname\'参数，波浪号~代表了你的$HOME目录。\r\n```\r\n$ find ~ -name \"*.txt\" -print\r\n```\r\n想要在当前目录及子目录中查找所有的‘ *.txt’文件，可以用：\r\n```\r\n$ find . -name \"*.txt\" -print\r\n```\r\n想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：\r\n\r\n$ find . -name \"[A-Z]*\" -print\r\n\r\n想要在/etc目录中查找文件名以host开头的文件，可以用：\r\n\r\n$ find /etc -name \"host*\" -print\r\n\r\n想要查找$HOME目录中的文件，可以用：\r\n```\r\n$ find ~ -name \"*\" -print 或find . -print\r\n```\r\n要想让系统高负荷运行，就从根目录开始查找所有的文件。\r\n```\r\n$ find / -name \"*\" -print\r\n```\r\n如果想在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件，下面的命令就能够返回名为ax37.txt的文件：\r\n```\r\n$find . -name \"[a-z][a-z][0--9][0--9].txt\" -print\r\n```\r\n2、用perm选项\r\n\r\n按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。\r\n\r\n如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：\r\n```\r\n$ find . -perm 755 -print\r\n```\r\n还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-006相当于666\r\n```\r\n# ls -l\r\n\r\n-rwxrwxr-x 2 sam adm 0 10月 31 01:01 http3.conf\r\n\r\n-rw-rw-rw- 1 sam adm 34890 10月 31 00:57 httpd1.conf\r\n\r\n-rwxrwxr-x 2 sam adm 0 10月 31 01:01 httpd.conf\r\n\r\ndrw-rw-rw- 2 gem group 4096 10月 26 19:48 sam\r\n\r\n-rw-rw-rw- 1 root root 2792 10月 31 20:19 temp\r\n\r\n# find . -perm 006\r\n\r\n# find . -perm -006\r\n\r\n./sam\r\n\r\n./httpd1.conf\r\n\r\n./temp\r\n\r\n-perm mode:文件许可正好符合mode\r\n\r\n-perm +mode:文件许可部分符合mode\r\n\r\n-perm -mode: 文件许可完全符合mode\r\n```\r\n3、忽略某个目录\r\n\r\n如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。\r\n\r\n如果希望在/apps目录下查找文件，但不希望在/apps/bin目录下查找，可以用：\r\n```\r\n$ find /apps -path \"/apps/bin\" -prune -o -print\r\n```\r\n4、使用find查找文件的时候怎么避开某个文件目录\r\n\r\n比如要在/usr/sam目录下查找不在dir1子目录之内的所有文件\r\n\r\nfind /usr/sam -path \"/usr/sam/dir1\" -prune -o -print\r\n\r\nfind [-path ..] [expression] 在路径列表的后面的是表达式\r\n\r\n-path \"/usr/sam\" -prune -o -print 是 -path \"/usr/sam\" -a -prune -o\r\n\r\n-print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 && 和 || 类似如果 -path \"/usr/sam\" 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path \"/usr/sam\" -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。\r\n\r\n这个表达式组合特例可以用伪码写为\r\n\r\nif -path \"/usr/sam\" then\r\n\r\n-prune\r\n\r\nelse\r\n\r\n-print\r\n\r\n避开多个文件夹\r\n\r\nfind /usr/sam ( -path /usr/sam/dir1 -o -path /usr/sam/file1 ) -prune -o -print\r\n\r\n圆括号表示表达式的结合。\r\n\r\n表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。\r\n\r\n查找某一确定文件，-name等选项加在-o 之后\r\n```\r\n#find /usr/sam (-path /usr/sam/dir1 -o -path /usr/sam/file1 ) -prune -o -name \"temp\" -print\r\n```\r\n5、使用user和nouser选项\r\n\r\n按文件属主查找文件，如在$HOME目录中查找文件属主为sam的文件，可以用：\r\n```\r\n$ find ~ -user sam -print\r\n```\r\n在/etc目录下查找文件属主为uucp的文件：\r\n```\r\n$ find /etc -user uucp -print\r\n```\r\n为了查找属主帐户已经被删除的文件，可以使用-nouser选项。这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。\r\n\r\n例如，希望在/home目录下查找所有的这类文件，可以用：\r\n```\r\n$ find /home -nouser -print\r\n```\r\n6、使用group和nogroup选项\r\n\r\n就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项，为了在/apps目录下查找属于gem用户组的文件，可以用：\r\n```\r\n$ find /apps -group gem -print\r\n```\r\n要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件\r\n```\r\n$ find / -nogroup-print\r\n```\r\n7、按照更改时间或访问时间等查找文件\r\n\r\n如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。\r\n\r\n用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。\r\n\r\n希望在系统根目录下查找更改时间在5日以内的文件，可以用：\r\n```\r\n$ find / -mtime -5 -print\r\n```\r\n为了在/var/adm目录下查找更改时间在3日以前的文件，可以用：\r\n```\r\n$ find /var/adm -mtime +3 -print\r\n```\r\n8、查找比某个文件新或旧的文件\r\n\r\n如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为：\r\n\r\nnewest_file_name ! oldest_file_name\r\n\r\n其中，！是逻辑非符号。\r\n\r\n查找更改时间比文件sam新但比文件temp旧的文件：\r\n\r\n例：有两个文件\r\n```\r\n-rw-r--r-- 1 sam adm 0 10月 31 01:07 fiel\r\n\r\n-rw-rw-rw- 1 sam adm 34890 10月 31 00:57 httpd1.conf\r\n\r\n-rwxrwxr-x 2 sam adm 0 10月 31 01:01 httpd.conf\r\n\r\ndrw-rw-rw- 2 gem group 4096 10月 26 19:48 sam\r\n\r\n-rw-rw-rw- 1 root root 2792 10月 31 20:19 temp\r\n\r\n# find -newer httpd1.conf ! -newer temp -ls\r\n\r\n1077669 0 -rwxrwxr-x 2 sam adm 0 10月 31 01:01 ./httpd.conf\r\n\r\n1077671 4 -rw-rw-rw- 1 root root 2792 10月 31 20:19 ./temp\r\n\r\n1077673 0 -rw-r--r-- 1 sam adm 0 10月 31 01:07 ./fiel\r\n```\r\n查找更改时间在比temp文件新的文件：\r\n```\r\n$ find . -newer temp -print\r\n```\r\n9、使用type选项\r\n\r\n在/etc目录下查找所有的目录，可以用：\r\n```\r\n$ find /etc -type d -print\r\n```\r\n在当前目录下查找除目录以外的所有类型的文件，可以用：\r\n```\r\n$ find . ! -type d -print\r\n```\r\n在/etc目录下查找所有的符号链接文件，可以用\r\n```\r\n$ find /etc -type l -print\r\n```\r\n10、使用size选项\r\n\r\n可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。\r\n\r\n在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。\r\n\r\n在当前目录下查找文件长度大于1 M字节的文件：\r\n```\r\n$ find . -size +1000000c -print\r\n```\r\n在/home/apache目录下查找文件长度恰好为100字节的文件：\r\n```\r\n$ find /home/apache -size 100c -print\r\n```\r\n在当前目录下查找长度超过10块的文件（一块等于512字节）：\r\n```\r\n$ find . -size +10 -print\r\n```\r\n11、使用depth选项\r\n\r\n在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。\r\n\r\n在下面的例子中， find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。\r\n\r\n它将首先匹配所有的文件然后再进入子目录中查找。\r\n```\r\n$ find / -name \"CON.FILE\" -depth -print\r\n```\r\n12、使用mount选项\r\n\r\n在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。\r\n\r\n从当前目录开始查找位于本文件系统中文件名以XC结尾的文件：\r\n```\r\n$ find . -name \"*.XC\" -mount -print\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(60,'黑苹果安装','60',1431649680,1431651833,'<!--markdown-->简单的步骤 单磁盘的操作,有时间再详细整理\r\n\r\n软件整合需要整理，transmac, clover最新版本，[mac10.10境像][1]，MultiBeast,voodooHDA \r\n\r\n<!--more-->\r\n\r\n\r\n1 win7下制作　mac系统的u盘, clover+mac10.10的境像, 使用工具 traceMac\r\n    原理是 U盘格式化成 efi分区+mac\r\n2 台式电脑支持 uefi\r\n    windows的引导+分区是  bios+mbr\r\n    mac 的是             uefi+gpt\r\n\r\n  1) 把原来的磁盘格式化成 空盘 (现买的外接光驱，光盘ghost上的pe工具)\r\n  2) 插入做好的u盘,clover是最新版本，选择 boot from os yes\r\n  3) 空格键 选择最后一个　注入驱动\r\n  4) 进入mac os,选择 上方菜单的 磁盘工具，把整个硬盘格式成gpt分区,注意查看选项\r\n     其实会分成三个 efi+gpt+recovery hd,另外两个看不到\r\n  5) 点击继续，把境像放入到硬盘，重启，重复2步骤\r\n  6) 再次进入时，可以看到一些系统引导配置了，配置好了，进入系统\r\n  7)　进入系统，格式化　efi为 fat32,和u盘的一样\r\n     diskutil list\r\n     newfs_msdos -v EFI /dev/diskXsX\r\n     mkdir /Volumes/EFI\r\n     mount_msdos /dev/diskXsX /Volumes/EFI\r\n  8) 将u盘的efi整个目录放入到 /Volumes/EFI,硬盘引导做好\r\n  9) 将注入的驱动  efi/clover/kexts/10.10/　放入到 硬盘里的system/library/extension/ \r\n     cp -r efi/clover/kexts/10.10/   system/library/extension/ \r\n\r\n  10) 安装网卡驱动，使用 MultiBeast软件装网卡驱动\r\n      voodooHDA 目前使用2.7.3装声卡\r\n      鼠标未装\r\n  11) 重启如果出现 boot,参考 http://bbs.feng.com/forum.php?mod=viewthread&tid=7534160&page=1#pid110026139\r\n\r\n3 软件安装\r\n  1) 先装homebrew\r\n      http://segmentfault.com/a/1190000000606752\r\n  2) 程序员如何优雅地使用 Mac？\r\n        http://www.zhihu.com/question/20873070\r\n \r\n\r\n\r\n  [1]: http://bbs.pcbeta.com/viewthread-1542110-1-1.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(66,'1.png','1-png',1432343049,1432343049,'a:5:{s:4:\"name\";s:5:\"1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/05/3542028003.png\";s:4:\"size\";i:11922;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',63),(63,'Linux  流、管道和重定向','63',1432342560,1432350743,'<!--markdown-->重定向标准 I/O 流：标准输出和标准错误\r\n通过管道将一个命令的输出导入到另一个命令的输入\r\n将输出发送到 stdout 和文件中\r\n将命令输出用作另一个命令的参数\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n### 一、标准输入、输出、错误\r\n\r\n![1.png][1]\r\n\r\n1 符号方法\r\n1)、标准输入（stdin）：代码为0，使用< 或 << \r\n2)、标准输出（stdout）：代码为1，使用>或>>\r\n3)、标准错误输出（stderr）：代码为2，使用2>或2>>\r\n\r\n备注\r\n符号**<, >, 2>** 清空FILE,重新写入\r\n符号**>>, <<, 2>>**  不清空,追加\r\n```\r\ncd ~\r\nls -al > desk\r\ncat desk\r\n```\r\n\r\n注意，这个newroot文件可以事先不创建，当执行到重定向的命令后，若不存在此文件，系统会自动创建，如果这个文件事先存在，那么系统会先将这个文件清空，然后写入重定向的数据。\r\n\r\n2 将流导入文件\r\n1> ：是将正确的数据输出到指定的地方去\r\n2> ：是将错误的数据输出到指定的地方去\r\n\r\n```\r\n#　查找/usr目录下bin文件,以普通chromev\r\nfind /usr  -name \"bin\" 1>/home/users/chromev/s_right 2>/home/users/chromev/s_error    \r\nmore s_right\r\ncat s_error\r\n```\r\n\r\n3 丢弃错误数据　2> /dev/null, /dev/null相当于 垃圾桶功能, 导入这个数据都会丢失\r\nfind /usr  -name \"bin\" 1>/home/users/chromev/s_right 2>/dev/null\r\n\r\n4 将正确,错误数据写入到同一个文件\r\n```\r\nfind /home -name test >list 2> list 错误写法\r\nfind /home -name test >list 2>&1 正确写法\r\n``` \r\n5  符号 **<**  将原本需要由键盘输入的数据，经由档案来读入，比如　我们可以使用 cat 在键盘上面输入一些数据，然后写入一个档案内\r\n由键盘写入 \r\n```\r\ncat > catfile\r\naaa\r\nbbb\r\n```\r\n按ctrl+d结束,写入到 catfile文件中\r\n\r\n改由档案写入\r\n```\r\ncat > cat2 < catfile\r\ncat cat2\r\n```\r\n\r\n注意符号 输入符号 **<<**\r\n```\r\ncat > catfile <<eof\r\n> a\r\n> b\r\n> eof\r\ncat catfile\r\n``` \r\n利用 << 右侧的控制字符，我们可以终止一次输入， 而不必输入 [crtl]+d 来结束\r\n\r\n### **二 命令执行的判断依据     ;   &&     || **\r\n\r\n**;** 表示执行完前一个命令，继续执行后一个命令例如关机时，希望我可以先执行两次 sync ，然后才 shutdown 计算机\r\n\r\n```\r\nsync; sync; shutdown -h now\r\n```\r\n\r\n&& 表示前面一个指令执行未出现错误，则执行后一个指令。若前一个出错，则不再执行后面指令。\r\n||  表示前面一个指令若执行错误，则执行后面指令，若前一个指令没有出错，则后面指令不再执行（正好与&&相反）。\r\n\r\n```\r\nls aaa || echo \'fail\'\r\nls catfile && echo \'success\' \r\n```\r\n\r\n正确\r\n**ls /tmp/chromev && echo \"exist\" || echo \"not exist\"**\r\n错误\r\n**ls /tmp/chromev || echo \"not exist\" && echo \"exist\"**\r\n因为指令是一个一个往下执行，因此，在上面的例子当中，如果 /tmp/chromev 不存在时，他会：\r\n1. 若 ls /tmp/chromev 不存在，因此回传一个非为 0 的数值；\r\n2. 接下来经过 || 的判断，发现前一个指令回传非为 0 的数值，因此，程序开始执行 echo \"not exist\" ，而 echo \"not exist\" 程序肯定可以执行成功，因此会回传一个 0 值给后面的指令；\r\n3. 经过 && 的判断，所以就开始执行 echo \"exist\" 。\r\n\r\n### 三 双向重定向（三通）\r\n![2.png][2]\r\n我们可以利用tee命令将数据流分送到文件与屏幕，对于linux系统来书，其stdout就是指的屏幕。\r\n\r\n```\r\ntee [-a] file\r\n-a ：以累加 (append) 的方式，将数据加入 file 当中！\r\n\r\nlast | tee last.list | cut -d \" \" -f1\r\n```\r\n这个范例可以让我们将 last 的输出存一份到 last.list 档案中；\r\n\r\n```\r\nlast |cut -c 2-15|tee last2\r\nlast |tee last2 |cut -c 2-15\r\n```\r\n按照对管道符号“|” 的理解，我们可以知道，\r\n第一个会先用cut命令截取了数据然后显示到屏幕，在将已经截取好的数据存入last2文件内。\r\n而第二个，会将last命令的所有内容先存的last2（不执行截取），然后对显示到屏幕上的内容执行cut命令截取数据。\r\n\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/05/3542028003.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/05/411172319.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(69,'2.png','2-png',1432349795,1432349795,'a:5:{s:4:\"name\";s:5:\"2.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/05/411172319.png\";s:4:\"size\";i:8111;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',63),(70,'Linux中find常见用法示例','70',1432435740,1433396291,'<!--markdown-->·find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \\;\r\nfind命令的参数；\r\n\r\npathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。\r\n-print： find命令将匹配的文件输出到标准输出。\r\n-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为\'command\' { } \\;，注意{ }和\\；之间的空格。\r\n-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\r\n\r\n#-print 将查找到的文件输出到标准输出\r\n#-exec   command   {} \\;      —–将查到的文件执行command操作,{} 和 \\;之间有空格\r\n#-ok 和-exec相同，只不过在操作前要询用户\r\n例：find . -name .svn | xargs rm -rf\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n====================================================\r\n\r\n```\r\n-name   filename             #查找名为filename的文件\r\n-perm                        #按执行权限来查找\r\n-user    username             #按文件属主来查找\r\n-group groupname            #按组来查找\r\n-mtime   -n +n                #按文件更改时间来查找文件，-n指n天以内，+n指n天以前\r\n-atime    -n +n               #按文件访问时间来查GIN: 0px\">\r\n\r\n-ctime    -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前\r\n\r\n-nogroup                     #查无有效属组的文件，即文件的属组在/etc/groups中不存在\r\n-nouser                     #查无有效属主的文件，即文件的属主在/etc/passwd中不存\r\n-newer   f1 !f2              找文件，-n指n天以内，+n指n天以前 \r\n-ctime    -n +n               #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 \r\n-nogroup                     #查无有效属组的文件，即文件的属组在/etc/groups中不存在\r\n-nouser                      #查无有效属主的文件，即文件的属主在/etc/passwd中不存\r\n-newer   f1 !f2               #查更改时间比f1新但比f2旧的文件\r\n-type    b/d/c/p/l/f         #查是块设备、目录、字符设备、管道、符号链接、普通文件\r\n-size      n[c]               #查长度为n块[或n字节]的文件\r\n-depth                       #使查找在进入子目录前先行查找完本目录\r\n-fstype                     #查更改时间比f1新但比f2旧的文件\r\n-type    b/d/c/p/l/f         #查是块设备、目录、字符设备、管道、符号链接、普通文件\r\n-size      n[c]               #查长度为n块[或n字节]的文件\r\n-depth                       #使查找在进入子目录前先行查找完本目录\r\n-fstype                      #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到\r\n-mount                       #查文件时不跨越文件系统mount点\r\n-follow                      #如果遇到符号链接文件，就跟踪链接所指的文件\r\n-cpio                %;      #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到\r\n-mount                       #查文件时不跨越文件系统mount点\r\n-follow                      #如果遇到符号链接文件，就跟踪链接所指的文件\r\n-cpio                        #对匹配的文件使用cpio命令，将他们备份到磁带设备中\r\n-prune                       #忽略某个目录\r\n```\r\n\r\n=====================================================\r\n```\r\n$find   ~   -name   \"*.txt\"   -print    #在$HOME中查.txt文件并显示\r\n$find   .    -name   \"*.txt\"   -print\r\n$find   .    -name   \"[A-Z]*\"   -print   #查以大写字母开头的文件\r\n$find   /etc   -name   \"host*\"   -print #查以host开头的文件\r\n$find   .   -name   \"[a-z][a-z][0–9][0–9].txt\"    -print   #查以两个小写字母和两个数字开头的txt文件\r\n$find .   -perm   755   -print\r\n$find   .   -perm -007   -exec ls -l {} \\;   #查所有用户都可读写执行的文件同-perm 777\r\n$find   . -type d   -print\r\n$find   .   !   -type   d   -print \r\n$find   .   -type l   -print\r\n\r\n$find   .   -size   +1000000c   -print        #查长度大于1Mb的文件\r\n$find   .   -size   100c         -print       # 查长度为100c的文件\r\n$find   .   -size   +10   -print              #查长度超过期作废10块的文件（1块=512字节）\r\n\r\n$cd /\r\n$find   etc   home   apps    -depth   -print   | cpio   -ivcdC65536   -o   /dev/rmt0\r\n$find   /etc -name \"passwd*\"   -exec grep   \"cnscn\"   {}   \\;   #看是否存在cnscn用户\r\n$find . -name \"yao*\"   | xargs file\r\n$find   . -name \"yao*\"   |   xargs   echo    \"\" > /tmp/core.log\r\n$find   . -name \"yao*\"   | xargs   chmod   o-w\r\n```\r\n======================================================\r\n```\r\nfind   -name april*                     在当前目录下查找以april开始的文件\r\nfind   -name   april*   fprint file        在当前目录下查找以april开始的文件，并把结果输出到file中\r\nfind   -name ap* -o -name may*   查找以ap或may开头的文件\r\nfind   /mnt   -name tom.txt   -ftype vfat   在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件\r\nfind   /mnt   -name t.txt ! -ftype vfat   在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件\r\nfind   /tmp   -name wa* -type l            在/tmp下查找名为wa开头且类型为符号链接的文件\r\nfind   /home   -mtime   -2                 在/home下查最近两天内改动过的文件\r\nfind /home    -atime -1                  查1天之内被存取过的文件\r\nfind /home -mmin    +60                  在/home下查60分钟前改动过的文件\r\nfind /home   -amin   +30                  查最近30分钟前被存取过的文件\r\nfind /home   -newer   tmp.txt             在/home下查更新时间比tmp.txt近的文件或目录\r\nfind /home   -anewer   tmp.txt            在/home下查存取时间比tmp.txt近的文件或目录\r\nfind   /home   -used   -2                  列出文件或目录被改动过之后，在2日内被存取过的文件或目录\r\nfind   /home   -user cnscn                列出/home目录内属于用户cnscn的文件或目录\r\nfind   /home   -uid   +501                  列出/home目录内用户的识别码大于501的文件或目录\r\nfind   /home   -group   cnscn              列出/home内组为cnscn的文件或目录\r\nfind   /home   -gid 501                   列出/home内组id为501的文件或目录\r\nfind   /home   -nouser                    列出/home内不属于本地用户的文件或目录\r\nfind   /home   -nogroup                   列出/home内不属于本地组的文件或目录\r\nfind   /home    -name tmp.txt    -maxdepth   4   列出/home内的tmp.txt 查时深度最多为3层\r\nfind   /home   -name tmp.txt   -mindepth   3   从第2层开始查\r\nfind   /home   -empty                     查找大小为0的文件或空目录\r\nfind   /home   -size   +512k                查大于512k的文件\r\nfind   /home   -size   -512k               查小于512k的文件\r\nfind   /home   -links   +2                查硬连接数大于2的文件或目录\r\nfind   /home   -perm   0700                查权限为700的文件或目录\r\nfind   /tmp   -name tmp.txt   -exec cat {} \\;\r\nfind   /tmp   -name   tmp.txt   -ok   rm {} \\;\r\n\r\nfind    /   -amin    -10     # 查找在系统中最后10分钟访问的文件\r\nfind    /   -atime   -2        # 查找在系统中最后48小时访问的文件\r\nfind    /   -empty             # 查找在系统中为空的文件或者文件夹\r\nfind    /   -group   cat        # 查找在系统中属于 groupcat的文件\r\nfind    /   -mmin   -5         # 查找在系统中最后5分钟里修改过的文件\r\nfind    /   -mtime   -1       #查找在系统中最后24小时里修改过的文件\r\nfind    /   -nouser           #查找在系统中属于作废用户的文件\r\nfind    /   -user    fred     #查找在系统中属于FRED这个用户的文件\r\n```\r\n查当前目录下的所有普通文件\r\n```\r\nfind . -type f -exec ls -l {} \\; \r\n-rw-r–r–    1 root      root         34928 2003-02-25   ./conf/httpd.conf \r\n-rw-r–r–    1 root      root         12959 2003-02-25   ./conf/magic \r\n-rw-r–r–    1 root      root          180 2003-02-25   ./conf.d/README \r\n```\r\n查当前目录下的所有普通文件，并在- e x e c选项中使用ls -l命令将它们列出\r\n=================================================\r\n在/ l o g s目录中查找更改时间在5日以前的文件并删除它们：\r\n```\r\n$ find logs -type f -mtime +5 -exec   -ok   rm {} \\;\r\n```\r\n=================================================\r\n查询当天修改过的文件\r\n```\r\n[root@book class]# find   ./   -mtime   -1   -type f   -exec   ls -l   {} \\;\r\n```\r\n=================================================\r\n查询文件并询问是否要显示\r\n```\r\n[root@book class]# find   ./   -mtime   -1   -type f   -ok   ls -l   {} \\;  \r\n< ls … ./classDB.inc.php > ? y\r\n-rw-r–r–    1 cnscn    cnscn       13709   1月 12 12:22 ./classDB.inc.php\r\n[root@book class]# find   ./   -mtime   -1   -type f   -ok   ls -l   {} \\;  \r\n< ls … ./classDB.inc.php > ? n\r\n[root@book class]#\r\n```\r\n\r\n=================================================\r\n查询并交给awk去处理\r\n```\r\n[root@book class]# who   |   awk   ’{print $1\"\\t\"$2}’\r\ncnscn    pts/0\r\n```\r\n=================================================\r\nawk—grep—sed\r\n\r\n```\r\n[root@book class]# df   -k |   awk ‘{print $1}’ |   grep   -v   ’none’ |   sed   s\"/\\/dev\\///g\"\r\n文件系统\r\nsda2\r\nsda1\r\n[root@book class]# df   -k |   awk ‘{print $1}’ |   grep   -v   ’none’\r\n文件系统\r\n/dev/sda2\r\n/dev/sda1\r\n```\r\n\r\n1)在/tmp中查找所有的*.h，并在这些文件中查找“SYSCALL_VECTOR\"，最后打印出所有包含\"SYSCALL_VECTOR\"的文件名\r\nA) find   /tmp   -name   \"*.h\"   | xargs   -n50   grep SYSCALL_VECTOR\r\nB) grep   SYSCALL_VECTOR   /tmp/*.h | cut    -d’:\'   -f1| uniq > filename\r\nC) find   /tmp   -name \"*.h\"   -exec grep \"SYSCALL_VECTOR\"   {}   \\; -print\r\n\r\n2)find / -name filename -exec rm -rf {} \\;\r\n    find / -name filename -ok rm -rf {} \\;\r\n\r\n3)比如要查找磁盘中大于3M的文件：\r\nfind . -size +3000k -exec ls -ld {} ;\r\n\r\n4)将find出来的东西拷到另一个地方\r\nfind *.c -exec cp ‘{}’ /tmp ‘;’\r\n\r\n如果有特殊文件，可以用cpio，也可以用这样的语法：\r\nfind dir -name filename -print | cpio -pdv newdir\r\n\r\n6)查找2004-11-30 16:36:37时更改过的文件\r\n# A=`find ./ -name \"*php\"` |   ls -l –full-time $A 2>/dev/null | grep \"2004-11-30 16:36:37\"\r\n\r\nLinux-all, Linux | No Comments »\r\n\r\nfind 实例\r\n四月 18th, 2006\r\n　　要在/usr/linux中查找所有的*.h，并在这些文件中查找“SYSCALL_VECTOR\"，最后打印出所有包含\"SYSCALL_VECTOR\"的文件名，有以下几种方法实现\r\n```\r\nfind /usr/linux -name \"*.h\" | xargs -n50 grep SYSCALL_VECTOR\r\ngrep SYSCALL_VECTOR /usr/linux/*.h | cut -d’:’ -f1 | uniq > filename\r\nfind /usr/linux -name \"*.h\" -exec grep \"SYSCALL_VECTOR\" {} \\; -print\r\n```\r\n我用find / -name filename| rm -rf，不成功，请问为什么不成功？\r\n```\r\nfind / -name filename -exec rm -rf {} \\;\r\nfind . -name filename |rm -rf试一下{} 表示你找出来的结果。\r\n```\r\n\\; 则相当于“宪法”，没什么说头，就是这么规定的，在 -exec 后面需要一个表示该命令终结的的符号。可以在 man find 中找到答案。\r\n要让rm识别find的结果，如下：\r\nfind / -name filename |xargs rm -rf\r\n之所以find . -name filename |rm -rf不通过，是因为rm命令不接受从标准输入传过来的指令\r\n查找含特定字符串的文件\r\n例如查找当前目录下含有\"the string you want find…\"字符串的文件：\r\n```\r\n$find . -type f -exec grep “the string you want find…” {} ; -print\r\n```\r\n从根目录开始查tmpfile，一旦查到马上删除\r\n```\r\nfind / -name \"tmpfile\" -exec rm {} \\;\r\n```\r\n　　find 的perm问题\r\n请问一下以下命令什么意思？关键是那个数字前的-，其他都还知道\r\nfind -name \".*\" -perm -007\r\n我知道\r\nfind -name \".*\" -perm 755\r\n这个是用来查找权限位为755的隐藏文件\r\n噢，对了还有，我上边的命令都省略了find的pathname参数 find默认是查找当前工作目录的吗？\r\n如果我用 -ok 替代 -exec, 那么还需要加上 {} \\; 吗？\r\n这个已经清楚，仍然需要，因为 -ok 只是 -exec 的提示模式，它只是多了一个确认操作的步骤,刚才没有读懂那几句E文的意思 呵呵 不好意思\r\n-007是指查找所有用户都可读、写、执行的文件，要小心呀~~~\r\n解释解释？\r\nfind -name \".*\" -perm -007 和 find -name \".*\" -perm 777 有区别吗？\r\n-007是怎么来得呢？\r\n不过有一个问题\r\n我用 find . -perm -100 会列出当前目录 . , 这是为什么呢？\r\n\r\n下面引用由explover在 2002/10/01 06:15am 发表的内容：\r\n-007是指查找所有用户都可读、写、执行的文件，要小心呀~~~\r\n-007是查找含其它用户(不同组,非属主)可读,写,执行的文件.并不一定要同组可读写,-是指最少权限为007.\r\n下面引用由一颗小白菜在 2002/10/01 10:16am 发表的内容：\r\nOK了， 呵呵\r\n不过有一个问题\r\n我用 find . -perm -100 会列出当前目录 . , 这是为什么呢？\r\n这种方法不会准确的找出目录的. -100是指权限至少是属主可运行.\r\n在unix系统下,你可以拥有对目录文件的执行权你才可以进入一个目录.这便是目录文件被列出的原因.\r\nfind . -perm -001 -print找到往往是目录文件.\r\n我的意思当然不是使用这种方法来找目录，只不过不明白其中的 -100 意义了\r\n那以此类推，是不是 -010是指权限至少是owner同组可执行的吗？也就是说其实这里的010和-是分开的，-表示一个至少的意思，而且010才是真正用来描述权限位的？\r\n这样子就明白了 谢谢你噢\r\n\r\n　　将find出来的东西拷到另一个地方?\r\nfind *.c -exec cp ‘{}’ /tmp ‘;’\r\n如果有特殊文件，可以用cpio，也可以用这样的语法：\r\nfind dir -name filename -print | cpio -pdv newdir\r\n\r\n　　找出磁盘中某个大小范围内的文件\r\n比如要查找磁盘中大于3M的文件：\r\nfind . -size +3000k -exec ls -ld {} ;\r\n\r\n　　如何用find查找某一天更改的文件？\r\n可以使用这一行命令来实现：\r\nA=`find ~ -print` | ls -l –full-time $A 2>/dev/null | grep \"Jun 27\" | grep 1998\r\n\r\n　　使用find 命令查找某个时间段的shell怎么写。比如11点到12点的。thanks\r\n创建一个脚本judgetime，内容如下：\r\nls -l $*|awk ‘{split($8,hour,\":\");if((hour[1]>23 || hour[1] < 1)&&hour[1]<24)print}’\r\n到要查找的目录下，运行\r\nfind ./ -name \"*\" -exec judgetime {} \\;\r\n注意时间格式为２４小时制。\r\nthank you ，如果我要精确到分钟呢\r\ntouch -t 04241112 starttemp #精确到12分钟\r\ntouch -t 04241220 endtemp #截止到12点20\r\nfind [dir] -newer starttemp -a ! -newer endtemp -exec ls -l {} \\;\r\nｎｅｗｅｒ？\r\n那昨天１２：１０文件如何呢？\r\n每天执行的时候，用当天的日期和时间戳替换一下不就行了吗？\r\n我不知道他是不是把所有的11：00~12：00的都找出来，是不是只执行一次还是每天都执行？\r\n这种情况俺猜想是自己的东西放在哪忘了，只记得当时是深夜了。\r\n有道理！\r\n不愧是斑竹！\r\n不光知道怎么解决问题，还知道在什么情况下出现这类问题，佩服佩服！\r\n问题又出现了。创建这个文件的时候。本来应该是时间的一栏现在写上了2002，而不是12：00.\r\n等到12：00过了吧！\r\n\r\n　　删除指定日期的文件\r\nfind ./ -name 文件名 -exec rm -f {} \\;\r\n例：删除当前30天内没用过的文件,用如下命令：\r\nfind / -atime +30 -exec rm -f {} \\;\r\n我自己试着写了一小段SHELL,也用ll ,grep, rm 几个命令，用起来还差强人意。\r\n对过滤出来的文件名列表中用了一个FOR语句，再执行rm 。现在我想把这段SHELL 扩展一下让它每天定时运行将 n 天前的文件删掉，有没有人能给我一些提示，谢谢！\r\n还有个问题，对于前面那位朋友提到的\"find / -atime +30 -exec rm -f {} \\;\r\n\"方法，我很早就试过几次，不过好像都不太对，参数 -atime n 是查找n天前被访问过的文件，我不明白的是这里的时间参照点是什么，以及这个n天是怎么计算的。\r\n问 题二、对于\"ll |cut -f 1\" 这个命令我是不是用错了，我只想取出 ll 中列出的文件名，但用cut -f 命令做不到 ，我只好换用 ll |cut -c 59- 这种方式得到我要的文件名，but it’s a pool idear ！我也试过用awk ，好像也不对，看看大家可不可以给我一些小小的提醒，TKS SO MUCH\r\n问题三、如何改变 I结点 的日期格式 我现在的系统显示的格式是：\r\n-rw-r—– 1 msahz01 users 2253 2002年2月 2日 poheader.i\r\n我想把这换成\r\n-rw-rw-rw- 1 house users 2193 Apr 19 2001 hkdisp.p\r\n如何才能做到这点？\r\nawk 应该可以\r\nll | awk ‘{print $9}’\r\n删除多少天之前的文件\r\nfind /yourpath -mtime +31 -exec rm {} \\;\r\nfind /yourpath -mtime +366 -exec rm {} \\;\r\n\r\nfind中, -ctime, -mtime及其-atime有何区别\r\n\r\n请问 -ctime 和 -mtime 有什么关系 ?\r\n如果父目录的 ctime 改变, 那它下面的文件的 ctime 就会自动都改了吗 ?\r\n-ctime 和 -mtime ,-atime 这些信息是存在哪儿呢 ?\r\n\r\n我用 -mtime -1 找到了新建或改的文件.\r\n但怎样才能找到一天内 mv 来的文件呢( 它们的时间是原有的时间,早于一天 ) ?\r\n\r\n用-newer选项啊。\r\n你可以先touch一个你想要的时间的文件如下：\r\n$ touch -t 08190800 test\r\n$ ls -l test\r\n-rw-r–r– 1 dba other 0 Aug 19 08:00 test\r\n然后\r\n$ find . -newer test -print\r\n.\r\n./.sh_history\r\n$ ls -l .sh_history\r\n-rw——- 1 dba other 154 Aug 20 17:39 .sh_history\r\n\r\n用touch可以写出你想要的任何时间的文件，然后用-newer ,! -newer选项即可成功。\r\n\r\n1.ctime含inode信息修改的时间.mtime只指文件内容建立或修改的时间.\r\n2 不会.\r\n3.这些信息应该是存在文件系统的超级块里.\r\n\r\n我查了书 -ctime 是指 inode 的改变(或称文件的状态改变).\r\n请问 inode 存了哪些信息 ?\r\n做了些小测试,-mtime 改, -ctime 一定也改.\r\n改文件名, -ctime 也会改.\r\n谁能回答 i-node 存了哪些东西 ?\r\n\r\nvi /usr/include/sys/inode.h\r\n\r\n班主,我不能 access /usr/include/sys/inode.h .\r\n摘书如下:\r\nDirectories contain directory entries. Each entry contains a file or subdirectory name and an index node reference number (i-node number). To increase speed and enhance use of disk space, the data in a file is stored at various locations in the computer’s memory. The i-node contains the addresses used to locate all the scattered blocks of data associated with a file. The i-node also records other information about the file including time of modification and access, access modes, number of links, file owner, and file type.\r\n可我发现 -atime 改了, -ctime 还没改. why ?\r\n( 我先 cat 一个 ASCII 文件,再用 -atime -1 有它用 -ctime -1 居然没有它.)\r\n着岂不跟 inode 信息改变, ctime 就改矛盾吗?\r\n\r\n我不同意你贴出来的那段文章,正如我提到的那样,atime,ctime,mtime是放到超级块里,在sco unix下是一种叫stat的结构.(stat_32),不同的系统文件系统可能不同.\r\nsco 下inode的结构如下:\r\n\r\ntypedef struct inode\r\n{\r\nstruct inode *i_forw; /* inode hash chain */\r\nstruct inode *i_back; /* ‘’ */\r\nstruct inode *av_forw; /* freelist chain */\r\nstruct inode *av_back; /* ‘’ */\r\nint *i_fsptr; /* \"typeless\" pointer to fs dependent */\r\nino32_t i_number; /* i number, 1-to-1 with dev address */\r\nushort i_ftype; /* file type = IFDIR, IFREG, etc. */\r\nshort i_fstyp; /* File system type */\r\noff_t i_size; /* size of file */\r\nushort i_uid; /* owner */\r\nushort i_gid; /* group of owner */\r\nushort i_flag;\r\nushort i_want; /* i_flag extension to avoid MP races */\r\nushort i_count; /* reference count */\r\nshort i_nlink; /* directory entries */\r\ndev_t i_rdev; /* Raw device number */\r\n#define i_namtype i_rdev /* i_ftype==IFNAM subtype */\r\ndev_t i_dev; /* device where inode resides */\r\nstruct mount *i_mton;/* ptr to mount table entry that */\r\n/* this directory is mounted on */\r\nstruct region *i_rp; /* ptr to shared region if any */\r\nstruct stdata *i_sp; /* ptr to associated stream */\r\nstruct iisem *isem; /* ptr to XENIX semaphores */\r\nstruct iisd *isd; /* ptr to XENIX shared data */\r\n} i_un;\r\n#define i_mnton i_un.i_mton /* i_ftype==IFDIR IMOUNT */\r\n#define i_rptr i_un.i_rp /* i_ftype==IFREG || i_ftype==IFBLK */\r\n#define i_sptr i_un.i_sp /* i_ftype==IFCHR || i_ftype==IFIFO */\r\n#define i_sem i_un.isem /* i_ftype==IFNAM && i_namtype==IFSEM */\r\n#define i_sd i_un.isd /* i_ftype==IFNAM && i_namtype==IFSHD */\r\n\r\nstruct fstypsw *i_fstypp; /* ptr to file system switch FSPTR */\r\nlong *i_filocks; /* pointer to filock (structure) list */\r\nunsigned long i_mappages; /* number of pages currently cached */\r\nunsigned long i_vcode; /* read-ahead block save (NFS) */\r\nshort i_wcnt; /* write open count or ITEXT count */\r\nstruct lockb i_cilock; /* tas to synchronize i_flag changes */\r\nushort i_rdlocks; /* count of non-exclusive lockers */\r\n} inode_t;\r\n\r\n所以,访问一个文件不能改变inode信息.\r\n使用chown, chgrp, chmod命令可以很好的比较mtime和ctime\r\nchown改变一个文件的属主,用ctime可以找到,用mtime便找不到.\r\n试试看.\r\n\r\n多谢斑竹! 我是在 Solaris 上面试的.我是对 -ctime 不明白.\r\n试的结果如下:\r\n修改文件,-mtime 改了, -ctime 也会改.\r\n访问文件,-atime 改了, -ctime 没变.\r\nchown, chgrp, chmod,mv, 都会使 -ctime 改变,但不影响 -atime 和 -mtime.\r\ntouch 可以改 -mtime and/or -atime,但 touch -a 只改访问时间时,-ctime也改了.\r\ntouch -m 改修改时间时,-ctime当然也改了.\r\n好象还有别的很多东西可以令 -ctime 改变, 搞不清楚.\r\n有什么方法可以显示 -mtime,atime,ctime 吗?\r\n可以用 -ctime 来实现对目录的增量文件进行备份或 transfer 吗 ?\r\n多谢!\r\n\r\n没有什么工具显示,(可能是俺不知道)\r\n把下面程序里的st_mtime换成st_ctime,或st_atime便可以得到你要的了.\r\n#include\r\nint\r\nmain (int argc, char **argv)\r\n{\r\nstruct stat buf;\r\nchar date[80];\r\nchar fname[80];\r\nprintf(\"Enter filename (with full path) to check mtime : \");\r\nscanf(\"%s\",fname);\r\nstat(fname, &buf);\r\nprintf (\"mtime (in sec) of %s = %ld\\n\", fname, buf.st_mtime);\r\nstrcpy(date, ctime((time_t *)&(buf.st_mtime)));\r\nprintf (\"mtime (in date) of %s = %s\\n\", fname, date);\r\n}\r\n\r\n至于文件备份,有什么不可以的么?\r\n\r\nmtime ls -l 最近修改文件内容的时间\r\natime ls -lu 最近访问文件的时间\r\nctime ls -li 最近文件有所改变的状态 ,如文件修改,属性\\属主 改变 ,节点 ,链接变化等 ,应该是不拘泥只是时间前后的改变\r\n\r\n俺看了ls的帮助,以为只是按ctime或atime排序,显示的时间还是mtime.\r\n\r\n仔细比较了一下,ayhan说的是对的.谢谢ayhan.\r\n\r\n多谢 ahyan 提示 ! 我在 Solaris 上试过如下:\r\nmtime 用 ls -l 看到\r\natime 用 ls -lu 看到\r\nctime 用 ls -lc 看到. (ls -li 只有 inode number)\r\n摘书如下:\r\n-c Uses time of last modification of the i-node (file\r\ncreated, mode changed, and so forth) for sorting (-t)\r\nor printing (-l or -n).\r\n-u Uses time of last access instead of last modification\r\nfor sorting (with the -t option) or printing (with the\r\n-l option).\r\n-i For each file, prints the i-node number in the first\r\ncolumn of the report.',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(71,'PHP7测试','71',1434535782,1434535782,'<!--markdown-->',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(72,'Linux 挂载硬盘，分区，挂载','72',1434602441,1434602441,'<!--markdown-->下面的操作将会把数据盘划分为一个分区来使用\r\n主要命令\r\ndf -lh, fdisk -l, mkfs.ext3 /dev/xvdb1, mount\r\n\r\n1、查看数据盘\r\n在没有分区和格式化数据盘之前，使用 “df –h”命令，是无法看到数据盘的，可以使用“fdisk -l”命令查看。如下图：\r\n\r\n\r\n友情提示：若您执行fdisk -l命令，发现没有 /dev/xvdb 表明您的云服务无数据盘，那么您无需进行挂载，此时该教程对您不适用\r\n\r\n2、 对数据盘进行分区\r\n执行“fdisk -S 56 /dev/xvdb”命令，对数据盘进行分区；\r\n根据提示，依次输入“n”，“p”“1”，两次回车，“wq”，分区就开始了，很快就会完成。\r\n\r\n\r\n3、 查看新的分区\r\n使用“fdisk -l”命令可以看到，新的分区xvdb1已经建立完成了。\r\n\r\n\r\n\r\n\r\n\r\n 4、格式化新分区\r\n以ext3为例：使用“mkfs.ext3 /dev/xvdb1”命令对新分区进行格式化，格式化的时间根据硬盘大小有所不同。\r\n(也可自主决定选用其它文件格式，如ext4等)\r\n \r\n\r\n 5、添加分区信息\r\n使用“echo \'/dev/xvdb1  /mnt ext3    defaults    0  0\' >> /etc/fstab”（不含引号）命令写入新分区信息。\r\n然后使用“cat /etc/fstab”命令查看，出现以下信息就表示写入成功。\r\n注：ubuntu12.04不支持barrier，所以正确写法是：echo \'/dev/xvdb1  /mnt ext3    barrier=0  0  0\' >> /etc/fstab\r\n*  如果需要把数据盘单独挂载到某个文件夹，比如单独用来存放网页，可以修改以上命令中的/mnt部分\r\n\r\n\r\n \r\n6、挂载新分区\r\n使用“mount -a”命令挂载新分区，然后用“df -h”命令查看，出现以下信息就说明挂载成功，可以开始使用新的分区了。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(73,'df1.png','df1-png',1434609302,1434609302,'a:5:{s:4:\"name\";s:7:\"df1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/06/4021381564.png\";s:4:\"size\";i:10247;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',77),(74,'du1.png','du1-png',1434609399,1434609399,'a:5:{s:4:\"name\";s:7:\"du1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/06/2336277426.png\";s:4:\"size\";i:20111;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',77),(75,'du2.png','du2-png',1434609452,1434609452,'a:5:{s:4:\"name\";s:7:\"du2.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/06/1215596058.png\";s:4:\"size\";i:4005;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',77),(76,'du4.png','du4-png',1434609543,1434609543,'a:5:{s:4:\"name\";s:7:\"du4.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/06/4192268085.png\";s:4:\"size\";i:12872;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',4,1,NULL,'attachment','publish',NULL,0,'1','0','1',77),(77,'Linux下查看文件和文件夹大小的df和du命令','77',1434609540,1434609554,'<!--markdown--> 当磁盘大小超过标准时会有报警提示，这时如果掌握df和du命令是非常明智的选择。\r\n    df可以查看一级文件夹大小、使用比例、档案系统及其挂入点，但对文件却无能为力。\r\n    du可以查看文件及文件夹的大小。\r\n    两者配合使用，非常有效。比如用df查看哪个一级目录过大，然后用df查看文件夹或文件的大小，如此便可迅速确定症结。\r\n\r\n\r\n<!--more-->\r\n\r\n  df命令可以显示目前所有文件系统的可用空间及使用情形，请看下列这个例子：\r\n![df1.png][1]\r\n参数 -h 表示使用「Human-readable」的输出，也就是在档案系统大小使用 GB、MB 等易读的格式。\r\n    上面的命令输出的第一个字段（Filesystem）及最后一个字段（Mounted on）分别是档案系统及其挂入点。我们可以看到 /dev/sda1 这个分割区被挂在根目录下。\r\n    接下来的四个字段 Size、Used、Avail、及 Use% 分别是该分割区的容量、已使用的大小、剩下的大小、及使用的百分比。 FreeBSD下，当硬盘容量已满时，您可能会看到已使用的百分比超过 100%，因为 FreeBSD 会留一些空间给 root，让 root 在档案系统满时，还是可以写东西到该档案系统中，以进行管理。\r\n    du：查询文件或文件夹的磁盘使用空间\r\n    如果当前目录下文件和文件夹很多，使用不带参数du的命令，可以循环列出所有文件和文件夹所使用的空间。这对查看究竟是那个地方过大是不利的，所以得指定深入目录的层数，参数：--max-depth=，这是个极为有用的参数！如下，注意使用“*”，可以得到文件的使用空间大小.\r\n    提醒：一向命令比linux复杂的FreeBSD，它的du命令指定深入目录的层数却是比linux简化，为 -d。\r\n\r\n![du1.png][2]\r\n\r\n![du2.png][3]\r\n\r\n![du4.png][4]\r\n\r\n du 统计文件大小相加 \r\n    df  统计数据块使用情况\r\n    如果有一个进程在打开一个大文件的时候,这个大文件直接被rm 或者mv掉，则du会更新统计数值，df不会更新统计数值,还是认为空间没有释放。直到这个打开大文件的进程被Kill掉。\r\n    如此一来在定期删除 /var/spool/clientmqueue下面的文件时，如果没有杀掉其进程，那么空间一直没有释放。\r\n    使用下面的命令杀掉进程之后，系统恢复。\r\n    fuser -u /var/spool/clientmqueue\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/06/4021381564.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/06/2336277426.png\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/06/1215596058.png\r\n  [4]: http://blog.chromev.com/usr/uploads/2015/06/4192268085.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(78,'Git  diff, clean, ','78',1434624780,1434625160,'<!--markdown-->git diff,\r\n\r\ngit clean\r\n在利用git工作时，工程目录下经常会出现一些未跟踪文件，虽然git支持通过.gitingore文件添加一些忽略文件类型和文件目录。但有时需要清理一些临时文件和自动生成的文件，手动删除显得太麻烦，这时你可以利用git clean命令来帮你完成这项操作。转载请注明出处：http://glgjing.github.io/。git clean命令支持以下参数：\r\n\r\n\r\n<!--more-->\r\n\r\n### git diff\r\n在git提交环节，存在三大部分：working tree, index file, commit\r\n\r\n这三大部分中：\r\nworking tree：就是你所工作在的目录，每当你在代码中进行了修改，working tree的状态就改变了。\r\nindex file：是索引文件，它是连接working tree和commit的桥梁，每当我们使用git-add命令来登记后，index file的内容就改变了，此时index file就和working tree同步了。\r\ncommit：是最后的阶段，只有commit了，我们的代码才真正进入了git仓库。我们使用git-commit就是将index file里的内容提交到commit中。\r\n总结一下：\r\ngit diff：是查看working tree与index file的差别的。\r\ngit diff --cached：是查看index file与commit的差别的。\r\ngit diff HEAD：是查看working tree和commit的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息）\r\n\r\n\r\n```\r\ngit clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>...\r\n```\r\n其中几个主要参数用法如下：\r\n```\r\n-d   # 删除未跟踪目录以及目录下的文件，如果目录下包含其他git仓库文件，并不会删除（-dff可以删除）。\r\n-f   # 如果 git cofig 下的 clean.requireForce 为true，那么clean操作需要-f(--force)来强制执行。\r\n-i   # 进入交互模式\r\n-n   # 查看将要被删除的文件，并不实际删除文件\r\n```\r\n\r\n通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：\r\n\r\n通过以上几根参数组合，基本上可以满足删除未跟踪文件的需求了。例如在删除前先查看有哪些文件将被删除运行：\r\n```\r\ngit clean -n\r\n```\r\n想删除当前工作目录下的未跟踪文件，但不删除文件夹运行（如果clean.requireForce为false可以不加-f选项）：\r\n```\r\ngit clean -f\r\n```\r\n想删除当前工作目录下的未跟踪文件以及文件夹运行：\r\n```\r\ngit clean -df\r\n```\r\n\r\n### 常用撤销操作\r\n```\r\n删除当前仓库内未受版本管理的文件：$ git clean -d -f 删除目录及文件 就是修改还使用git add\r\n还原当前仓库版本管理的　已修改文件 $ git checkout -- .\r\n                               $ git checkout -- path/to/file\r\n恢复仓库到上一次的提交状态：$ git reset --hard\r\n回退所有内容到上一个版本：$ git reset HEAD^\r\n回退a.py这个文件的版本到上一个版本：$ git reset HEAD^ a.py\r\n回退到某个版本：$ git reset 057d\r\n将本地的状态回退到和远程的一样：$ git reset –hard origin/master\r\n向前回退到第3个版本：$ git reset –soft HEAD~3\r\n修改最后的提交日志：$ git commit --amend\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(79,'PHP生成随机密码的4种方法及性能对比','79',1434979680,1434979878,'<!--markdown-->使用PHP开发应用程序，尤其是网站程序，常常需要生成随机密码，如用户注册生成随机密码，用户重置密码也需要生成一个随机的密码。随机密码也就是一串固定长度的字符串，这里我收集整理了几种生成随机字符串的方法，以供大家参考。\r\n\r\n\r\n<!--more-->\r\n\r\n### 方法一：\r\n1、在 33 – 126 中生成一个随机整数，如 35，\r\n2、将 35 转换成对应的ASCII码字符，如 35 对应 #\r\n3、重复以上 1、2 步骤 n 次，连接成 n 位的密码\r\n该算法主要用到了两个函数，mt_rand ( int $min , int $max )函数用于生成随机整数，其中 $min – $max 为 ASCII 码的范围，这里取 33 -126 ，可以根据需要调整范围，如ASCII码表中 97 – 122 位对应 a – z 的英文字母，具体可参考 ASCII码表； chr ( int $ascii )函数用于将对应整数 $ascii 转换成对应的字符。\r\n```\r\nfunction create_password($pw_length = 8)\r\n{\r\n    $randpwd = \'\';\r\n    for ($i = 0; $i < $pw_length; $i++) \r\n    {\r\n        $randpwd .= chr(mt_rand(33, 126));\r\n    }\r\n    return $randpwd;\r\n}\r\n\r\n// 调用该函数，传递长度参数$pw_length = 6\r\necho create_password(6);\r\n```\r\n\r\n### 方法二：\r\n1、预置一个的字符串 $chars ，包括 a – z，A – Z，0 – 9，以及一些特殊字符\r\n2、在 $chars 字符串中随机取一个字符\r\n3、重复第二步 n 次，可得长度为 n 的密码\r\n```\r\nfunction generate_password( $length = 8 ) {\r\n    // 密码字符集，可任意添加你需要的字符\r\n    $chars = \'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_ []{}<>~`+=,.;:/?|\';\r\n\r\n    $password = \'\';\r\n    for ( $i = 0; $i < $length; $i++ ) \r\n    {\r\n        // 这里提供两种字符获取方式\r\n        // 第一种是使用 substr 截取$chars中的任意一位字符；\r\n        // 第二种是取字符数组 $chars 的任意元素\r\n        // $password .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\r\n        $password .= $chars[ mt_rand(0, strlen($chars) - 1) ];\r\n    }\r\n\r\n    return $password;\r\n}\r\n```\r\n\r\n### 方法三：\r\n1、预置一个的字符数组 $chars ，包括 a – z，A – Z，0 – 9，以及一些特殊字符\r\n2、通过array_rand()从数组 $chars 中随机选出 $length 个元素\r\n3、根据已获取的键名数组 $keys，从数组 $chars 取出字符拼接字符串。该方法的缺点是相同的字符不会重复取。\r\n```\r\nfunction make_password( $length = 8 )\r\n{\r\n    // 密码字符集，可任意添加你需要的字符\r\n    $chars = array(\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \r\n    \'i\', \'j\', \'k\', \'l\',\'m\', \'n\', \'o\', \'p\', \'q\', \'r\', \'s\', \r\n    \'t\', \'u\', \'v\', \'w\', \'x\', \'y\',\'z\', \'A\', \'B\', \'C\', \'D\', \r\n    \'E\', \'F\', \'G\', \'H\', \'I\', \'J\', \'K\', \'L\',\'M\', \'N\', \'O\', \r\n    \'P\', \'Q\', \'R\', \'S\', \'T\', \'U\', \'V\', \'W\', \'X\', \'Y\',\'Z\', \r\n    \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'!\', \r\n    \'@\',\'#\', \'$\', \'%\', \'^\', \'&\', \'*\', \'(\', \')\', \'-\', \'_\', \r\n    \'[\', \']\', \'{\', \'}\', \'<\', \'>\', \'~\', \'`\', \'+\', \'=\', \',\', \r\n    \'.\', \';\', \':\', \'/\', \'?\', \'|\');\r\n\r\n    // 在 $chars 中随机取 $length 个数组元素键名\r\n    $keys = array_rand($chars, $length); \r\n\r\n    $password = \'\';\r\n    for($i = 0; $i < $length; $i++)\r\n    {\r\n        // 将 $length 个数组元素连接成字符串\r\n        $password .= $chars[$keys[$i]];\r\n    }\r\n\r\n    return $password;\r\n}\r\n```\r\n\r\n### 方法四：\r\n根据md5()函数的返回值生成的密码只包括字母和数字，不过也算是一个不错的方法。算法思想：\r\n1、time() 获取当前的 Unix 时间戳\r\n2、将第一步获取的时间戳进行 md5() 加密\r\n3、将第二步加密的结果，截取 n 位即得想要的密码\r\n```\r\nfunction get_password( $length = 8 ) \r\n{\r\n    $str = substr(md5(time()), 0, 6);\r\n    return $str;\r\n}\r\n```\r\n\r\n### 时间效率对比\r\n我们使用以下PHP代码，计算上面的 4 个随机密码生成函数生成 6 位密码的运行时间，进而对他们的时间效率进行一个简单的对比。\r\n```\r\n<?php\r\nfunction getmicrotime()\r\n{\r\n    list($usec, $sec) = explode(\" \",microtime());\r\n    return ((float)$usec + (float)$sec);\r\n}\r\n\r\n// 记录开始时间\r\n$time_start = getmicrotime();\r\n\r\n// 这里放要执行的PHP代码，如:\r\n// echo create_password(6);\r\n\r\n// 记录结束时间\r\n$time_end = getmicrotime();\r\n$time = $time_end - $time_start;\r\n\r\n // 输出运行总时间 \r\necho \"执行时间 $time seconds\";\r\n?>\r\n```\r\n最终得出的结果是：\r\n方法一：9.8943710327148E-5 秒\r\n方法二：9.6797943115234E-5 秒\r\n方法三：0.00017499923706055 秒\r\n方法四：3.4093856811523E-5 秒\r\n可以看出方法一和方法二的执行时间都差不多，方法四运行时间最短，而方法三的运行时间稍微长点。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(80,'PHP 判断数组是否为空的5大方法','80',1434980156,1434980156,'<!--markdown-->本文介绍了PHP开发中遇到的数组问题，这里介绍了判断PHP数组为空的5种方法，有需要的朋友可以借鉴参考一下。\r\n\r\n\r\n<!--more-->\r\n\r\n### 1. isset功能：判断变量是否被初始化\r\n说明：它并不会判断变量是否为空，并且可以用来判断数组中元素是否被定义过\r\n注意：当使用isset来判断数组元素是否被初始化过时，它的效率比array_key_exists高4倍左右\r\n```\r\n<?php\r\n$a = \'\';\r\n$a[\'c\'] = \'\';\r\nif (!isset($a)) echo \'$a 未被初始化\' . \"\";\r\nif (!isset($b)) echo \'$b 未被初始化\' . \"\";\r\nif (isset($a[\'c\'])) echo \'$a 已经被初始化\' . \"\";\r\n// 显示结果为\r\n// $b 未被初始化\r\n// $a 已经被初始化\r\n\r\n```\r\n\r\n### 2. empty功能：检测变量是否为”空”\r\n说明：任何一个未初始化的变量、值为 0 或 false 或 空字符串”” 或 null的变量、空数组、没有任何属性的对象，都将判断为empty==true\r\n注意1：未初始化的变量也能被empty检测为”空”\r\n注意2：empty只能检测变量，而不能检测语句\r\n```\r\n<?php\r\n$a = 0;\r\n$b = \'\';\r\n$c = array();\r\nif (empty($a)) echo \'$a 为空\' . \"\";\r\nif (empty($b)) echo \'$b 为空\' . \"\";\r\nif (empty($c)) echo \'$c 为空\' . \"\";\r\nif (empty($d)) echo \'$d 为空\' . \"\";\r\n```\r\n\r\n### var == null功能：判断变量是否为”空”\r\n说明：值为 0 或 false 或 空字符串”” 或 null的变量、空数组、都将判断为 null\r\n注意：与empty的显著不同就是：变量未初始化时 var == null 将会报错。\r\n```\r\n<?php\r\n$a = 0;\r\n$b = array();\r\nif ($a == null) echo \'$a 为空\' . \"\";\r\nif ($b == null) echo \'$b 为空\' . \"\";\r\nif ($c == null) echo \'$b 为空\' . \"\";\r\n// 显示结果为\r\n// $a 为空\r\n// $b 为空\r\n// Undefined variable: c\r\n```\r\n\r\n4. is_null功能：检测变量是否为”null”\r\n说明：当变量被赋值为”null”时，检测结果为true\r\n注意1：null不区分大小写：$a = null; $a = NULL 没有任何区别\r\n注意2：仅在变量的值为”null”时，检测结果才为true，0、空字符串、false、空数组都检测为false\r\n注意3：变量未初始化时，程序将会报错\r\n```\r\n<?php\r\n$a = null;\r\n$b = false;\r\nif (is_null($a)) echo \'$a 为NULL\' . \"\";\r\nif (is_null($b)) echo \'$b 为NULL\' . \"\";\r\nif (is_null($c)) echo \'$c 为NULL\' . \"\";\r\n// 显示结果为\r\n// $a 为NULL\r\n// Undefined variable: c\r\n```\r\n\r\n### 5. var === null功能：检测变量是否为”null”，同时变量的类型也必须是”null”\r\n\r\n说明：当变量被赋值为”null”时，同时变量的类型也是”null”时，检测结果为true\r\n注意1：在判断为”null”上，全等于和is_null的作用相同\r\n注意2：变量未初始化时，程序将会报错\r\n\r\n### 总结：\r\nPHP中，”NULL” 和 “空” 是2个概念。\r\nisset 主要用来判断变量是否被初始化过\r\nempty 可以将值为 “假”、”空”、”0″、”NULL”、”未初始化” 的变量都判断为TRUE\r\nis_null 仅把值为 “NULL” 的变量判断为TRUE\r\nvar == null 把值为 “假”、”空”、”0″、”NULL” 的变量都判断为TRUE\r\nvar === null 仅把值为 “NULL” 的变量判断为TRUE\r\n注意：在判断一个变量是否真正为”NULL”时，大多使用 is_null，从而避免”false”、”0″等值的干扰。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(81,'解析PHP中ob_start()函数的用法','81',1434981820,1434981820,'<!--markdown-->ob_start()函数用于打开缓冲区,比如header()函数之前如果就有输出,包括回车/空格/换行/都会有\"Header had all ready send by\"的错误,这时可以先用ob_start()打开缓冲区PHP代码的数据块和echo()输出都会进入缓冲区而不会立刻输出.当然打开缓冲区的作用很多,只要发挥你的想象.可以总结以下四点:\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n### 1.用于header()之前\r\n```\r\nob_start(); //打开缓冲区 \r\necho /\"Hellon/\"; //输出 \r\nheader(\"location:index.php\"); //把浏览器重定向到index.php \r\nob_end_flush();//输出全部内容到浏览器 \r\n\r\n```\r\n\r\n### 2.phpinfo()函数可获取客户端和服务器端的信息,但要保存客户端信息用缓冲区的方法是最好的选择.\r\n```\r\nob_start(); //打开缓冲区 \r\nphpinfo(); //使用phpinfo函数 \r\n$info=ob_get_contents(); //得到缓冲区的内容并且赋值给$info \r\n$file=fopen(/\'info.txt/\',/\'w/\'); //打开文件info.txt \r\nfwrite($file,$info); //写入信息到info.txt \r\nfclose($file); //关闭文件info.txt \r\n```\r\n\r\n### 3.静态页面技术\r\n```\r\nob_start();//打开缓冲区 \r\n?> \r\nphp页面的全部输出 \r\n$content = ob_get_contents();//取得php页面输出的全部内容 \r\n$fp = fopen(\"output00001.html\", \"w\"); //创建一个文件，并打开，准备写入 \r\nfwrite($fp, $content); //把php页面的内容全部写入output00001.html，然后…… \r\nfclose($fp); \r\n?>\r\n```\r\n\r\n### 4.输出代码\r\n```\r\nfunction run_code($code) { \r\n    if($code) { \r\n        ob_start(); \r\n            eval($code); \r\n            $contents = ob_get_contents(); \r\n            ob_end_clean(); \r\n        }else { \r\n            echo \"错误！没有输出\"; \r\n            exit(); \r\n        } \r\n    return $contents; \r\n}\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(82,'linux查找大文件，清理内存，mysql-bin-log清理','82',1435197600,1435197627,'<!--markdown-->### 清理内存\r\n在清理前内存使用情况\r\nfree -m\r\n用以下命令清理内存\r\necho 1 > /proc/sys/vm/drop_caches\r\n清理后内存使用情况再用以下命令看看。\r\nfree -m\r\n多出很多内存了吧。\r\n\r\n查看内存条数命令：\r\ndmidecode |grep -A16 \"Memory Device$\"\r\n\r\n\r\n### 查找清理磁盘大文件方法  \r\n查找大于100M的大文件，\r\nfind / -size +100M -exec ls -lh {} \\;\r\nfind / -size +1G -exec ls -lh {} \\;\r\nfind / -name *~ -print -exec rm -rf {} \\;\r\n\r\n优化清理垃圾文件防止inode被占满\r\n\r\n使用 Linux 命令删除垃圾文件\r\nhttp://www.ibm.com/developerworks/cn/linux/1310_caoyq_linuxdelete/\r\n\r\n删除用户后遗留下的垃圾文件\r\nfind ./ -nouser  |xargs rm –rf\r\n\r\ncore 文件\r\nfind / -name core -print -exec rm -rf {} \\;\r\n\r\n多余的手册页\r\n\r\ncd /usr/share/man\r\nfind ./ -maxdepth 1 -type d | tail -n +2 | grep -E -v \'(en|zh|man).*\' | \\\r\nwhile read d; do rm -rf $d; done\r\n\r\n1.清除缓存目录(/var/cache/yum)下的软件包\r\n命令：yum clean packages\r\n\r\n2.清除缓存目录(/var/cache/yum)下的 headers\r\n命令：yum clean headers\r\n\r\n3.清除缓存目录(/var/cache/yum)下旧的 headers\r\n命令：yum clean oldheaders\r\n\r\n4.清除缓存目录(/var/cache/yum)下的软件包及旧的headers\r\n命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders)\r\n\r\n\r\n\r\n### Mysql log-bin start\r\n1    清除mysql的log-bin日志\r\n\r\n作用\r\n1、数据恢复\r\n\r\n如果你的数据库出问题了，而你之前有过备份，那么可以看日志文件，找出是哪个命令导致你的数据库出问题了，想办法挽回损失。\r\n2、主从服务器之间同步数据\r\n主服务器上所有的操作都在记录日志中，从服务器可以根据该日志来进行，以确保两个同步。\r\n\r\n解决\r\n/usr/local/mysql/bin/mysql -u root -p\r\nreset master;\r\n\r\n/etc/my.cnf\r\n\r\n#log-bin=mysql-bin\r\n#binlog_format=mixed\r\n\r\n这两行注释掉，然后将mysql下的var目录中的这些日志文件全部删除，重启mysql服务即可。\r\n\r\n3但是如果你设置了主从服务器，那么就需要做以下操作了。\r\n\r\nA：在每个从属服务器上，使用SHOW SLAVE STATUS来检查它正在读取哪个日志。\r\n\r\nB：使用SHOW MASTER LOGS获得主服务器上的一系列日志。\r\n\r\nC：在所有的从属服务器中判定最早的日志，这个是目标日志，如果所有的从属服务器是更新的，就是清单上的最后一个日志。\r\n\r\nD：清理所有的日志，但是不包括目标日志，因为从服务器还要跟它同步。 简单地说,这些MySQL目录下的形如mysql-bin.000***的文件时MySQL的事务日志。 删除复制服务器已经拿走的binlog是安全的，一般来说网络状况好的时候，保留最新的那一个足以。\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(83,'gdb调试C开发,php扩展开发','83',1438173060,1438180033,'<!--markdown-->最近在开发php扩展，发现调试C语言的利器，gdb,这个是神器。废话不多说，先来个介绍。\r\ngdb是[the GNU Debugger][1]的简称。它是一款UNIX平台的调试器(debugger)，可用于为C, C++, Objective-C, Java, Fortran等程序debug。\r\n\r\n在gdb中，你可以通过设置断点(break point)来控制程序运行的进度，并查看断点时的变量和函数调用状况，从而发现可能的问题。\r\n\r\n这里主要介绍gdb的命令行使用，并以linux(centos)系 C程序为例。\r\nwindows略过,**mac osx**主要是 lldb命令\r\n\r\n<!--more-->\r\n\r\n### 相关环境\r\n#### 1.系统环境\r\n```\r\nLinux  2.6.32-504.8.1.el6.x86_64 #1 SMP Wed Jan 28 21:11:36 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\r\n```\r\n不同的环境，gcc，gdb编译结果可能不同，要注意下。\r\n\r\n#### 2.安装gdb\r\n默认情况下,系统一般自带可用gdb -v查看\r\n```\r\ngdb -v\r\nGNU gdb (GDB) Red Hat Enterprise Linux (7.2-75.el6)\r\nCopyright (C) 2010 Free Software Foundation, Inc.\r\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\r\nThis is free software: you are free to change and redistribute it.\r\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\r\nand \"show warranty\" for details.\r\nThis GDB was configured as \"x86_64-redhat-linux-gnu\".\r\nFor bug reporting instructions, please see:\r\n<http://www.gnu.org/software/gdb/bugs/>.\r\n```    \r\n没有的话，可以去[官方][2]下载编译安装，中间缺少什么补什么\r\n```\r\ntar -zxvf gdb-6.5-tar-bz2\r\ncd  gdb-6.5\r\n./configure --target=arm-linux --prefix=/usr/local/arm-gdb –v\r\nmake\r\nmake install\r\n``` \r\n\r\n\r\n### gdb调试\r\nc程序1.c\r\n```\r\n#include <stdio.h>\r\nint main()\r\n{\r\n  int i = 9999;\r\n  return 0;\r\n}\r\n```\r\n编译 **加-g参数**\r\n```\r\ngcc -g 1.c -o 1.out\r\n```\r\n进入gdb调试查看，当然也可以先执行看下\r\n```\r\ngdb 1.out\r\n```\r\n界面如下\r\n![list.png][3]\r\n\r\n### 讲解命令\r\n#### 1.查看代码list(l), 进入程序内部start或run， 打印变量 print(p)\r\n     ,查看变量类型 ptype, 下一步next(n)或回车，退出q, y\r\nlist命令\r\n![list2.png][4]\r\nstart命令\r\n![start1.png][5]\r\n这时打印p i\r\n```\r\n$1 = 0\r\n```\r\n为何是0，说明还没有执行到这步。继续执行n，打印p i\r\n```\r\n$1 = 999\r\n```\r\n这个和 $i++,++$a好点像\r\n查看变量类型ptype i\r\n```\r\nptype i\r\ntype = int\r\n```\r\n是int类型，这和声明是相同的，查看变量地址p &i\r\n```\r\n(gdb) p &i\r\n$3 = (int *) 0x7fffffffe53c\r\n```\r\n\r\n#### 断点操作 break,info\r\n断点两种方法 break 函数名(break main), break 行数(break 10)\r\n查看断点 info break\r\n继续执行 continue （简写c ）： 到下一个断点处（或运行结束）\r\n删除断点 delete 1\r\n运行程序 run(r), 作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令\r\n进入函数运行 step(s), 单步调试如果有函数调用，则进入函数, n不能\r\n\r\n\r\n改下C程序\r\n```\r\n#include <stdio.h>\r\nint main()\r\n{\r\n  int i = 9999;\r\n  char *str  = \"aaaabbbbcc\";\r\n  double a = 99.00;\r\n  return 0;\r\n}\r\n```\r\n打断点及查看 \r\n```\r\n(gdb) break main\r\nBreakpoint 1 at 0x400478: file 1.c, line 5.\r\n(gdb) break 7\r\nBreakpoint 2 at 0x400487: file 1.c, line 7.\r\n(gdb) info break\r\nNum     Type           Disp Enb Address            What\r\n1       breakpoint     keep y   0x0000000000400478 in main at 1.c:5\r\n2       breakpoint     keep y   0x0000000000400487 in main at 1.c:7\r\n```\r\n运行start开始\r\n```\r\n(gdb) start\r\nTemporary breakpoint 3 at 0x400478: file 1.c, line 5.\r\nStarting program: /opt/zzw/c/gdb/1.out \r\n\r\nBreakpoint 1, main () at 1.c:5\r\n5         int i = 9999;\r\n```\r\n可以看在 brakpoint 1断点处停了, C跳到下一个断点，可以打印相关的变量信息\r\n```\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, main () at 1.c:7\r\n7         double a = 99.00;\r\n```\r\n其他命令自己可以尝试下\r\n\r\n#### 查看堆栈信息\r\n修改C程序，增加函数, 函数之间的调试\r\nwhere/bt ：当前运行的堆栈列表；\r\nbt backtrace 显示当前调用堆栈\r\ninfo program： 来查看程序的是否在运行，进程号，被暂停的原因。\r\nshow args：查看设置好的参数\r\nuntil：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。\r\nfinish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。\r\n切换函数 f 0/1\r\n\r\n```\r\n#include <stdio.h>\r\n\r\nint func(int n) {\r\n  int sum = 0;\r\n  int i = 0;\r\n  for ( i=0; i<n; i++ ) {\r\n    sum += i;\r\n  }\r\n  return sum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n  int i = 0;\r\n  char *str  = \"aaaabbbbcc\";\r\n  double a = 99.00;\r\n\r\n  int sum2 = 0;\r\n  for ( i=0; i<= 100; i++) {\r\n    sum2 += i;\r\n  }\r\n  printf(\"1+...+100 sum is %d\\n\", sum2);\r\n\r\n  int sum = 0;\r\n  sum = func(10);\r\n  printf(\"sum is %d\\n\", sum);\r\n\r\n  return 0;\r\n}\r\n\r\n```\r\n查看函数\r\n```\r\n(gdb) bt \r\n#0  func (n=10) at 1.c:4\r\n#1  0x0000000000400566 in main () at 1.c:26\r\n```\r\n可以 f 0 或 f 1来切换函数跳转，在函数内可利用 finish结束\r\n```\r\n(gdb) finish\r\nRun till exit from #0  func (n=10) at 1.c:6\r\n0x0000000000400566 in main () at 1.c:26\r\n26        sum = func(10);\r\nValue returned is $17 = 45\r\n```\r\n\r\n### 用x命令查看内存\r\n\r\n变量在c内存标签连续块。一个变量的内存块是由两个数字来决定的——块的第一个byte的地址和块的大小（以bytes为单位）。变量的大小是由变量的类型决定的。\r\n```\r\n(gdb) p i\r\n$1 = 0\r\n(gdb) p &i\r\n$2 = (int *) 0x7fffffffe524\r\n(gdb) p sizeof(i)\r\n$3 = 4\r\n```\r\n总而言之，i的内存块开始于0x7fff5fbff5b4，占用4个字节。我上面提到过一个变量的大小是由变量类型决定的。其实sizeof 操作可以直接作用在类型上：\r\nX命令测量内存开始与一个特定的地址。它配备了一些格式化命令，提供精确的控制来实现你想检查多少字节，以及如何你想将它们打印出来\r\n```\r\n(gdb) x/4xb &i\r\n0x7fffffffe524: 0x00    0x00    0x00    0x00\r\n```\r\n是16进制的，0x00表示0\r\n\r\n具体的格式是这样\r\n格式: x /nfu <addr>\r\nn表示要显示的内存单元的个数  就是上面的4\r\nf表示显示方式, 可取如下值\r\n    x 按十六进制格式显示变量。\r\n    d 按十进制格式显示变量。\r\n    u 按十进制格式显示无符号整型。\r\n    o 按八进制格式显示变量。\r\n    t 按二进制格式显示变量。\r\n    a 按十六进制格式显示变量。\r\n    i 指令地址格式\r\n    c 按字符格式显示变量。\r\n    f 按浮点数格式显示变量。\r\n\r\nu表示一个地址单元的长度\r\n    b表示单字节，\r\n    h表示双字节，\r\n    w表示四字节，\r\n    g表示八字节\r\n\r\n\r\nx/3uh buf\r\n表示从内存地址buf读取内容，\r\nh表示以双字节为一个单位，\r\n3表示三个单位，\r\nu表示按十进制显示\r\n\r\n### 总结\r\ngdb用来学习C指针还是相当不错的工具，开发php扩展时，可以使用 如下格式 \r\ngdb <program> <PID>\r\ngdb hello 11127\r\n\r\ngdb php-fpm 80\r\n然后php扩展程序\r\n这样可以高性能的程序进了一步。\r\n\r\n有兴趣可以加趣 139731083\r\n\r\n\r\n  [1]: http://www.gnu.org/software/gdb/\r\n  [2]: http://www.gnu.org/software/gdb/\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/07/4227398663.png\r\n  [4]: http://blog.chromev.com/usr/uploads/2015/07/2307966149.png\r\n  [5]: http://blog.chromev.com/usr/uploads/2015/07/2241683535.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(84,'list.png','list-png',1438174919,1438174919,'a:5:{s:4:\"name\";s:8:\"list.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/07/4227398663.png\";s:4:\"size\";i:22212;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',83),(85,'list2.png','list2-png',1438175298,1438175298,'a:5:{s:4:\"name\";s:9:\"list2.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/07/2307966149.png\";s:4:\"size\";i:4613;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',83),(87,'start1.png','start1-png',1438175469,1438175469,'a:5:{s:4:\"name\";s:10:\"start1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/07/2241683535.png\";s:4:\"size\";i:7104;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',83),(88,'centos7安装samba服务器,mac os挂载samba硬盘','88',1438507080,1438509969,'<!--markdown-->mac os 底下开发一些程序还是需要用到linux，那就需要在linux底下samba服务器，mac os来挂载\r\n\r\n\r\n<!--more-->\r\n\r\n### 检查是否已经安装\r\n```\r\nrpm -qa | grep samba \r\n```\r\n如果有的话，清理下， 命令格式如下\r\n```\r\nrpm -e samba-comm -f --nodeps\r\n```\r\n\r\n### 全新安装\r\n```\r\nyum install samba samba-client samba-common -y\r\n#检查安装\r\nrpm -qa | grep samba\r\n```\r\n\r\n### 启用服务\r\n这个centos6.5有些区别的\r\n```\r\nsystemctl enable smb\r\nsystemctl enable nmb\r\nsystemctl restart smb\r\nsystemctl restart nmb\r\n#查看\r\nnetstat -nltup\r\n```\r\n\r\n### 设置配置文件 \r\n```\r\nvim /etc/samba/smb.conf\r\n\r\n[global]\r\nworkgroup = MYGROUP\r\nserver string = Samba Server %v\r\nnetbios name = centos_7\r\nsecurity = user\r\nmap to guest = bad user\r\ndns proxy = no\r\n \r\n[Secure]\r\npath = /home/share_dir\r\nvalid users = @smbgrp\r\nguest ok = no\r\nwritable = yes\r\nbrowsable = yes\r\n\r\n[homes]\r\ncomment = Home Directories\r\nbrowseable = no\r\nwritable = yes\r\nvalid users = %S\r\n; valid users = MYDOMAIN\\%S\r\n```\r\n\r\n### mac os 挂载 samba服务\r\n这里只说一个/home/users的配置\r\n\r\n打开 Finder。Finder 程序一般位于 Dock 上。按下 Command+K 打开连接到服务器窗口\r\n![QQ20150802-1@2x.png][1]\r\n连接成功后\r\n![QQ20150802-1@2x.png][2]\r\n\r\n\r\n\r\n\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/08/1093675603.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/08/3199491238.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(89,'QQ20150802-1@2x.png','QQ20150802-1-2x-png',1438509042,1438509042,'a:5:{s:4:\"name\";s:19:\"QQ20150802-1@2x.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/08/1093675603.png\";s:4:\"size\";i:118648;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',88),(90,'QQ20150802-1@2x.png','QQ20150802-1-2x-png-1',1438509161,1438509161,'a:5:{s:4:\"name\";s:19:\"QQ20150802-1@2x.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/08/3199491238.png\";s:4:\"size\";i:133867;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',88),(91,'日记','91',1440635520,1450078213,'<!--markdown--># 12.14\r\n上个星期五发生的吃药吃多的情况，唉，太伤\r\n现在我的腰也有问题，不该玩game,对我太伤了，再玩下去，你就废了\r\n\r\n现在全心做 sf1的电商网站，努力吧，不要想别的了\r\n\r\n# 12.07\r\n11.31做的手术，到现在没好，有点心累，身体也有点累了，\r\n不知道什么能好，不知道还要不要流血了，真的是不知如何\r\n应该每天做 俯卧撑 20个，坚持吧\r\n\r\n# 11.04\r\n你之所以即使疲劳了，也不肯睡觉，是因为你没有勇气结束这一天，也没有勇气迎接新的一天。\r\n\r\n10.30号做了一个手术，痛苦的几天时间，唉\r\n现在多运动吧，\r\n好好努力工作\r\n\r\n# 9.23\r\n早上没起来\r\n肠道又不怎么好了，被子好像没盖好\r\n\r\n### 9.8\r\n最近一直都睡不好，要改变，9.8, 改变自己的作息。改变自己的生命。\r\n6点起床，11点睡觉\r\n\r\n# 9.22\r\n竞争越来越激烈，真的应该努力了\r\n首页游戏这个东西是应该戒了\r\n其次身体，应该规律化 11点睡觉，6点起床\r\n再次，电视剧电影这些就不要再看了\r\n\r\n# 8.27\r\n右手从 8.15到现在一直比较痛，不能打字，现在好点了，照顾好自己\r\n老婆昨天发烧了，今天去社区医院掉水\r\n每天记下日记',4,1,NULL,'page','hidden',NULL,0,'0','0','0',0),(92,'1.png','1-png-1',1441174867,1441174867,'a:5:{s:4:\"name\";s:5:\"1.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/09/1395966703.png\";s:4:\"size\";i:63447;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',94),(93,'2.png','2-png-1',1441174887,1441174887,'a:5:{s:4:\"name\";s:5:\"2.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/09/1321649875.png\";s:4:\"size\";i:72480;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',94),(94,'为什么有些人工作是痛苦的？','94',1441174860,1441175193,'<!--markdown-->![1.png][1]\r\n\r\n身边一个朋友，每天工作内容多但是都不复杂，但都是些特别容易出错的东西，所以每天兢兢战战，做不好又要被领导批评，这种恶性循环导致每天心神不宁，感觉工作是痛苦的，\r\n\r\n实在不忍心看到朋友这种焦虑的状态，我们聊了很久总结了以下原因，晒出来，也希望帮助更多的朋友每天工作顺利。\r\n\r\n \r\n\r\n### 一、工作是生活的一部分\r\n\r\n我曾经说过，工作中是不会带入情绪的，也不能影响到工作之外的生活的；我现在觉着这样是不妥的，因为除了睡觉，每天花时间最多的事就是工作，工作成绩的好坏的确会影响到生活质量的。那么我们必须正视这个问题，把工作当做生活的一部分，每个人对待生活都是充满积极、乐观等正能量的，那么我们对待工作应该也是这样。\r\n\r\n把工作当做事业\r\n\r\n当你把眼下的工作当做自己终身的事业的时候，你的态度是不一样的，那么态度决定看问题的高度，解决问题的方法自然也是最优的，当优秀成为一种习惯时，走到哪里都是成功人士，请把工作当做你的事业\r\n\r\n \r\n\r\n### 二、自信应该来自何方\r\n\r\n每天怕做错事，做错事被领导批评，导致精神更加紧张，外加一点莫须有的自卑感，那么自卑是因为不自信，为什么不自信呢？\r\n\r\n在人的前18年，也就是未成年阶段，中国的特色教育是得到奖状你就有自信，得到表扬你就有自信，那么等你读完大学走入社会中，不是所有的公司屑于和善于激励员工的，那么这个时候，大批的人就陷入了自卑的泥潭，觉着每件事都做不好。这个时候，父母和老师都没有教导你，我们的自信应该来自哪里\r\n\r\n首先自信是一种态度，这种态度就是我们相信我们能够把一件事做好，这种态度包含以下几个元素：\r\n\r\n#### 1、坚持不懈的行动\r\n\r\n对任何一件事情，只要坚持10000个小时，都会由量变到质变，坚持并不断总结着向前走，永远不要踏步不前，那样只会成为空想的大师，行动的矮子！\r\n\r\n \r\n\r\n#### 2、对自己应该正直、勇敢、独立的信仰\r\n\r\n优秀的人是有共性的，那就是永远正直、勇敢和独立的，坚持这份信仰，你就会成为优秀的人。\r\n\r\n \r\n\r\n### 三、国人的惰性\r\n\r\n中国人民，多数是无志之人常立志，每年逢年过节都要立下一大堆志向，但决定做的事情又永远拖拖拉拉，这是和社会风气有关，在当今社会这种恶习俨然是一种会把人埋没的万恶习俗。\r\n\r\n#### 1、勤奋每个人应有的习惯\r\n\r\n马云夜里2点还在不停的会客，你敢说你有他优秀吗？勤奋是一种习惯，习惯是一种很可怕的东西。\r\n\r\n你养成了每天读书的习惯，一年就会比同龄人上在知识层次上一个台阶，一生下来，你退休做个教授也绰绰有余；\r\n\r\n你养成了每天打游戏和乱用社交的习惯，在虚拟世界中每天远离真实的人，真实的社会，你就会慢慢与社会脱轨；\r\n\r\n不再做多余的对比，养成尽可能多得优秀的习惯，你就会节节高。\r\n\r\n#### 2、别把自己当回事\r\n\r\n首先在我进入这家公司之前，我一直觉得是一个很聪明的人，我可以六级750满分考650，我可以半年成为一个最优秀的讲师；但是当我看到年薪200万的同事还在彻夜工作，我心底的价值观还是震动了的。\r\n\r\n这个世界永远有比你优秀的人在你偷懒休息的时候，勤奋着做着每件你看不到的事儿，这就是真实的社会。放下身姿，把自己当做笨鸟往前不停的飞，飞久了成为了一种习惯，也就习惯了。\r\n\r\n \r\n\r\n老师说写作文要紧扣主题，为什么有些人工作是痛苦的？是因为你将工作仅仅是当做工作，因为你对自信的理解是错误的，因为你不够勤快。\r\n\r\n最后一句：成功不会自燃，必须自己点火\r\n![2.png][2]\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/09/1395966703.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/09/1321649875.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(95,'centos初始化所有环境','95',1441499280,1441508212,'<!--markdown-->### centos 虚拟机安装\r\n#### 分区\r\n    \r\n#### 网络配置 192.168.148.1\r\n      \r\n#### sshd\r\n\r\n#### git服务器及git客户端  \r\n    #### git 提交检察\r\n\r\n#### samba服务器安装 \r\n##### win 客户端, 电脑-映射管理器\r\n##### mac 客户端，finder-> command+k -> IP\r\n\r\n### 初始化环境 及 mysql-nginx-php-ftp 安装\r\n    #### php扩展标准 \r\n\r\n### memcached, mongod, redis服务器端安装\r\n    \r\n  #### php扩展添加\r\n    \r\n### amqb队列，sphinx, varnish服务端\r\n\r\n #### php扩展添加\r\n\r\n### solr(apache,分词,mysql) 搜索服务\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(97,'sphinx,coreseek 分词及实时索引','97',1441531994,1441531994,'<!--markdown-->sphinx,coreseek 分词及实时索引',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(98,'php 面向对象','98',1445559720,1445559855,'<!--markdown-->### 继承\r\n### 多态\r\n### 面向接口',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(99,'技术晨读','morningreading',1445993460,1446080472,'<!--markdown-->### 10.29\r\n[你真的会玩SQL吗？之逻辑查询处理阶段][1]\r\n[http://www.cnblogs.com/zhangs1986/p/4914125.html][2]\r\n\r\n### 10.28\r\n#技术晨读#\r\n浏览器HTTP缓存原理分析\r\nhttp://www.cnblogs.com/tzyy/p/4908165.html\r\n\r\n### 10.27\r\n#技术晨读#\r\nHTTP/2 头部压缩技术介绍\r\n客户端和服务端共同维护一份动态字典达到HTTP/2头部压缩的目的\r\nhttps://imququ.com/post/header-compression-in-http2.html\r\n\r\n\r\n  [1]: http://www.cnblogs.com/zhangs1986/p/4914125.html\r\n  [2]: http://www.cnblogs.com/zhangs1986/p/4914125.html',3,1,NULL,'page','publish',NULL,0,'1','1','1',0),(101,'php.png','php-png',1449460093,1449460093,'a:5:{s:4:\"name\";s:7:\"php.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/4013603071.png\";s:4:\"size\";i:275052;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',102),(102,'php 生命周期','102',1449460080,1449460243,'<!--markdown-->php 图解内核执行过程\r\n\r\n\r\n\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n![php.png][1]\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/12/4013603071.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(103,'程序员应该做开源项目的6个原因(转载)','103',1449535920,1449535979,'<!--markdown-->“开源开发人员都是义务劳动者”的观点已经成为编程世界中的陈词滥调，即使是那些伟大的开源举措也无法驳倒这种风靡一时的心态。\r\n\r\n　　但是真理总是掌握在少数人手里——即使是在开源惯例中，也需要参与开源的开发人员主动为其他人贡献他们的技能，一些企业（或企业集团）往往会因此雇用——并支付——这些程序员去研究特定的开源项目（如 Linux Kernel）。\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n　　除了开发人员确实可以从开源代码项目中得到薪酬这个事实外，还有 6 个理由可以说服你去做更多的开源项目——如果你是一个开发人员的话：\r\n\r\n　　**1. 学习和实践**\r\n\r\n　　还有什么能让我们一直紧密关联自己的工作领域？\r\n\r\n　　作为一个程序员，你需要不断学习编码的最新趋势，你需要不断练习以进一步磨练自己的技能。开源是助你攀登这两座高峰的阶梯。开源的确是预防我们生锈的最佳途径。\r\n\r\n　　**2. 经验和简历**\r\n\r\n　　你是一个新手开发者？那么，从开源项目中学习，并致力于开源项目是你获得经验和打造有吸引力的简历的最佳方法，它能让你争取到原本不可能的就业机会。\r\n\r\n　　在 IT 界找工作并不容易，而且如果你没有任何实战经验的话，那么情况就更糟了。但是如果当雇主看到你的简历，看到你已经参与过一些开源工作，那么可能会认为你主动积极，愿意工作，有工作经验——从而增加你被雇用的机会。\r\n\r\n　　**3. 网络和协作**\r\n\r\n　　这是开源的主要精髓——也是开源培养的精神。你需要作为团队一员和其他程序员一起工作——优化项目，寻找并修复 bug，等等。\r\n\r\n　　你可以与其他伟大的程序员联网，建立项目之外的关系。这是增加 Twitter 粉丝的好办法。开源还可以帮助你和那些志趣相投的，优质的联系人建立网络联系。\r\n\r\n　　你和你的小伙伴还可以一起工作于以后的项目，或者创建一个交流技巧的组群。各种可能数不胜数。\r\n\r\n　　**4. 展现（技能，代码等）**\r\n\r\n　　参与开源项目能让你获得大量的曝光机会——无论是技能还是工作机会。\r\n\r\n　　通过使用以前写的代码，能让你节省大量编写开源代码的时间。此外，在你贡献了自己的代码之后，其他程序员可能会紧随你的身后去扩展这些代码——你可能会发现代码变得更高级。这是一个开发和机遇无休止的循环，可能会大大影响你的职业生涯。\r\n\r\n　　**5. 社区建设**\r\n\r\n　　除了能让你获取伟大的实践和经验，开源还能帮助构建一个伟大的社区。因为它是开源的，所以大家可以互相学习彼此的技巧，提高自己的编码技能。\r\n\r\n　　教学相长。就像其他职业一样，你在教授别人的过程中，在为开源项目或社区简单地贡献自己的专业知识的同时，也可以学到东西。\r\n\r\n　　**6. 更好的收入机会**\r\n\r\n　　现在，如果我们再回过头谈谈钱，为大家揭示所谓的“自由工作”神话。真的能赚到钱的编程或许就是开源领域了。\r\n\r\n　　为什么？这是因为虽然开源软件产品大多是免费提供给公司使用的，但是公司往往还是会雇用程序员（尤其是那些对此有贡献的程序员）来提供与开源软件相关的服务——例如，安装，支持，维护，等等。\r\n\r\n　　具有讽刺意味的是：这些服务很赚钱，而且比销售类似付费软件所赚的钱更多——反而这些付费软件不需要这些相关服务。\r\n\r\n　　现在，你知道开源的好处了吧，所以每个开发人员都应该致力于开源项目。而且开源不仅对开发人员有利，对企业而言，也是好事，因为它保证了最高的安全性和质量。\r\n\r\n　　开源并不是完全免费的志愿活动。相反，从长期来看，它能让你渐渐地超越你的同龄人，它会成为一棵真正的摇钱树。\r\n\r\n　　你以前有没有参与过开源项目？你获得的经验？好处？欢迎和我们一起分享。\r\n\r\n   译文链接：http://www.codeceo.com/article/6-reasons-do-open-source.html\r\n\r\n　　翻译作者：码农网 – 小峰',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(104,'35E27C6A-2E94-40F0-95C2-020E1A9157C0.png','35E27C6A-2E94-40F0-95C2-020E1A9157C0-png',1449576888,1449576888,'a:5:{s:4:\"name\";s:40:\"35E27C6A-2E94-40F0-95C2-020E1A9157C0.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/4097305072.png\";s:4:\"size\";i:98835;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',105),(105,'iterm设置半透明','105',1449576901,1449576901,'<!--markdown-->![35E27C6A-2E94-40F0-95C2-020E1A9157C0.png][1]\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/12/4097305072.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(106,'nginx 开启gzip','setting-up-http-cache-and-gzip-with-nginx',1449624360,1449625082,'<!--markdown-->nginx 是一个高性能的 Web 服务器，为了提高网站的响应速度，可以从设置 nginx 的 gzip 和缓存这2方面入手。为js,css,图片，字体等开启 gzip 和缓存能大大减少带宽的消耗。\r\n\r\n\r\n<!--more-->\r\n\r\n### 开启gzip\r\n配置\r\n\r\n```\r\n# 开启gzip\r\ngzip on;\r\n# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\r\ngzip_min_length 1k;\r\n# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\r\ngzip_comp_level 2;\r\n# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。\r\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\r\n# 是否在http header中添加Vary: Accept-Encoding，建议开启\r\ngzip_vary on;\r\n# 禁用IE 6 gzip\r\ngzip_disable \"MSIE [1-6]\\.\";\r\n```\r\n\r\n\r\n### 开启缓存\r\n配置\r\n```\r\nlocation ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ { \r\n        access_log   off; \r\n        expires      30d;\r\n}\r\nlocation ~* ^.+\\.(css|js|txt|xml|swf|wav)$ {\r\n    access_log   off;\r\n    expires      24h;\r\n}\r\nlocation ~* ^.+\\.(html|htm)$ {\r\n        expires      1h;\r\n}\r\n```\r\n\r\n关于字体\r\n为静态资源开启缓存能够较少服务器带宽的消耗，特别是在css中使用字体时，同时配合gzip压缩能够大大减少下载字体造成的带宽影响。\r\n```\r\nlocation ~* ^.+\\.(eot|ttf|otf|woff|svg)$ {\r\n        access_log   off;\r\n        expires max;\r\n}\r\n```\r\n\r\n启用gzip\r\n\r\n只需要为 ttf、otf 和 svg 字体启用 gzip，对其他字体格式进行 gzip 压缩时效果不明显。\r\n\r\n```\r\ngzip_types  font/ttf font/otf image/svg+xml\r\n```\r\n\r\n\r\n推荐一个：[http://gtmetrix.com/][1]可以对页面访问速度进行一个打分，类似google page speed。\r\n\r\n\r\n### 用curl测试Gzip是否成功开启\r\n```\r\ncurl -I -H \"Accept-Encoding: gzip, deflate\" \"//www.slyar.com/blog/\"\r\n\r\nHTTP/1.1 200 OK\r\nServer: nginx/1.0.15\r\nDate: Sun, 26 Aug 2012 18:13:09 GMT\r\nContent-Type: text/html; charset=UTF-8\r\nConnection: keep-alive\r\nX-Powered-By: PHP/5.2.17p1\r\nX-Pingback: //www.slyar.com/blog/xmlrpc.php\r\nContent-Encoding: gzip\r\n```\r\n\r\n可以把 //www.slyar.com/blog/ 换成 css,js,图片路径 看下\r\n\r\n  [1]: http://gtmetrix.com/',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(107,'正则表达式','107',1449741984,1449741984,'<!--markdown-->正则表达式\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n```\r\n//preg_match_all(\"/\\<img.*src=[\\\"](.*?)[\\\"].*?\\>/\", $this->works->getContent(), $matches);\r\n    //$str = \'<p><img src=\"/js/plugins/ueditor/php/../../../../uploads/15/1210/5669478b6f523.jpeg\" title=\"1.jpeg\"/><img src=\"/js/plugins/ueditor/php/../../../../uploads/15/1210/56694796c084d.jpg\" title=\"3.jpg\"/></p>\';\r\n    //$this->content = $this->works->getContent();\r\n    $this->content = preg_replace(\"/src=\\\"(.*?)\\\"/U\", \'\\\\1\" width=\"100% \', $this->works->getContent());\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(108,'nginx模块','108',1449802196,1449802196,'<!--markdown-->http://my.oschina.net/u/1156660/blog/364955?fromerr=AVFlI07S',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',0),(110,'工具集','tools',1450075380,1450659475,'<!--markdown-->[http://blog.xiayf.cn/pages/tools.html][1]\r\n\r\nssh\r\n```\r\n.ssh/config\r\nHost bob\r\n    HostName bob.example.com\r\n    Port 2222\r\n    User wdaher\r\n```\r\n\r\nvim 粘贴\r\n```\r\nset nopaste\r\nset pastetoggle=<F12>\r\n```\r\n\r\ngit 配置\r\n```\r\n[color]\r\n    diff = auto\r\n    status = true\r\n    branch = auto\r\n    interactive = auto\r\n    ui = auto\r\n    log = true\r\n\r\n[alias]\r\n    co = checkout\r\n    ci = commit\r\n    st = status\r\n    pl = pull\r\n    ps = push\r\n    dt = difftool\r\n    ls = log --stat\r\n    cp = cherry-pick\r\n    ca = commit -a\r\n    br = branch\r\n\r\n```\r\n\r\n  [1]: http://blog.xiayf.cn/pages/tools.html',2,1,NULL,'page','publish',NULL,0,'1','1','1',0),(112,'Include和require,include_once,require_once的区别','include_once_require_once_diff',1450078260,1450078334,'<!--markdown-->include是包含的意思，找不到文件时，会报warning的错误，然后程序继续往下执行 \r\n\r\nrequire是必须的意思，找不到文件时，会报fatal error （致命错误），程序停止往下执行 \r\n\r\n　　加once后，系统会进行判断，如果已经包含，则不会再包含第二次 ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(113,'Linux修改SSH端口和禁止Root远程登陆','linux-modify-sshd-port-ban-root',1450662060,1450665749,'<!--markdown-->Linux修改ssh端口是22,同在来修改\r\n\r\n\r\n<!--more-->\r\n\r\n\r\nvi /etc/ssh/sshd_config \r\n\r\n然后修改为port 8888\r\n\r\n以root身份service sshd restart (redhat as3)\r\n\r\n使用putty,端口8888 \r\n\r\nLinux下SSH默认的端口是22,为了安全考虑，现修改SSH的端口为1433,修改方法如下 ：\r\n\r\n \r\n\r\n/usr/sbin/sshd -p 1433\r\n\r\n \r\n\r\n为增强安全\r\n\r\n先增加一个普通权限的用户：\r\n\r\n#useradd uploader\r\n\r\n#passwd uploader\r\n\r\n//设置密码\r\n\r\n \r\n\r\n生产机器禁止ROOT远程SSH登录：\r\n\r\n#vi /etc/ssh/sshd_config\r\n\r\n \r\n\r\n把\r\n\r\nPermitRootLogin yes\r\n\r\n改为\r\n\r\nPermitRootLogin no\r\n\r\n重启sshd服务\r\n\r\n#service sshd restart\r\n\r\n \r\n\r\n远程管理用普通用户uploader登录，然后用 su root 切换到root用户拿到最高权限',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(115,'vsftpd 修改端口','vsftpd-modify-port',1450665726,1450665726,'<!--markdown-->一、简介\r\n\r\n　　FTP支持两种模式，一种方式叫做Standard (也就是 PORT方式，主动方式)，一种是 Passive (也就是PASV，被动方式)。\r\n\r\n　　主动模式下FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令，PORT命令包含了客户端用什么端口接收数据,在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。\r\n\r\n　　被动模式（Passive）模式在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令，FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接。\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n二、配置修改过程\r\n\r\n　　1 主动模式\r\n\r\n1.编辑 /etc/vsftpd/vsftpd.conf 文件，在该配置文件中添加此行：listen_port=901\r\n\r\n2.编辑 /etc/services 文件，将其中的 ftp 21/tcp 改为\r\n\r\nftp 21/tcp\r\nftp 21/udp\r\n改成\r\nftp 901/tcp\r\nftp 901/udp\r\n\r\n\r\n\r\n3.执行 /etc/init.d/vsftpd restart 重新启动 vsftpd 服务。启动完成后可以使用 netstat -ntpl | grep vsftpd 命令可以查看到系统现监听的 vsftpd 的端口为 801\r\n\r\n4.使用 lftp 192.168.0.1:801(192.168.0.1 是 vsftpd 服务器的地址 )，这样既可以访问到 ftp 服务器了。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(116,'my.cnf常用配置','mycnf',1450668840,1450668933,'<!--markdown-->当mysql变慢进，my.cnf可以改动\r\ninnodb_buffer_pool_size，innodb_write_io_threads，innodb_read_io_threads，innodb_log_file_size，table_cache\r\n\r\n这里要通过监控 看 进程是查询的多还是 更新写的多，分别来调整innodb_write_io_threads，innodb_read_io_threads\r\n我最高把这两个设置到12，设置完reload，排队的sql进程 很快就由query变成sleep\r\n\r\n综合了linux服务器资源使用情况\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n```\r\n[mysqld]\r\nbasedir=/usr/local/mysql\r\nuser=mysql\r\nsocket=/var/run/mysqld/mysqld.sock\r\n\r\nserver_id=1\r\n\r\nlocal_infile=1\r\ntmpdir=/mnt/fio\r\n\r\ndatadir=/mnt/fio320\r\nskip-grant-table\r\n\r\ninnodb_buffer_pool_size=4G[实际内存8G]\r\n\r\ninnodb_data_file_path=ibdata1:10M:autoextend\r\ninnodb_file_per_table=1\r\ninnodb_flush_log_at_trx_commit=1\r\ninnodb_log_buffer_size=16M\r\ninnodb_log_files_in_group=2\r\ninnodb_log_file_size=900M\r\ninnodb_thread_concurrency=0\r\ninnodb_flush_method             = O_DIRECT\r\n\r\ninnodb_write_io_threads=9\r\ninnodb_read_io_threads=9\r\ninnodb_io_capacity=500\r\ninnodb_max_dirty_pages_pct=90\r\nmax_connections=12000\r\nquery_cache_size=0\r\nskip-name-resolve\r\ntable_cache=400\r\n\r\n调整后reload，瞬间 排队的sql慢慢在减少，进程也开始逐步减少，到130稳定下\r\n再次打开app，速度跟平常速度一样了\r\n用mysqlworkbench 监控，命中率 和buffer使用率达到100%\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(117,'php,js  URL加密解密','php-js-url-encode-decode',1450685640,1450688244,'<!--markdown-->PHP url　加密解密函数\r\nbase64_encode\r\nbase64_decode\r\nrawurlencode\r\n\r\n<!--more-->\r\n\r\n```\r\n$returnUrl = base64_encode($returnUrl); //编码 \r\n$returnUrl = base64_decode($returnUrl);//解码 \r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(118,'从理论到实践，全方位认识DNS(转)','dns',1450701780,1450703004,'<!--markdown-->对于 DNS(Domain Name System) 大家肯定不陌生，不就是用来将一个网站的域名转换为对应的IP吗。当我们发现可以上QQ但不能浏览网页时，我们会想到可能是域名服务器挂掉了；当我们用别人提供的hosts文件浏览到一个“不存在”的网页时，我们会了解到域名解析系统的脆弱。\r\n\r\n然而关于DNS还有一大堆故事值得我们去倾听，去思考。\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n### DNS 源起\r\n\r\n要想访问网络上的一台计算机，我们必须要知道它的IP地址，但是这些地址（比如243.185.187.39）只是一串数字，没有规律，因此我们很难记住。并且如果一台计算机变更IP后，它必须通知所有的人。\r\n\r\n显然，直接使用IP地址是一个愚蠢的方案。于是人们想出了一个替代的方法，即为每一台计算机起一个名字，然后建立计算机名字到地址的一个映射关系。我们访问计算机的名字，剩下的名字到地址的转换过程则由计算机自动完成。\r\n\r\n### hosts映射\r\n\r\n早期，名字到地址的转换过程十分简单。每台计算机保存一个hosts文件，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。\r\n![20151105_hosts_local.png][1]\r\n\r\n早期的ARPANET就是这样做的，但是随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因：\r\n\r\nhosts文件变得非常大；\r\n主机名字会冲突；\r\n集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕）。\r\n域名系统\r\n\r\n为了解决上面的问题，1983年Paul Mockapetris提出了域名系统（DNS, Domain Name System)，这是一种层次的、基于域的命名方案，并且用一个分布式数据库系统加以实现。当我们需要访问一个域名（其实就是前面说的计算机的名字）时，应用程序会向DNS服务器发起一个DNS请求，DNS服务器返回该域名对应的IP地址。通过下面三种手段解决了上面的问题：\r\n\r\n用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）。\r\n规定了域名的命名规则，保证主机名字不会重复。\r\nDNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。\r\n这样访问一个域名的过程可以简化为下图：\r\n![20151105_dns_concept.png][2]\r\n\r\n\r\n### DNS 协议\r\n\r\n那么如何具体实现这个所谓的域名系统呢，要知道管理一个超大型并且不断变化的域名到IP的映射集合可不是一个简单的事，况且还要去应付成千上万的DNS查询请求。人们最终想出了一套不错的协议，规定如何来实现这个系统，下面我们一起来看看吧。\r\n\r\n### 域名空间\r\n\r\n首先我们需要制定一套命名规则，防止域名出现重复。DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。快递系统中要给某人邮寄物品，地址可能是这样：中国、广东省、广州市、番禺区、中山西路12号 XXX。而一个域名看起来则是这样的groups.google.com（为什么不是com.google.groups？我猜可能和老外写地址的习惯有关）。\r\n\r\n对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由ICANN（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示（图片来自Computer Networks: 7-1 ）：\r\n![20151105_domain_tree.png][3]\r\n\r\n\r\n### 域名资源记录\r\n\r\nDNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：\r\n\r\n**Domain_name Time_to_live Class Type Value**\r\n\r\n其中：\r\n\r\nDomain_name: 指出这条记录适用于哪个域名；\r\n**Time_to_live**: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；\r\nClass: 一般总是IN；\r\nType: 记录的类型；\r\nValue: 记录的值，如果是A记录，则value是一个IPv4地址。\r\n我们看到域名资源记录有一个Type字段，用来表明记录的类型。这是为什么呢？因为对于一个域名来说，通常并非只记录其IP地址，还可能需要一些其他种类的记录，一些常见的记录类型如下：\r\n\r\n记录类型	含义\r\nA	主机的IPv4地址\r\nAAAA	主机的IPv6地址\r\nNS	该域名所在域的权威域名服务器\r\nMX	接受特定域名电子邮件的服务器域名\r\nCNAME	当前域名的一个别名\r\n\r\n\r\n### 域名服务器\r\n\r\n我们知道不能只用一台域名服务器来响应所有的DNS查询，因为没有一台机器能够给全球的用户提供查询服务，计算能力、存储、带宽都不允许。只能合理组织一个域名服务器集群，使他们协同工作，共同提供域名解析服务。接下来首先要面对的一个问题是如何合理地将所有的域名资源记录存储到不同的域名服务器上。\r\n\r\n前面说过域名的名字空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（DNS zone），针对上图的域名空间，一种可能的域名划分如下图：\r\n![20151105_domain_zone.png][4]\r\n\r\n\r\n然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的权威域名服务器(Authoritative Name Servers )，它保存两类域名资源记录：\r\n\r\n该区域内所有域名的域名资源记录。\r\n父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。\r\n这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于我们后面进行域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图a：\r\n\r\n![20151105_name_servers.png][5]\r\n\r\n图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。对于上图的NDS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。\r\n\r\n仔细观察上图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，你可能会想出一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到我们有超过250个顶级域名，这样做并不是很恰当。\r\n\r\n而我们使用的域名系统则采用了一种更加聪明的方法，那就是引入根域名服务器，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。下图为全球根域名服务器的分布图，可以在这里找到。\r\n\r\n![20151105_root_servers.png][6]\r\n\r\n现在为止，我们的权威域名服务器和根域名服务器其实组成了一个树，树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器，对于图a中各个DNS区域的权威域名服务器，它们组成了下面这棵树（实际中，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。这部分的详细内容可以参考RFC 1034: 4. NAME SERVERS。下面为了容易理解，将其简化为一棵树）：\r\n![20151105_servers_tree.png][7]\r\n\r\n\r\n### 域名解析\r\n\r\n我们已经有了一个域名服务器集群，该集群合理地保存了域名空间和域名资源记录的对应关系。现在我们要做的就是发送一个DNS请求给域名服务器，然后坐等它返回正确的域名资源记录，这个过程叫作域名解析。\r\n\r\n严格来说，域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8（DNS服务器也有信任不信任之分，是的，实践篇会讲到），我们把这个域名服务器也叫作本地域名服务器。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。\r\n\r\n如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是本地域名服务器如何找到根域名服务器在哪里呢？其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。\r\n\r\n仍然以我们的图a为例，现在假设区域E内的某个用户想访问math.sysu.edu.cn，那么请求的过程如下：\r\n\r\n![20151105_name_resolution.png][8]\r\n\r\n用语言简单描述如下：\r\n\r\n用户：喂，本地域名服务器，告诉我math.sysu.edu.cn的地址；\r\n本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。root老大，能告诉我math.sysu.edu.cn的地址吗；\r\n根域名服务器：忙着呢，你去问B（.cn）；\r\n本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；\r\nB：你去问D（.edu.cn）；\r\n本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；\r\nD：你去问F（sysu.edu.cn）；\r\n本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；\r\nF：容老衲看看，哎呀，找到了，是X.X.X.X；\r\n本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X\r\n仔细想想，这和我们邮寄快递实在是如出一辙啊，假设你从美国邮东西到广州市番禺区，首先快递送到中国（不过这里没有一个类似根域名服务器的中转站而已），然后往下到广东省，接下来是广州市，再往下是番禺了。\r\n\r\n上面的是本地域名服务器的迭代解析过程，其实也可以递归查询，这里就不说了，道理差不多。\r\n\r\n### 缓存机制\r\n\r\n现在整个域名系统已经可以为我们提供域名解析服务了，当我们输入域名，计算机发送DNS请求，然后DNS服务器返回给我们解析的结果，一切看起来很完美。然而是不是可以更完美呢？\r\n\r\n回顾一下平时浏览网站的情况，我们会发现两个比较有意思的结论：\r\n\r\n80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的80/20 Rule；\r\n我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。\r\n这两条结论很容易让我们联想到缓存机制。如果我们将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，给自己和域名服务器都节省了麻烦。\r\n\r\n当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个Time_to_live字段，表明这条记录最多可以缓存多久。对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。\r\n\r\n我们既然可以在本机利用缓存，那么可不可以在域名服务器上也利用缓存机制呢，答案当然是可以的。因为对于域名服务器来说，上面的两条有意思的结论仍然有效。所以，域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。\r\n\r\n关于DNS理论部分，更多内容还可以参考这两个文本：\r\n\r\nRFC 1034: Domain Names - Concepts and Facilities\r\n\r\n### 并没有结束\r\n\r\n上面一大堆理论，看上去有点不明所以是吧，没事，接下来会结合实践来更加清晰地认识DNS这一最基础的系统。\r\n\r\n其实不止是DNS，还有HTTPS、TCP、UDP这些很基础的协议，都值得我们静下心去好好认识它们。因为，写DNS之前，我以为我已经完全搞明白了它，但是写的过程发现好多地方自己根本就不知道，之前完全是停留在一个很浮夸的层面上。所以，是时候找时间好好把这些协议过一遍，用自己的语言，从解决问题的角度，记录下这些经典协议的故事了。\r\n\r\n转自 [http://segmentfault.com/a/1190000003956853][9]\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/12/2334663679.png\r\n  [2]: http://blog.chromev.com/usr/uploads/2015/12/3320104314.png\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/12/2377305158.png\r\n  [4]: http://blog.chromev.com/usr/uploads/2015/12/2526693216.png\r\n  [5]: http://blog.chromev.com/usr/uploads/2015/12/1287288179.png\r\n  [6]: http://blog.chromev.com/usr/uploads/2015/12/2459498458.png\r\n  [7]: http://blog.chromev.com/usr/uploads/2015/12/1685879443.png\r\n  [8]: http://blog.chromev.com/usr/uploads/2015/12/440071482.png\r\n  [9]: http://segmentfault.com/a/1190000003956853',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(119,'20151105_hosts_local.png','20151105_hosts_local-png',1450701993,1450701993,'a:5:{s:4:\"name\";s:24:\"20151105_hosts_local.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/2334663679.png\";s:4:\"size\";i:48817;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(120,'20151105_dns_concept.png','20151105_dns_concept-png',1450702362,1450702362,'a:5:{s:4:\"name\";s:24:\"20151105_dns_concept.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/3320104314.png\";s:4:\"size\";i:66706;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(121,'20151105_domain_tree.png','20151105_domain_tree-png',1450702427,1450702427,'a:5:{s:4:\"name\";s:24:\"20151105_domain_tree.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/2377305158.png\";s:4:\"size\";i:44619;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(122,'20151105_domain_zone.png','20151105_domain_zone-png',1450702647,1450702647,'a:5:{s:4:\"name\";s:24:\"20151105_domain_zone.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/2526693216.png\";s:4:\"size\";i:73728;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',4,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(123,'20151105_name_servers.png','20151105_name_servers-png',1450702753,1450702753,'a:5:{s:4:\"name\";s:25:\"20151105_name_servers.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/1287288179.png\";s:4:\"size\";i:61869;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',5,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(124,'20151105_root_servers.png','20151105_root_servers-png',1450702819,1450702819,'a:5:{s:4:\"name\";s:25:\"20151105_root_servers.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/2459498458.png\";s:4:\"size\";i:104876;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',6,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(125,'20151105_servers_tree.png','20151105_servers_tree-png',1450702838,1450702838,'a:5:{s:4:\"name\";s:25:\"20151105_servers_tree.png\";s:4:\"path\";s:35:\"/usr/uploads/2015/12/1685879443.png\";s:4:\"size\";i:15764;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',7,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(126,'20151105_name_resolution.png','20151105_name_resolution-png',1450702877,1450702877,'a:5:{s:4:\"name\";s:28:\"20151105_name_resolution.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/12/440071482.png\";s:4:\"size\";i:48555;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',8,1,NULL,'attachment','publish',NULL,0,'1','0','1',118),(127,'python3.5安装,与2.6共存','python-centos-widowns-install',1450745100,1450745447,'<!--markdown-->在centos上安装Python3.5,\r\n\r\n\r\n<!--more-->\r\n\r\n```\r\n1、下载python 3源码\r\n# cd /usr/local/src/\r\n# wget https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz\r\n\r\n2、解压Python-3.5.1.tgz\r\n# tar -xzvf Python-3.5.0.tgz\r\n\r\n3、编译安装Python-3.5.1\r\n\r\n# cd Python-3.5.1\r\n\r\n./configure\r\n\r\n编译命令：\r\n# make\r\n安装命令：\r\n\r\n# make install\r\n\r\n\r\n```\r\n\r\n```\r\n# python3\r\nPython 3.5.1 (default, Dec 22 2015, 08:46:52) \r\n[GCC 4.4.7 20120313 (Red Hat 4.4.7-16)] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n```\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(128,'centos 安装 jenkins,maven,java 一','java-apache-maven-jenkins-install',1450775460,1450777683,'<!--markdown-->原来的升级总是ftp升级，这个是相当不方便，升级错误如何回流，要升级的文件一个一个升级。直到公司使用jenkins配合git来升级，感觉无比方便，查了下这个叫,  自动化持续集成软件安装，现在就来一步一步的安装\r\n\r\n\r\n<!--more-->\r\n\r\n![java.png][1]\r\n### java 安装\r\n本身系统已有java的版本，可通过 java -version来查看， 我们现在安装 1.7的版本，这里使用新的方式 alternatives，你问我怎么知道的，是通过 搜索到了 比较好.\r\n\r\n#### 首先下载java版本 64位\r\n```\r\n# cd /opt/\r\n# wget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u66-b17/jdk-8u66-linux-x64.tar.gz\"\r\n# tar xzf jdk-8u66-linux-x64.tar.gz\r\n```\r\n#### Install Java with Alternatives, alternatives 这个命令是我系统自带的，所以我就没有研究如何安装了，\r\nalternatives 执行后会要你选 你现在java的目录 ,输入 序号\r\n```\r\n# cd /opt/jdk1.8.0_66/\r\n# alternatives --install /usr/bin/java java /opt/jdk1.8.0_66/bin/java 2\r\n# alternatives --config java\r\n\r\n\r\nThere are 3 programs which provide \'java\'.\r\n\r\n  Selection    Command\r\n-----------------------------------------------\r\n*  1           /opt/jdk1.7.0_71/bin/java\r\n + 2           /opt/jdk1.8.0_45/bin/java\r\n   3           /opt/jdk1.8.0_51/bin/java\r\n   4           /opt/jdk1.8.0_66/bin/java\r\n\r\nEnter to keep the current selection[+], or type selection number: 4\r\n\r\n```\r\n\r\n然后替换 现有的java命令\r\n```\r\n\r\n# alternatives --install /usr/bin/jar jar /opt/jdk1.8.0_66/bin/jar 2\r\n# alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_66/bin/javac 2\r\n# alternatives --set jar /opt/jdk1.8.0_66/bin/jar\r\n# alternatives --set javac /opt/jdk1.8.0_66/bin/javac \r\n\r\n```\r\n\r\n验证下\r\n```\r\n\r\nroot@tecadmin ~# java -version\r\n\r\njava version \"1.8.0_66\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_66-b17)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)\r\n\r\n\r\n```\r\n\r\n改变java home的环境变量\r\n```\r\nexport JAVA_HOME=/opt/jdk1.8.0_66\r\nexport JRE_HOME=/opt/jdk1.8.0_66/jre\r\nexport PATH=$PATH:/opt/jdk1.8.0_66/bin:/opt/jdk1.8.0_66/jre/bin\r\n```\r\n\r\n这样java新版就安装好了\r\n\r\n\r\n\r\n### apache的maven安装  maven翻译过来，叫行家\r\n在 官网下载 [http://maven.apache.org/download.cgi][2], 下载 apache-maven-3.3.9-bin.tar.gz 带bin的，编译过的\r\n```\r\ntar -zvxf apache-maven-3.3.3-bin.tar.gz  \r\n\r\n```\r\n配置环境变量 编辑在etc目录下的profile文件\r\n```\r\nvi /etc/profile \r\nexport MAVEN_HOME=/usr/local/apache-maven-3.3.3  \r\nexport PATH=$PATH:$MAVEN_HOME/bin \r\nsource /etc/profile  \r\n```\r\n验证\r\n```\r\nmvn -version  \r\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)\r\nMaven home: /opt/apache/apache-maven-3.3.9\r\nJava version: 1.7.0_79, vendor: Oracle Corporation\r\nJava home: /opt/java/jdk1.7.0_79/jre\r\nDefault locale: en_US, platform encoding: UTF-8\r\nOS name: \"linux\", version: \"2.6.32-431.23.3.el6.x86_64\", arch: \"amd64\", family: \"unix\"\r\n```\r\n如上信息，表示成功\r\n\r\n### 安装jenkins\r\n\r\n下载jenkins的 rpm包,顺序执行下面的命令，这里没有进行编译了\r\n```\r\nwget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo  \r\nrpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key \r\nyum install jenkins \r\n```\r\n\r\n安装成功后，修改端口\r\n```\r\nvi /etc/sysconfig/jenkins  \r\n\r\n```\r\n\r\n将其中默认的\r\nJENKINS_PORT=\"8080\"\r\nJENKINS_AJP_PORT=\"8009\"\r\n\r\n修改为\r\nJENKINS_PORT=\"8888\"\r\nJENKINS_AJP_PORT=\"8889\"\r\n\r\n保存退出，尝试启动Jenkins服务\r\n\r\n\r\n```\r\nservice jenkins start \r\n\r\n# /etc/init.d/jenkins restart\r\nShutting down Jenkins                                      [FAILED]\r\nStarting Jenkins                                           [  OK  ]\r\n```\r\n如上表示成功\r\n\r\n然后用ip加 8888 访问,如果看到下图\r\n\r\n![jenkins.png][3]\r\n\r\n接下来 [博客][4]，将添加 git等任务\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2015/12/133958508.png\r\n  [2]: http://maven.apache.org/download.cgi\r\n  [3]: http://blog.chromev.com/usr/uploads/2015/12/779488286.png\r\n  [4]: http://blog.chromev.com',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(131,'java.png','java-png',1450777679,1450777679,'a:5:{s:4:\"name\";s:8:\"java.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/12/133958508.png\";s:4:\"size\";i:15629;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',128),(130,'jenkins.png','jenkins-png',1450776483,1450776483,'a:5:{s:4:\"name\";s:11:\"jenkins.png\";s:4:\"path\";s:34:\"/usr/uploads/2015/12/779488286.png\";s:4:\"size\";i:29568;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',128),(132,'javascript 闭包 (转)','js-closure',1450862797,1450862797,'<!--markdown-->闭包，是 javascript 中重要的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，你很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包！\r\n\r\n\r\n<!--more-->\r\n\r\n### 1 闭包的概念\r\n\r\n在接触一个新技术的时候，我首先会做的一件事就是：找它的demo code。对于码农们来说，代码有时候比自然语言更能理解一个事物。 其实，闭包无处不在，比如：jQuery、zepto的主要代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包demo，好让你在大脑里产生闭包的画面：\r\n```\r\nfunction A(){\r\n    function B(){\r\n       console.log(\"Hello Closure!\");\r\n    }\r\n    return B;\r\n}\r\nvar c = A();\r\nc();//Hello Closure!\r\n```\r\n\r\n这是史上最简单的闭包，不能再简单了，再简单就不是闭包了！\r\n\r\n有了初步的认识后，我们简单分析一下它和普通函数有什么不同，这样我们才能从“茫茫人海”中一眼认出“她”。\r\n\r\n上面代码翻译成自然语言如下：\r\n\r\n(1)定义了一个普通函数A\r\n\r\n(2)在A中定义了普通函数B\r\n\r\n(3)在A中返回B**（确切的讲，在A中返回B的引用）**\r\n\r\n(4)执行A(),把A的返回结果赋值给变量 c\r\n\r\n(5)执行 c() \r\n\r\n把这5步操作总结成一句扯淡的话就是：\r\n\r\n函数A的内部函数B被函数A外的一个变量 c 引用\r\n\r\n把这句扯淡的话再加工一下就变成了闭包的定义：\r\n\r\n当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。\r\n\r\n不要刻意去记住这个定义，我告诉你这个定义的目的是想让你理解上面的5步操作就是在阐述闭包的定义。\r\n\r\n因此，当你执行了上述5步操作的时候，你就已经定义了一个闭包！\r\n\r\n这就是**闭包**。\r\n\r\n### 闭包的作用 \r\n在了解闭包的作用之前，我们先了解一下 javascript中的GC机制:在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收，否则这个对象一直会保存在内存中。\r\n\r\n在上述例子中，B定义在A中，因此B依赖于A,而外部变量 c 又引用了B, 所以A间接的被 c 引用，也就是说，A不会被GC回收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进：\r\n\r\n```\r\nfunction A(){\r\n    var count = 0;\r\n    function B(){\r\n       count ++;\r\n       console.log(count);\r\n    }\r\n    return B;\r\n}\r\nvar c = A();\r\nc();// 1\r\nc();// 2\r\nc();// 3\r\n```\r\ncount是A中的一个变量，它的值在B中被改变，函数B每执行一次，count的值就在原来的基础上累加1。因此，A中的count一直保存在内存中。\r\n\r\n这就是闭包的作用，有时候我们需要一个模块中定义这样一个变量：希望这个变量一直保存在内存中但又不会“污染”全局的变量，这个时候，我们就可以用闭包来定义这个模块。\r\n\r\n\r\n### 3 高端写法\r\n\r\n上面的写法其实是最简单最原始的写法，而在实际应用中，没人这么玩，特别是在一些大型JS框架中更不会这么写。我之所以还要告诉你这种写法，是因为干扰因素越少越容易专注于一件事。下面我用常用的写法来写一个简单的demo组件：\r\n\r\n```\r\n(function(document){\r\n    var viewport;\r\n    var obj = {\r\n        init:function(id){\r\n           viewport = document.querySelector(\"#\"+id);\r\n        },\r\n        addChild:function(child){\r\n            viewport.appendChild(child);\r\n        },\r\n        removeChild:function(child){\r\n            viewport.removeChild(child);\r\n        }\r\n    }\r\n    window.jView = obj;\r\n})(document);\r\n```\r\n这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行。主要是要理解这种写法是怎么实现闭包功能的。\r\n\r\n可以将上面的代码结构分成两部分：**(function(){})**()  红色部分是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加()就表示执行这个匿名函数。\r\n\r\n因此这段代码执行执行过程可以分解如下：\r\n```\r\nvar f = function(document){\r\n    var viewport;\r\n    var obj = {\r\n        init:function(id){\r\n            viewport = document.querySelector(\"#\"+id);\r\n        },\r\n        addChild:function(child){\r\n            viewport.appendChild(child);\r\n        },\r\n        removeChild:function(child){\r\n            viewport.removeChild(child);\r\n        }\r\n    }\r\n    window.jView = obj;\r\n};\r\nf(document);\r\n```\r\n在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：\r\n```\r\nwindow.jView = obj;\r\n```\r\n\r\nobj 是在 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了 f 中的变量 viewport ,因此 f 中的 viewport 不会被GC回收，会一直保存到内存中，所以这种写法满足闭包的条件。 \r\n\r\n \r\n\r\n### 4 简单的总结语\r\n\r\n这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(call object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为一个初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解！\r\n\r\n\r\n转载 [干货分享：让你分分钟学会 javascript 闭包][1]\r\n\r\n\r\n  [1]: http://www.cnblogs.com/onepixel/p/5062456.html',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(133,'PHP 数组 详解','php_array',1450870020,1450870756,'<!--markdown-->PHP数组是一个重要的概念,它包含有大量的函数,方便人们的开发…现将它的数组分类,以方便查询及应用.\r\n先说说PHP数组的定义…PHP数组包含两个项,key和value,可以通过key来获取相应的value,其中key又可以是数值和关联的\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n创建数组\r\nPHP中的数组声明跟其它语言的也有点小小的差别,但一样可以声明为一维,两维,三维及多维等,如\r\n$array[0] = 1,$array = array(1,2,3); 一维数组,只包括三个值,属于数值型数组,引用时可用$array[0]来代表1,创建数值数组时可以省略索引.\r\n```\r\n$array = array(\r\n   1 => “one”,\r\n   2 => “two”,\r\n   3 => “three”,\r\n   4 => array(\r\n    “one” => 1,\r\n    “two” => 2,\r\n    “three” => 3\r\n   )\r\n);\r\n```\r\n二维数组,同时又是关联数组,引用时可以$array[4][“one”]来代表1.\r\n三维以上依此类推…\r\n如果要批量创建数组,则可以通过下面这个函数:\r\n```\r\narray range ( mixed low, mixed high [, number step] )\r\n```\r\n如$array = range(1,6);代表array(1,2,3,4,5,6);\r\n  $array = range(a,f); 代表 array(a,b,c,d,e,f);\r\n\r\n输出数组\r\nPHP中输出数组的函数有比较多,常用的有\r\n```\r\nbool print_r ( mixed expression [, bool return] )\r\nvoid var_dump ( mixed expression [, mixed expression [, …]] )\r\n还有像echo,print,printf都可以输出单个数组.\r\n```\r\n\r\n测试数组\r\n有时我们需要判定一个变量是否为数组,则可以使用:\r\n```\r\nbool is_array ( mixed var )\r\n```\r\n\r\n### 增加或删除数组元素\r\n数组声明后并不是一成不变的,可能通过对数组的增加删除来进行深入的操作:\r\n```\r\nint array_push ( array &array, mixed var [, mixed …] ) 将一个或多个单元压入数组的末尾,数组的长度根据入栈变量的数目增加,如array_push($array,$var)\r\nmixed array_pop ( array &array ) 将数组的最后一个元素弹出(出栈),并在结束后重置数组的指针\r\nmixed array_shift ( array &array ) 返回数组的第一个元素.\r\nint array_unshift ( array &array, mixed var [, mixed …] ) 在数组的开头插入一个或多个单元\r\narray array_pad ( array input, int pad_size, mixed pad_value ) 用值将数组填补到指定的长度,如array_pad($array,3,$var);\r\n```\r\n\r\n### 定位数组元素\r\n```\r\nbool in_array ( mixed needle, array haystack [, bool strict] ) 检查数组中是否存在某个值\r\narray array_keys ( array input [, mixed search_value [, bool strict]] ) 返回数组中的所有键名,重组成一个新数组\r\nbool array_key_exists ( mixed key, array search ) 检查给定的key是否存在于数组中.\r\narray array_values ( array input ) 返回数组中所有的值\r\nmixed array_search ( mixed needle, array haystack [, bool strict] ) 在数组中搜索给定的值,成功则返回key.\r\n```\r\n\r\n### 遍历数组\r\nPHP中提供了很多获取key和value的函数\r\n```\r\nmixed key ( array &array ) 从关联数组中取得键名\r\nmixed reset ( array &array ) 将数组指针重置\r\narray each ( array &array ) 返回数组中的键/值对并将数组向前移一步\r\nmixed current ( array &array ) 返回数组中的当前单元\r\nmixed end ( array &array ) 将数组中的指针移向最后一位\r\nmixed next ( array &array ) 将数组中的指针移向下一位\r\nmixed prev ( array &array ) 将数组中的指针移向上一位\r\narray array_reverse ( array array [, bool preserve_keys] ) 返回一个单元顺序相反的数组\r\narray array_flip ( array trans ) 将数组中的键值角色调换\r\n```\r\n\r\n除了上面的函数外还可以使用循环来对数组中的元素进行遍历,如\r\n```\r\nforeach (array_expr as $value)\r\n{ statement    }\r\nforeach (array_expr as $key=>$value)\r\n{ statement   }\r\n```\r\n提取每个键/值对,直到获得所有项或满足某些内部条件为止\r\n```\r\nvoid list ( mixed varname, mixed … ) 把数组中的值赋给一些变量\r\n```\r\n\r\n### 确定数组大小和唯一性\r\n```\r\nint count ( mixed var [, int mode] ) 计算数组中单元数组或对象中属性的个数, sizeof 的同名函数\r\narray array_count_values ( array input ) 统计数组中所有值出现的次数\r\narray array_unique ( array array ) 移除数组中重复的值\r\n```\r\n\r\n### 数组排序\r\n```\r\nbool sort ( array &array [, int sort_flags] ) 对数组进行排序\r\nbool natsort ( array &array ) 用自然排序法对数组进行排序\r\nbool natcasesort ( array &array ) 用自然排序法对数组进行排序,不区分大小写\r\nbool rsort ( array &array [, int sort_flags] ) 对数组进行逆向排序\r\nbool asort ( array &array [, int sort_flags] ) 对数组进行排序并保持索引关系\r\nbool array_multisort ( array ar1 [, mixed arg [, mixed … [, array …]]] ) 对多个数组或多维数组进行排序\r\nbool arsort ( array &array [, int sort_flags] ) 对数组进行逆序排序并保持索引关系\r\nbool ksort ( array &array [, int sort_flags] ) 对数组按键名排序\r\nbool krsort ( array &array [, int sort_flags] ) 对数组按键名逆序排序\r\n```\r\n\r\n### 合并,拆分,接合和分解数组\r\n```\r\narray array_combine ( array keys, array values ) 创建一个数组,一个数组的值作为其键名,另一个数组的值作为其值\r\narray array_merge ( array array1 [, array array2 [, array …]] ) 合并一个或多个数组\r\narray array_merge_recursive ( array array1 [, array …] ) 递归地全部一个或多个数组\r\narray array_slice ( array array, int offset [, int length [, bool preserve_keys]] ) 从数组中取出一段,建立一个新的数组,如果offset为正数,拆分从距数组开关的offset位置开始,如果为负数,则拆分从距数组末尾的offset位置开始,此时距数组开关的count(input_array)-|length|位置结束\r\narray array_splice ( array &input, int offset [, int length [, array replacement]] ) 把数组中的部分值去掉,并用其它值替代.offset设置同上\r\narray array_intersect ( array array1, array array2 [, array …] ) 计算数组的交集,即是说如果第一个数组中出现过的值在接下来的几个数组中都有出现,则取出该值\r\narray array_intersect_assoc ( array array1, array array2 [, array …] ) 带索引检查数组中的交集\r\narray array_intersect_key ( array array1, array array2 [, array …] ) 使用键名比较数组中的交集\r\narray array_diff ( array array1, array array2 [, array …] ) 计算数组的差集, 即是说跟第一个数组中不同的值\r\narray array_diff_assoc ( array array1, array array2 [, array …] ) 带索引检查数组中的差集\r\narray array_diff_key ( array array1, array array2 [, array …] ) 使用键名比较数组中的差集\r\n```\r\n\r\n其它比较有用的数组函数\r\n数组函数还有好多没有列出来…再上几个比较有用也比较常的,其它的就参考手册啦…手册里很清楚\r\n```\r\nmixed array_rand ( array input [, int num_req] ) 数组中随机取出一个或多个键,num指定个数\r\nbool shuffle ( array &array ) 将数组打乱\r\nnumber array_sum ( array array ) 计算数组中所有值的总和,关联数组忽略\r\narray array_chunk ( array input, int size [, bool preserve_keys] ) 将一个数组分割成几个\r\n```\r\n\r\nphp索引以0开始\r\n```\r\n$a=array(0=>”a”,1=>”b”);\r\n$a=array(“a”=>”A”,”b”=>”B”);\r\n调用：$a[“a”]\r\n```\r\n\r\n\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(134,'python抓取糗事百科','python-crawl-qiushibaike',1452136500,1452136533,'<!--markdown-->直接上代码\r\n\r\n\r\n<!--more-->\r\n\r\n```\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\n__title__ = \'\'\r\n__author__ = \'Administrator\'\r\n__mtime__ = \'2016/1/7\'\r\n# code is far away from bugs with the god animal protecting\r\n    I love animals. They taste delicious.\r\n\"\"\"\r\nimport re\r\n\r\nimport urllib\r\nimport urllib2\r\nimport cookielib\r\nimport sys\r\n\r\n# 使得 sys.getdefaultencoding() 的值为 \'utf-8\'\r\nreload(sys)                      # reload 才能调用 setdefaultencoding 方法\r\nsys.setdefaultencoding(\'utf-8\')  # 设置 \'utf-8\'\r\n\r\n\r\npage = 1\r\nurl = \"http://www.qiushibaike.com/hot/page/\" + str(page)\r\nlogin_header = {\r\n    \'User-Agent\': \'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\'\r\n}\r\nrequest = urllib2.Request(url, headers=login_header)\r\ntry:\r\n\r\n    response = urllib2.urlopen(request)\r\n    content = response.read().decode(\'utf-8\')\r\n    # print(response1.getcode())\r\n    # print(len(response1.read()))\r\nexcept urllib2.URLError, e:\r\n    if hasattr(e, \"code\"):\r\n        print e.code\r\n    if hasattr(e, \"reason\"):\r\n        print e.reason\r\n\r\n\r\npattern = re.compile(\'<a.*?<h2>(.*?)</h2>.*?</a>.*?<div.*?>(.*?)<!--(.*?)-->.*?</div>.*?<div.*?<i.*?class=\"number\">(.*?)</i>.*?</div>\', re.S)\r\n\r\nitems = re.findall(pattern, content)\r\n\r\nfor item in items:\r\n    #print(item[0], item[1], item[2], item[3])\r\n    print(item[0].strip())\r\n    print(item[1].strip())\r\n    print(item[2].strip())\r\n    print(item[3].strip())\r\n    print(\'===========\')\r\n```\r\n\r\n效果\r\n```\r\nD:\\Python27\\python.exe F:/python/scrapy/url0107.py\r\n佛讲同缘，道法自然！\r\n初中时候，楼主比较瘦弱，但是同桌是个“高大威猛”女汉子……<br/>有次有几个“小痞子”在教室欺负楼主，她二话没说，上去抱住楼主，一把摔倒，对那几个小痞子说：你们看，这样瘦弱，你们忍心欺负吗？！\r\n1452130112\r\n3467\r\n===========\r\n90後不爱冬眠\r\n小的时候，和村里的一人起了争执，我一气之下就把他给打了，打完之后他哭着说要去告诉他哥。我一听，这下坏了，他哥揍人下手非常的狠，我越想越觉得不能就这么便宜了他，于是追上去，把他按在地上又打了一顿！！\r\n1452074315\r\n9987\r\n===========\r\n小恩同学~\r\n每次看完恐怖片后。和厕所的距离。\r\n1452095299\r\n464\r\n===========\r\n我不犯二谁犯二\r\n到了适婚年龄了，于是向老妈取经，：妈，我是找个喜欢我的人还是找个我喜欢的人呢？老妈：当然是你喜欢的人啊。我：为什么呀。老妈：因为没有人会喜欢你啊。是亲娘吗\r\n1452103713\r\n8169\r\n===========\r\n110流浪的猫\r\n最近妞妞期末摸底考试一直不错，今天拿回一张试卷，才考78分，我一看火了:咋这么点分？是不是骄傲了？<br/><br/>妞妞挺委屈:最后让写一篇短文，占了20分，题目是&lt;勤劳的妈妈&gt;，实在不知道怎么写。。。\r\n1452076836\r\n19090\r\n===========\r\n陌路莫回。媚娘\r\n我当年生完孩子回娘家，老公特别勤快的给我和闺女打包尿片衣服各种生活用品、开门下车还塞给我600块钱说“老婆多住几天没关系的、钱不够给我打电话！把我感动的快哭了！临走时这货来了句“今晚终于可以睡个安稳觉了！”\r\n1452086961\r\n11557\r\n===========\r\n未来的蔚蓝\r\n今天早上起来晨跑，有个女的问我，看你天天一个人跑，你老婆呢？我说有老婆在身边这么冷谁起来这么早乱跑……\r\n1452150721\r\n2508\r\n===========\r\n落花时节花落\r\n哥们看上了一女的，让我扮流氓，结果我差点被那女的打屎，幸好哥们及时赶来救我，后来那女的竟然看上我了，原因是我好欺负。。。。。我该怎么办\r\n1452098455\r\n13069\r\n===========\r\n麦田里的春天。\r\nlz是个差生。大学毕业一年了，今天被叫去给侄儿教作业。只想说一句，三年级的英语对我具有很高的挑战性，，，\r\n1452069670\r\n7906\r\n===========\r\n豆姥爷逗豆豆\r\n听县医院一同学讲的：一八十多的老头，骑自行车遇一九十多的老头，非要带上他，结果两人都住院了\r\n1452032694\r\n7259\r\n===========\r\n叫我小磊就好\r\n有一天我坐公交，到站后上来一位妇女抱着一个小孩，我很有眼力的给让了座，然后那位妇女笑着对那个小男孩说 : 快说谢谢，儿子。然后那个小男孩微笑着对我说 : 谢谢儿子。\r\n1452111219\r\n8743\r\n===========\r\n蛋蛋夹大鸟\r\n大一刚开学军训。一男生背来一女生，女生很痛苦的样子。医生检查后，那男生问医生女生得了什么病。医生说是痛经。男生华丽丽的来了一句，她是哪根经痛啊，痛的那么厉害！！！医务室的护士、病人集体凌乱了！！！\r\n1452091716\r\n11300\r\n===========\r\n一本正经的假正经\r\n我不会告诉你它是流浪到我家的\r\n1452086799\r\n353\r\n===========\r\nF有你真好C\r\n别嫌老婆烦，除了她 谁特么大半夜的不睡觉给你打电话要你注意安全 早点回家！！！\r\n1452115852\r\n4701\r\n===========\r\n三炮五十六\r\n就刚刚，三岁的儿子从床上下来跑到我跟前说：爸爸我刚才喝奶和太多了。我以为他肚子难受就问他是不是想去嘘嘘，结果臭小子说：不嘘嘘，我想耍奶疯。。。。玛的，他才三岁啊，这词儿都搁哪学的啊\r\n1452121213\r\n5528\r\n===========\r\n童萌\r\n本人体毛奇多，昨天洗澡的时候室友盯着我身上的体毛看了好久之后说了一句：你是不是每次洗澡擦一遍沐浴露还要再擦一次护发素啊？当时我心里的那个醉啊。。。\r\n1452071472\r\n8812\r\n===========\r\n微信小视频群！日更百部\r\n儿子特别不爱洗脸、昨天晚上带他去吃肯德基、就指着旁边坐的黑人老外说：儿子你要是再不爱洗脸以后就像他一样黑、没想到那个老外转身拍了拍我儿子、用一口流利的普通话说：你爸爸撒谎呢！我这是天生的！\r\n1452116189\r\n6816\r\n===========\r\n隔三差五犯点二\r\n期末历史考试，有一题：秦始皇和汉武帝你更欣赏哪一位？一学生答：我更欣赏秦始皇，因为他焚书坑儒，把书烧了，把老师埋了，学生就不用上学了！\r\n1452088078\r\n7723\r\n===========\r\n吟小隐\r\n媳妇怀孕八个月了，马上要生个猴宝宝。。割咯咯咯各割。。今天媳妇对我说“你看你孩儿要出生了，你要送她什么礼物呢？要不送个金猴的项链吧。”我说送项链他那么小也带不了啊。媳妇来了句。。。“她妈替她带。。”媳妇你好机智啊！！\r\n1452111979\r\n7377\r\n===========\r\n张小鸟儿\r\n没事抱着八岁的外甥女教育：你长大了要找个像舅舅一样的男人嫁，知道不？<br/><br/>外甥女答应：嗯。<br/><br/>刚放下，她又跟我说：可是舅舅，我还是喜欢比较帅的。\r\n1452076552\r\n8067\r\n===========\r\n\r\nProcess finished with exit code 0\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(135,'python 抓取免费IP,并验证是否有真实','python-crawl-free-ip',1454139540,1454139904,'<!--markdown-->python把这些IP爬下来时，就可以批量爬站，投票，模拟用户等操作\r\n用到python 组件 Mysql,redis, BeautifulSoup\r\n\r\n<!--more-->\r\n\r\n```\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\n__title__ = \'\'\r\n__author__ = \'Administrator\'\r\n__mtime__ = \'2016/1/29\'\r\n# code is far away from bugs with the god animal protecting\r\n    I love animals. They taste delicious.\r\n\"\"\"\r\n\r\n#http://haodailiip.com/guonei/1\r\n\r\nimport time\r\nimport sys\r\nfrom bs4 import BeautifulSoup\r\nimport re\r\nimport urllib\r\nimport urllib2\r\nimport socket\r\nimport MySQLdb\r\nimport redis\r\n\r\nNEW_URLS_KEY=\'new:urls:key\'\r\n\r\n\r\nclass IpCrawl:\r\n    def __init__(self):\r\n        self.header = {\r\n            \'User-Agent\': \'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36\',\r\n        }\r\n        proxy = \'61.160.250.25:3128\'\r\n        self.proxy = urllib2.ProxyHandler({\'http\': proxy})\r\n\r\n        self.conn = \'\'\r\n        self.cursor = \'\'\r\n        self.init_mysql()\r\n\r\n        self.redis = \'\'\r\n        self.init_redis()\r\n\r\n\r\n    def init_mysql(self):\r\n        self.conn = MySQLdb.connect(host=\"127.0.0.1\", user=\"root\", passwd=\"root\", db=\"douban\", charset=\"utf8\")\r\n        self.cursor = self.conn.cursor()\r\n\r\n    def init_redis(self):\r\n        self.redis = redis.StrictRedis(\'localhost\', \'6379\', 0)\r\n\r\n\r\n    def get_content(self, url):\r\n        #request\r\n        request = urllib2.Request(url, headers=self.header)\r\n        opener = urllib2.build_opener(self.proxy)\r\n        resp = opener.open(request)\r\n        try:\r\n            if resp.getcode() == 200:\r\n                #print(resp.read())\r\n                return resp.read()\r\n            else:\r\n                print(resp.getcode())\r\n\r\n        except urllib2.HTTPError, e:\r\n            print e.code\r\n            print e.msg\r\n            return None\r\n\r\n\r\n    def html_parse(self, content):\r\n        soup = BeautifulSoup(content, \'html.parser\', from_encoding=\'utf-8\')\r\n        trs = soup.find_all(\'tr\')\r\n        for tr in trs:\r\n            tds = tr.find_all(\'td\')\r\n            if len(tds) == 7:\r\n                ip = tds[0].get_text().strip()\r\n                pattern = re.compile(\'IP\')\r\n                m = pattern.match(ip)\r\n                if m:\r\n                    continue\r\n                port = tds[1].get_text().strip()\r\n                lo = tds[2].get_text().strip()\r\n                n = self.in_redis_queue(ip, port)\r\n\r\n                str = \"%s 入库,待验证\".decode(\'utf-8\') % ip\r\n                print(str)\r\n\r\n                # n = self.in_douban_queue(ip, port, lo)\r\n                #\r\n                # if n == 0:\r\n                #     str = \"%s 入库,待验证\".decode(\'utf-8\') % ip\r\n                #     print(str)\r\n                # else:\r\n                #     if n == 1:\r\n                #         print(\"%s 已加入过\".decode(\'utf-8\') % ip)\r\n                #     else:\r\n                #         print(\"%s 入库出错\".decode(\'utf-8\') % ip)\r\n\r\n    def veritfy(self, ipstr):\r\n        iparr = ipstr.split(\':\')\r\n        #print(iparr[0], iparr[1])\r\n        visiturl = \'http://ip.chinaz.com/getip.aspx\'\r\n        proxy_url = \"http://%s\" % (ipstr)\r\n        try:\r\n            resp = urllib.urlopen(visiturl, proxies={\'http\': proxy_url})\r\n            if resp.getcode() == 200:\r\n                pattern = re.compile(r\"address:\'(.*?)\'\", re.S)\r\n                str = \'\'\r\n                m = re.findall(pattern, resp.read())\r\n                if m:\r\n                    str = m[0].strip()\r\n                    print(str)\r\n\r\n        except Exception, e:\r\n            print proxy_url\r\n            print e\r\n\r\n\r\n\r\n    def in_redis_queue(self, ip, port):\r\n\r\n        ipstr = \'%s:%s\' % (ip, port)\r\n        if not self.redis.sismember(NEW_URLS_KEY, ipstr):\r\n            self.redis.sadd(NEW_URLS_KEY, ipstr)\r\n\r\n    def do_redis_queue(self):\r\n        ips = self.redis.smembers(NEW_URLS_KEY)\r\n        ipslen = len(ips)\r\n\r\n        i = 0\r\n        while i<ipslen:\r\n            ipstr = self.redis.spop(NEW_URLS_KEY)\r\n            self.veritfy(ipstr)\r\n            i = i+1\r\n\r\n    def in_douban_queue(self, ip, port, lo):\r\n        #判断是否存在\r\n        sqlif = \"SELECT COUNT(1) as cnt FROM douban_ip_queue WHERE ip=%s \"\r\n        param = [ip]\r\n\r\n        try:\r\n            self.cursor.execute(sqlif, param)\r\n            n = self.cursor.fetchone()\r\n            if int(n[0]) > 0:\r\n                return 1\r\n        except MySQLdb.Error, e:\r\n            print \"Mysql Error %d: %s\" % (e.args[0], e.args[1])\r\n\r\n        try:\r\n            sql = \"INSERT INTO douban_ip_queue(ip, port, lo, addtime) VALUES(%s, %s, %s, %s)\"\r\n            param = [ip, port, lo, time.strftime(\"%Y-%m-%d %H-%M-%S\")]\r\n            n = self.cursor.execute(sql, param)\r\n            self.conn.commit()\r\n            return 0\r\n        except MySQLdb.Error, e:\r\n            print \"Mysql Error %d: %s\" % (e.args[0], e.args[1])\r\n            self.conn.rollback()\r\n            return 2\r\n\r\n\r\n\r\n    def crawl(self, url):\r\n        content = self.get_content(url)\r\n        self.html_parse(content)\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    crawl = IpCrawl()\r\n    url = \'http://haodailiip.com/guonei/1\'\r\n    crawl.crawl(url)\r\n\r\n    crawl.do_redis_queue()\r\n\r\n```\r\n\r\n结果如图\r\n![1.png][1]\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2016/01/3049345278.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(136,'1.png','1-png-2',1454139850,1454139850,'a:5:{s:4:\"name\";s:5:\"1.png\";s:4:\"path\";s:35:\"/usr/uploads/2016/01/3049345278.png\";s:4:\"size\";i:56434;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',135),(137,'3F58D8AB-9C76-461C-8394-F35CF8A3FE70.png','3F58D8AB-9C76-461C-8394-F35CF8A3FE70-png',1456546653,1456546653,'a:5:{s:4:\"name\";s:40:\"3F58D8AB-9C76-461C-8394-F35CF8A3FE70.png\";s:4:\"path\";s:35:\"/usr/uploads/2016/02/1547794873.png\";s:4:\"size\";i:40291;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',138),(138,'mac 安装vm fusion虚拟机，解决网络 unknown host','mac-vmfusion-centos-network-unknow',1456546680,1456548816,'<!--markdown-->mac的虚拟机vm fusion安装centos6.7\r\ncentos6.7.iso 源用的是阿里云的，下载的话去搜索下吧\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n### 1点击安装分区\r\n![3F58D8AB-9C76-461C-8394-F35CF8A3FE70.png][1]\r\n\r\n### 2配置固定ip网络\r\n \r\n先安装VM TOOLS\r\n\r\n#### 2.1 确认设置了域名服务器\r\n\r\n```\r\n  # cat /etc/resolv.conf\r\n  nameserver 8.8.8.8    #（Google的公共DNS服务）\r\n  nameserver 8.8.4.4    #（Google的公共DNS服务）\r\n```\r\n#### 2.2 确认网关\r\n先确定下 mac下vm fusion的网络配置\r\n```\r\ncd /Library/Preferences/VMware Fusion/\r\nvim networking\r\n添加网关\r\nanswerVNET_8_HOSTONLY_SUBNET 192.168.148.0\r\n```\r\n```\r\nvim /etc/sysconfig/network\r\n增加一条网关信息\r\n\r\nNETWORKING=yes\r\nNETWORKING_IPV6=no\r\nHOSTNAME=maccentenos\r\nGATEWAY=192.168.148.2\r\n```\r\n#### 2.3 域名服务器\r\n```\r\n# cat /etc/resolv.conf\r\nnameserver 8.8.8.8    #（Google的公共DNS服务）\r\nnameserver 8.8.4.4    #（Google的公共DNS服务）\r\n```\r\n确认DNS可用\r\n```\r\n# grep hosts /etc/nsswitch.conf\r\n   hosts:      files dns\r\n```\r\n\r\n#### 2.4 配置固定IP\r\n```\r\nHWADDR=00:0C:29:CF:9F:7C\r\nTYPE=Ethernet\r\nBOOTPROTO=none\r\nIPADDR=192.168.148.132\r\nNETMASK=255.255.255.0\r\nPREFIX=24\r\nGATEWAY=192.168.148.2\r\nDNS1=114.114.114.114\r\nDNS2=8.8.8.8\r\nDEFROUTE=yes\r\nIPV4_FAILURE_FATAL=yes\r\nIPV6INIT=no\r\nNAME=\"Auto eth0\"\r\nONBOOT=yes\r\nDEVICE=eth0\r\nUSERCTL=no\r\n```\r\n\r\n#### 2.5 重启\r\n```\r\nservice network restart\r\n```\r\n\r\n### 查看网关的其他方法\r\n\r\n```\r\n1.ifconfig -a 和 cat /etc/resolv.conf  （主要查看ip/netmask和dns）\r\n\r\n2.netstat -rn\r\n\r\n3.cat /etc/sysconfig/network\r\n\r\n4.cat /etc/sysconfig/network-scripts/ifcfg-eth0\r\n\r\n5.traceroute 第一行就是自己的网关\r\n\r\n6.ip route show\r\n```\r\n\r\n### 测试\r\n```\r\nping baidu.com\r\n```\r\n应该能成功\r\n\r\n\r\n### 安装sshd\r\n```\r\nyum clean all\r\nyum install openssh-server\r\n```\r\n\r\n### 虚拟机免密码登录\r\n```\r\nssh-keygen -t rsa\r\nvim .ssh/authorized_keys\r\n添加要登录的id_rsa.pub\r\nchmod 700 .ssh/authorized_keys\r\n```\r\n\r\n可以开始操作了\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2016/02/1547794873.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(139,'centos 安装samba服务，挂载目录','vm-install-samba',1456581643,1456581643,'<!--markdown-->方便在centos开发，安装samba\r\n\r\n\r\n<!--more-->\r\n\r\n### 注意防火墙\r\n\r\n### 安装\r\n```\r\nyum install samba samba-client samba-common -y\r\n```\r\n\r\n### 配置文件\r\n```\r\nvim /etc/samba/smb.conf\r\n[global]                                                  //该设置与Samba服务整体运行环境有关，它的设置项目针对所有共享资源       \r\n\r\n# ----------------------- Network Related Options -------------------------\r\n#\r\n# workgroup = NT-Domain-Name or Workgroup-Name, eg: MIDEARTH\r\n#\r\n# server string is the equivalent of the NT Description field\r\n#\r\n# netbios name can be used to specify a server name not tied to the hostname\r\n\r\n        workgroup = WORKGROUP                             //定义工作组，也就是windows中的工作组概念\r\n        server string = David Samba Server Version %v     //定义Samba服务器的简要说明\r\n        netbios name = DavidSamba                         //定义windows中显示出来的计算机名称\r\n\r\n# --------------------------- Logging Options -----------------------------\r\n#\r\n# Log File let you specify where to put logs and how to split them up.\r\n\r\n        log file = /var/log/samba/log.%m                  //定义Samba用户的日志文件，%m代表客户端主机名\r\n                                                          //Samba服务器会在指定的目录中为每个登陆主机建立不同的日志文件\r\n# ----------------------- Standalone Server Options ------------------------\r\n#\r\n# Scurity can be set to user, share(deprecated) or server(deprecated)\r\n\r\n        security = share                                  //共享级别，用户不需要账号和密码即可访问\r\n\r\n#============================ Share Definitions ==============================\r\n\r\n[homes]\r\n        comment = Home Directories\r\n        browseable = no\r\n        public = yes\r\n        writable = yes\r\n        valid users = %S\r\n; valid users = MYDOMAIN\\%S\r\n\r\n[public]\r\n        comment = Public Stuff\r\n        path = /home/share\r\n        public = yes \r\n``` \r\n\r\n### 配置用户\r\n```\r\nsandy 为系统用户\r\nsmbpasswd -a sandy\r\n```\r\n\r\n### 重启及其他命令\r\n```\r\n/etc/init.d/smb restart\r\n/etc/init.d/nmb restart\r\n加入开机\r\n chkconfig --level 35 smb on\r\n配置重载\r\nservice smb reload\r\n\r\n测试配置文件\r\ntestparm\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(140,'[转]浅谈千万级PV/IP规模高性能高并发网站架构','high-concurrency',1456660860,1456661039,'<!--markdown-->高并发访问的核心原则其实就一句话“把所有的用户访问请求都尽量往前推”。\r\n\r\n如果把来访用户比作来犯的\"敌人\"，我们一定要把他们挡在800里地以外，即不能让他们的请求一下打到我们的指挥部（指挥部就是数据库及分布式存储）。 如：能缓存在用户电脑本地的，就不要让他去访问CDN。 能缓存CDN服务器上的，就不要让CDN去访问源（静态服务器）了。能访问静态服务器的，就不要去 访问动态服务器。以此类推：能不访问数据库和存储就一定不要去访问数据库和存储。\r\n\r\n说起来很轻松，实际做起来却不容易，但只要稍加努力是可以做到的，Google的日独立IP过亿不也做到了么？我们这几千万的PV站比起Google不是小巫见 大巫了。我们还是先从我们的小屋搭起吧！下面内容的介绍起点是千万级别的PV站，也可以支持亿级PV的网站架构。\r\n\r\n高性能高并发高可扩展网站架构访问的几个层次： 有人会问，我们老是说把用户对业务的访问往前推，到底怎么推啊？推到哪呢？下面，老男孩就为大家一一道来。\r\n\r\n\r\n<!--more-->\r\n\r\n\r\n### 第一层：首先在用户浏览器端，使用Apache的mod_deflate压缩传输，再比如：expires功能、deflate和expires功能利用的好，就会大大提升用户 体验效果及减少网站带宽，减少后端服务器的压力。当然，方法还有很多，这里不一一细谈了。\r\n\r\n提示：有关压缩传输及expires功能nginx/lighttpd等软件同样也有。\r\n\r\n### 第二层：页面元素，如图片/js/css等或静态数据html，这个层面是网页缓存层,比如CDN（效果比公司自己部署squid/nginx要好，他们更专业，价 格低廉，比如快网/CC等（价格80元/M/月甚至更低）而且覆盖的城市节点更多），自己架设squid/nginx cache来做小型CDN是次选(超大规模的公 司可能会考虑风险问题实行自建加购买服务结合)，除非是为前端的CDN提供数据源服务，以减轻后端我们的服务器数据及存储压力，而不是直接提 供cache服务给最终用户。taobao的CDN曾经因为一部分图片的次寸大而导致CDN压力大的情况，甚至对图片尺寸大的来改小，以达到降低流量及带 宽的作用。\r\n\r\n提示：我们也可以自己架设一层cache层，对我们购买的CDN提供数据源服务，可用的软件有varnish/nginx/squid 等cache，以减轻第三层静态 数据层的压力。在这层的前端我们也可以架设DNS服务器，来达到跨机房业务拓展及智能解析的目的。\r\n\r\n### 第三层：静态服务器层一般为图片服务器，视频服务器，静态HTML服务器。这一层是前面缓存层和后面动态服务器层的连接纽带，大公司发布新闻 等内容直接由发布人员分发到各cache节点（sina,163等都是如此），这和一般公司的业务可能不一样。所以，没法直接的参考模仿，比如人人的SNS。\r\n\r\n我们可以使用Q队列方式实现异步的分发访问，同时把动态发布数据（数据库中的数据）静态化存储。即放到本层访问，或通过其他办法发布到各 cache节点，而不是直接让所有用户去访问数据库，不知道大家发现了没有，qq.com门户的新闻评论多的有几十万条，如果所有用户一看新闻就加载 所有评论，那数据库不挂才怪。他们的评论需要审核（美其名约，实际是异步的方式，而且，评论可能都是静态化的或类似的静态化或内存cache的 方式），这点可能就是需要51cto.com这样站点学习的，你们打开51CTO的一篇博文，就会发现下面的评论一直都显示出来了，也可能是分页的。不过， 应该都是直接读库的，一旦访问量大，数据库压力大是必然。这里不是说51cto网站不好，所有的网站都是从类似的程序架构开始发展的。CU也可能 是如此。\r\n\r\n提示：我们可以在静态数据层的前端自己架设一层cache层，对我们购买的CDN提供数据源服务，可用的软件有varnish/nginx/squid 等cache。 在这层的前端我们也可以架设DNS服务器，来达到跨机房业务拓展及智能解析的目的。\r\n\r\n### 第四层：动态服务器层：php,java等，只有透过了前面3层后的访问请求才会到这个层，才可能会访问数据库及存储设备。经过前三层的访问过滤 能到这层访问请求一般来说已非常少了，一般都是新发布的内容和新发布内容第一次浏览如；博文（包括微博等），BBS帖子。\r\n\r\n特别提示：此层可以在程序上多做文章，比如向下访问cache层，memcache,memcachedb,tc,mysql,oracle，在程序级别实现分布式访问，分布式 读写分离，而程序级别分布式访问的每个db cache节点，又可以是一组业务或者一组业务拆分开来的多台服务器的负载均衡。这样的架构会为后面 的数据库和存储层大大的减少压力，那么这里呢，相当于指挥部的外层了。\r\n\r\n### 第五层：数据库cache层，比如：memcache,memcachedb,tc等等。根据不同的业务需求，选择适合具体业务的数据库。对于memcache、memcachedb、 ttserver及相关nosql数据库，可以在第四层通过程序来实现对本层实现分布式访问，每个分布式访问的节点都可能是一组负载均衡（数十台机器）。\r\n### 第六层：数据库层，一般的不是超大站点都会用mysql主从结构，如：163,sina,kaixin都是如此，程序层做分布式数据库读写分离，一主（或双主） 多从的方式，访问大了，可以做级连的主从及环状的多主多从，然后，实现多组负载均衡，供前端的分布式程序调用，如果访问量在大，就需要拆业 务了，比如：我再给某企业做兼职时，发现类似的51cto的一个站点，把www服务,blog服务，bbs服务都放一个服务器上，然后做主从。这种情况， 当业务访问量大了，可以简单的把www,blog,bbs服务分别各用一组服务器拆分开，这种方式运维都会的没啥难度。当然访问量在大了，可以继续针 对某一个服务拆分如：www库拆分，每个库做一组负载均衡，还可以对库里的表拆分。需要高可用可以通过drbd等工具做成高可用方式。对于写大的， 可以做主主或多主的MYSQL REP方式，对于ORACLE来说，来几组oracle DG（1master多salve方式）就够了，11G的DG可以象mysql rep一样，支 持读写分离了。当然可选的方案还有，mysql cluster 和oracle 的RAC，玩mysql cluster和oracle RAC要需要更好更多的硬件及部署后的大量 维护成本，因此，要综合考虑，到这里访问量还很大，那就恭喜了，起码是几千万以上甚至上亿的PV了。\r\n\r\n象百度等巨型公司除了会采用常规的mysql及oracle数据库库外，会在性能要求更高的领域，大量的使用nosql数据库，然后前端在加DNS，负载均衡， 分布式的读写分离，最后依然是拆业务，拆库，。。。逐步细化，然后每个点又可以是一组或多组机器。\r\n\r\n特别提示：数据库层的硬件好坏也会决定访问量的多少，尤其是要考虑磁盘IO的问题，大公司往往在性价比上做文章，比如核心业务采用硬件 netapp/emc及san光纤架构，对于资源数据存储，如图片视频，会采用sas或固态ssd盘，如果数据超大，可以采取热点分取分存的方法， 如：最常访问的10-20%使用ssd存储，中间的20-30%采用sas盘，最后的40-50%可以采用廉价的sata。\r\n\r\n### 第七层：千万级PV的站如果设计的合理一些，1，2个NFS SERVER就足够了。我所维护（兼职）或经历过的上千万PV的用NFS及普通服务器做存储的 还有大把，多一些磁盘，如SAS 15K*6的，或者用dell6850，搞几组 NFS存储，中小网站足够了。当然可以做成drbd+heartbeat+nfs+a/a的方式。\r\n\r\n如果能达到本文设计要求的，中等规模网站，后端的数据库及存储压力会非常小了。 象门户网站级别，如sina等， 会采用硬件netapp/emc等等 硬件存储设备或是san光纤同道，甚至在性价比上做文章，比如核心业务采用硬件netapp/emc及san光纤架构，对于资源数据存储，如图片视频， 会采用sas或固态ssd盘，如果数据超到，可以采取热点分取分存的方法：如：最常访问的10-20%使用ssd存储，中间的20-30%采用sas盘，最后 的40-50%可以采用廉价的sata。\r\n\r\n象百度等巨型公司会采用hadoop等分布式的存储架构，前端在加上多层CACHE及多及的负载均衡，同样会根据业务进行拆分，比如爬虫层存储， 索引层存储，服务层存储。。。可以更细更细。。。为了应付压力，什么手段都用上了。 特殊业务，如人人，开心网，包括门户网站的评论， 微博，大多都是异步的写入方式，即无论读写，并发访问数据库都是非常少量的。\r\n\r\n以上1-7层，如果都搭好了，这样漏网到第四层动态服务器层的访问，就不多了。一般的中等站点，绝对不会对数据库造成太大的压力。程序层的分布式访问 是从千万及PV向亿级PV的发展，当然特殊的业务 还需要特殊架构，来合理利用数据库和存储。\r\n\r\n\r\n原文地址 http://blog.chinaunix.net/space.php?uid=26131888&do=blog&id=3034987',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(141,'wx.png','wx-png',1456740670,1456740670,'a:5:{s:4:\"name\";s:6:\"wx.png\";s:4:\"path\";s:35:\"/usr/uploads/2016/02/3439597528.png\";s:4:\"size\";i:252635;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',142),(142,'微信开发 -  1微信开发环境搭建','weixin-enviroment',1456740660,1456740723,'<!--markdown-->最近一直在开发微信，所以总结下\r\n目前移动开发处于比较火的的趋势,很多的开发者都跃跃欲试,目前移动App开发领域主要分为以下几种类型\r\n![wx.png][1]\r\n\r\n\r\n\r\n  [1]: http://blog.chromev.com/usr/uploads/2016/02/3439597528.png',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(143,'PHP命名空间及自动加载','php-namespace',1456752300,1456752407,'<!--markdown-->什么是命名空间呢？\r\n\r\n> 命名空间（英语：Namespace）表示标识符（identifier）的可见范围。一个标识符可在多个命名空间中定义，它在不同命名空间中的含义是互不相干的。这样，在一个新的命名空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其它命名空间中。\r\n\r\n简单说来命名空间是为了解决不同库在同一个环境下使用时出现的命名冲突。例如我自己有一个函数名叫A，但是系统已经有一个A函数了，那就会出现冲突。\r\n<!--more-->\r\n\r\n## PHP中的命名空间\r\n\r\nPHP从5.3版本开始引入了命名空间，之后许多现有PHP类库以及框架都开始支持它。那么PHP的命名空间怎么用呢？\r\n\r\n### 定义命名空间\r\n下面是一个定义命名空间的例子\r\n```\r\n<?php    \r\n//file a.php\r\nnamespace A;\r\n\r\nconst test = \'Atest\'; \r\n\r\nfunction test() { \r\n    return __FUNCTION__; \r\n}\r\n\r\nclass Test{\r\n    public function __construct(){\r\n        return __METHOD__;\r\n    }\r\n}\r\n?>\r\n```\r\n\r\n上面例子中就是一个典型的命名空间定义方法，只有const, function, class受命名空间的约束\r\n\r\n\r\n\r\n### 使用命名空间\r\n\r\n使用命名空间的方式如下：\r\n```\r\n<?php \r\nnamespace B;\r\nuse A;\r\n\r\nconst test = \'Btest\';\r\nfunction test() { \r\n    return __FUNCTION__; \r\n}\r\n\r\nclass Test{\r\n    public function __construct(){\r\n        return __METHOD__;\r\n    }\r\n}\r\n\r\ninclude \"a.php\";//必须包含A命名空间的文件\r\n\r\n// 完全限定\r\n// `\\B\\test`从绝对位置查找输出，如果是全局函数则`\\test`\r\necho \\B\\test;   //输出Btest\r\n\r\n// 限定名称  \r\n// 这里已经通过`use A`申明了在这个文件可以通过`\\A\\...`使用A命名空间的函数\r\necho A\\test;    //输出Atest\r\n\r\n// 非限定名称\r\n// 非限定名称的函数`test`会从当前命名控件查找，即B\r\necho test;      //输出Btest\r\n\r\n// namespace关键字代表当前命名空间\r\necho namespace/test;\r\n```\r\n\r\n首先要注意的是命名空间只起申明作用，也就是在使用了命名空间的时候依然得把这个命名空间申明的那个文件包含进来。在使用中可以通过__NAMESPACE__来查看当前命名空间。\r\n\r\n更多内容可以查看[PHP官方文档][1]\r\n\r\n### 自动加载\r\n每个文件既要申明命名控件又要手动include是非常不智能的事情，所以在自己的PHP系统或者框架中可以使用自动加载技术，让系统自己去找\r\n\r\n最简单的方式是利用函数__autoload函数，但是这个函数只能在非命名控件下定义，也就是全局情况下：\r\n\r\n```\r\nfunction __autoload($class) {\r\n  $dir = \'./\';\r\n  set_include_path(get_include_path().PATH_SEPARATOR.$ids_dir);\r\n  $class = str_replace(\'\\\\\', \'/\', $class) . \'.php\'; \r\n  require_once($class); \r\n}\r\n```\r\n\r\n如果在已经有了命名空间的类中，可以使用函数spl_autoload_register来注册一个类中的方法来代替__autoload\r\n\r\n\r\n\r\n\r\n  [1]: http://php.net/manual/zh/language.namespaces.basics.php',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(144,'你有什么相见恨晚的知识想推荐给年轻人','persist',1460594400,1470819933,'<!--markdown-->坚持锻炼身体，再忙俯卧撑不能断，尽量戒烟，少喝酒，早起一杯水，多吃水果，按时吃饭，多喝茶，吃饭想吃什么吃什么，但不要暴饮暴食，适度就好，学会调节自己的心态，不要让负面情绪占领自己心情的高地太久，少玩手机多看书、少年，我已经将自己人生最宝贵的东西给你了，最起码得点个赞再走吧\r\n\r\n**做你害怕做的事情。\r\n然后你会发现，不过如此。**\r\n\r\n\r\n\r\n**[不要纠结细节和完美的规划，重点在于是否开始了行动，即便每天只能抽出十分钟，那就从这十分钟开始吧][1]。**\r\n\r\n### **方法1：告别资源贪欲**\r\n“你下载了Sketch，不代表你就是设计师了；你下载了Sublime Text，不代表你就是前端工程师了；你下载了几个G的法语学习视频，不代表你就会法语了。你下载了扎克伯格2015年书单中所有书的电子版，不代表你就真的饱读诗书了。重要的是你的脑子里有什么，而不是你的硬盘里有什么。” \r\n\r\n\r\n### **方法2：做好心理建设**\r\n转变前：刚开始学习一个新主题时特别自信。一旦遇到困难，却又很快开始自我否定。\r\n转变：意识到学习是有不同阶段的，每个阶段都有其特点。\r\na. 初期：学习内容比较简单，容易产生“能力上的幻觉”。而这种幻觉会拔高了对下一阶段学习效果的期待值。\r\nb. 抬升期：学习曲线开始骤然陡峭，容易摧毁一个人的自信（大多数人于此时放弃）。此时学习需要更大的专注和时间投入。\r\nc. 平台期：长时间的投入却看不到明显的效果。这时需要更多寻找自己在学习中的问题，并进行有针对的训练，即所谓的 deliberate practice 。学习的平台期很难熬，但跨过就会宽阔。\r\n转变后：在每个学习阶段，都能合理地解读自己的情绪 (emotions)，形成正确的感受 (feelings)。比如，初期我会告诉自己，此时学得快，感到高兴是正常的，但要明白真正的挑战还未到来。抬升期我会告诉自己，此时因难度蹿升，产生恐惧是正常的，此时要对未来有信心，不要放弃。平台期我会告诉自己，长期看不到明显进步，容易沮丧也是正常的，此时要多寻求外界的帮助，多沉下心来做针对练习。\r\n\r\n### **方法3：量化学习时间**\r\n### **方法4：活用零碎时间**\r\n转变：在零碎时间会刷刷 duolingo ，听听高质量的播客，或者思考一些问题。\r\n转变后：零碎时间得到更好的利用，比如我的很多知乎答案都是利用独自吃饭，步行（注意看着点路），和等车的时间来理清文章结构的。\r\n### **方法5：控制饮食摄入**\r\n 转变：在要好好学习的晚上，晚饭会吃的比较简单，尽量多吃蔬菜少吃肉（尤其是红肉），有时甚至干脆不吃晚饭。\r\n 转变后：效果特别好，不再感到太多的疲乏，注意力比以前集中多了，遇到困难的学习任务时也不再轻易放弃。\r\n\r\n### 方法6：制作思维导图\r\n### 方法8：定期还原笔记\r\n### 方法9：寻找实践机会\r\n### 方法10：回顾学习成果\r\n\r\n### -----------------------------分割线-----------------------------\r\n当你把所有的事情当做任务来做，你是很难成功的。去挖掘自己想知道的东西，多思考点，这样才能更好玩点。\r\n\r\n在不了解之前，先别急着说不感兴趣。\r\n\r\n别为自己是个凡人而负疚。\r\n\r\n坚持不是没有中断，而是现在还在做。\r\n\r\n如果袜子买同样的颜色款式，早上拿的时候会容易很多。\r\n\r\n别为太久以后的事情发愁。\r\n\r\n自己的事情，要自己做决定。\r\n\r\n没有选择的时候，就只能前行。\r\n\r\n如果橘子很酸，换个角度吃，可能会觉得甜。\r\n\r\n早睡。\r\n\r\n多学几种运动。\r\n\r\n人生没有成功，只有顿挫和偶胜。\r\n\r\n要对得起别人，更要对得起自己。\r\n\r\n牙痛的时候，含两粒花椒，可以消肿止痛。\r\n\r\n没有过去和将来，只有现在。\r\n\r\n同一天，过的高兴，就赚了，过的郁闷，就亏了，过的浑浑噩噩，就没了。\r\n\r\n有所不为。\r\n\r\n在为浪费时间而后悔和自责时，你依然在浪费时间。\r\n\r\n逛街逛累了，可以去看电影。\r\n\r\n只试不买，心情不好，边逛边吃，才是王道。\r\n\r\n学会做饭。\r\n\r\n晚上少吃点，心情会很好。\r\n\r\n学个新东西，心情会很好。\r\n\r\n去跑两圈步，心情会很好。\r\n\r\n蛙泳游太久，小腿上的韧带可能受伤。\r\n\r\n技不压身。\r\n\r\n免费的东西，不一定便宜。\r\n\r\n对于没用的东西，最好的收纳方法，就是扔。\r\n\r\n学习资料找太多，就会有已经学了的错觉。\r\n\r\n运动装备买太好，就会有已经瘦了的错觉。\r\n\r\n如果吃点油腻的东西，就会拉肚子，可能减肥会有帮助。\r\n\r\n减肥的时候，要假设所有人都不想你成功，所有人都想破坏你的计划，包括爹妈。\r\n\r\n面试是低成本，高回报的事。\r\n\r\n低成本的事情谈不上失败，只有成功或不成功。\r\n\r\n没有万事俱备的时候，只有做，或者不做。\r\n\r\n不试，就不会有结果。\r\n\r\n一辈子，大概是三万天。\r\n\r\n作者：ze ran\r\n链接：https://www.zhihu.com/question/22238159/answer/42159279\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n![QQ图片20151217165311.jpg][2]\r\n\r\n![kkx.jpg][3]\r\n\r\n\r\n  [1]: https://www.zhihu.com/question/20406019/answer/101110297?group_id=715530270832340992\r\n  [2]: http://blog.chromev.com/usr/uploads/2016/05/4114459456.jpg\r\n  [3]: http://blog.chromev.com/usr/uploads/2016/06/1897672510.jpg',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(145,'QQ图片20151217165311.jpg','QQ图片20151217165311-jpg',1463379556,1463379556,'a:5:{s:4:\"name\";s:26:\"QQ图片20151217165311.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2016/05/4114459456.jpg\";s:4:\"size\";i:33010;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',144),(146,'kkx.jpg','kkx-jpg',1466647695,1466647695,'a:5:{s:4:\"name\";s:7:\"kkx.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2016/06/1897672510.jpg\";s:4:\"size\";i:271723;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',144),(147,'nginx location的匹配规则','nginx-location-match-rule',1488076320,1488078514,'<!--markdown-->### location匹配命令\r\n\r\n～ 执行正则表达式，区分大小写\r\n\r\n```\r\nlocation ~ \\.php($|/) {\r\n\r\n}\r\n```\r\n\r\n～* 执行正则表达式，不区分大小写\r\n```\r\n$http_referer ~* (baidu.com) {\r\n  return 403;\r\n}\r\n```\r\n^~ 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录     \r\n＝ 普通字符精通匹配 \r\n```\r\nlocation = /503.html {\r\n}\r\n```\r\n@ \"@\" 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files\r\n```\r\nerror_page 404 = @fallback\r\nlocation @fallback {\r\n}\r\n```\r\n\r\n### location 匹配的优先级(与location在配置文件中的顺序无关)\r\n= 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。\r\n普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。\r\n^~ 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。\r\n最后匹配理带有\"~\"和\"~*\"的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。\r\n\r\n\r\n优先级\r\n```\r\n\r\n\r\nlocation  = / {\r\n  # 只匹配\"/\".\r\n  [ configuration A ] \r\n}\r\nlocation  / {\r\n  # 匹配任何请求，因为所有请求都是以\"/\"开始\r\n  # 但是更长字符匹配或者正则表达式匹配会优先匹配\r\n  [ configuration B ] \r\n}\r\nlocation ^~ /images/ {\r\n  # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location\r\n  [ configuration C ] \r\n}\r\nlocation ~* .(gif|jpg|jpeg)$ {\r\n  # 匹配以 gif, jpg, or jpeg结尾的请求. \r\n  # 但是所有 /images/ 目录的请求将由 [Configuration C]处理.   \r\n  [ configuration D ] \r\n}\r\n```\r\n\r\n请求URI例子 顺序:\r\n\r\n/ -> 符合configuration A\r\n/documents/document.html -> 符合configuration B\r\n/images/1.gif -> 符合configuration C\r\n/documents/1.jpg ->符合 configuration D',0,1,NULL,'post','publish',NULL,0,'1','1','1',0),(149,'nginx location的匹配规则','@nginx-location-match-rule',1488076320,1488078904,'<!--markdown-->### location匹配命令\r\n\r\n～ 执行正则表达式，区分大小写\r\n\r\n```\r\nlocation ~ \\.php($|/) {\r\n\r\n}\r\n```\r\n\r\n～* 执行正则表达式，不区分大小写\r\n```\r\n$http_referer ~* (baidu.com) {\r\n  return 403;\r\n}\r\n```\r\n^~ 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录     \r\n＝ 普通字符精通匹配 \r\n```\r\nlocation = /503.html {\r\n}\r\n```\r\n@ \"@\" 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files\r\n```\r\nerror_page 404 = @fallback\r\nlocation @fallback {\r\n}\r\n```\r\n\r\n### location 匹配的优先级(与location在配置文件中的顺序无关)\r\n= 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。\r\n普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。\r\n^~ 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。\r\n最后匹配理带有\"~\"和\"~*\"的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。\r\n\r\n\r\n优先级\r\n```\r\n\r\n\r\nlocation  = / {\r\n  # 只匹配\"/\".\r\n  [ configuration A ] \r\n}\r\nlocation  / {\r\n  # 匹配任何请求，因为所有请求都是以\"/\"开始\r\n  # 但是更长字符匹配或者正则表达式匹配会优先匹配\r\n  [ configuration B ] \r\n}\r\nlocation ^~ /images/ {\r\n  # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location\r\n  [ configuration C ] \r\n}\r\nlocation ~* .(gif|jpg|jpeg)$ {\r\n  # 匹配以 gif, jpg, or jpeg结尾的请求. \r\n  # 但是所有 /images/ 目录的请求将由 [Configuration C]处理.   \r\n  [ configuration D ] \r\n}\r\n```\r\n\r\n请求URI例子 顺序:\r\n\r\n/ -> 符合configuration A\r\n/documents/document.html -> 符合configuration B\r\n/images/1.gif -> 符合configuration C\r\n/documents/1.jpg ->符合 configuration D',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',147);
/*!40000 ALTER TABLE `typecho_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_fields`
--

DROP TABLE IF EXISTS `typecho_fields`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_fields`
--

LOCK TABLES `typecho_fields` WRITE;
/*!40000 ALTER TABLE `typecho_fields` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_fields` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_metas`
--

DROP TABLE IF EXISTS `typecho_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM AUTO_INCREMENT=86 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_metas`
--

LOCK TABLES `typecho_metas` WRITE;
/*!40000 ALTER TABLE `typecho_metas` DISABLE KEYS */;
INSERT INTO `typecho_metas` VALUES (1,'Linux','Linux','category','Linux',43,1,0),(2,'PHP','php','category',NULL,23,4,0),(3,'C','C','category',NULL,3,2,0),(4,'Python','python','category','python',4,3,0),(5,'Javascript','javascript','category','javascript',3,5,0),(6,'solr','solr','tag',NULL,1,0,0),(7,'ik analyzer','ik-analyzer','tag',NULL,1,0,0),(8,'redis','redis','tag',NULL,4,0,0),(9,'pear','pear','tag',NULL,1,0,0),(10,'php','php','tag',NULL,13,0,0),(11,'安全','安全','tag',NULL,2,0,0),(12,'file','file','tag',NULL,1,0,0),(13,'mongo','mongo','tag',NULL,1,0,0),(14,'array','array','tag',NULL,2,0,0),(15,'symfony2','symfony2','category',NULL,3,6,0),(16,'symfony2','symfony2','tag',NULL,2,0,0),(17,'linux','linux','tag',NULL,2,0,0),(18,'yii','yii','tag',NULL,1,0,0),(19,'http','http','tag',NULL,1,0,0),(20,'framework','framework','tag',NULL,1,0,0),(21,'Mysql','mysql','category',NULL,1,7,0),(22,'mysql','mysql','tag',NULL,2,0,0),(23,'分页','分页','tag',NULL,1,0,0),(24,'javascript','javascript','tag',NULL,1,0,0),(25,'click','click','tag',NULL,1,0,0),(26,'doctrine','doctrine','tag',NULL,1,0,0),(27,'抽象类','抽象类','tag',NULL,1,0,0),(28,'接口','接口','tag',NULL,1,0,0),(29,'shell','shell','tag',NULL,1,0,0),(30,'人生','人生','tag',NULL,3,0,0),(31,'c','c','tag',NULL,2,0,0),(32,'find','find','tag',NULL,3,0,0),(33,'apple','apple','tag',NULL,1,0,0),(34,'apple','apple','category',NULL,1,8,0),(35,'io','io','tag',NULL,1,0,0),(36,'stdin','stdin','tag',NULL,1,0,0),(37,'stdout','stdout','tag',NULL,1,0,0),(38,'stderr','stderr','tag',NULL,1,0,0),(39,'php7','php7','tag',NULL,1,0,0),(40,'mount','mount','tag',NULL,1,0,0),(41,'df','df','tag',NULL,2,0,0),(42,'du','du','tag',NULL,1,0,0),(43,'git','git','tag',NULL,1,0,0),(44,'密码','密码','tag',NULL,1,0,0),(45,'数组','数组','tag',NULL,1,0,0),(46,'null','null','tag',NULL,1,0,0),(47,'ob_start','ob_start','tag',NULL,1,0,0),(48,'free','free','tag',NULL,1,0,0),(49,'gdb','gdb','tag',NULL,1,0,0),(50,'centos','centos','tag',NULL,4,0,0),(51,'samba','samba','tag',NULL,1,0,0),(52,'macos','macos','tag',NULL,1,0,0),(53,'centos7','centos7','tag',NULL,1,0,0),(54,'人生','人生','category',NULL,3,9,0),(55,'sphinx','sphinx','tag',NULL,1,0,0),(56,'coreseek','coreseek','tag',NULL,1,0,0),(57,'开源','开源','tag',NULL,1,0,0),(58,'iterm','iterm','tag',NULL,1,0,0),(59,'nginx','nginx','tag',NULL,2,0,0),(60,'nginx','nginx','category',NULL,1,10,0),(61,'正则表达式','正则表达式','tag',NULL,1,0,0),(62,'include','include','tag',NULL,1,0,0),(63,'require','require','tag',NULL,1,0,0),(64,'sshd','sshd','tag',NULL,1,0,0),(65,'my.cnf','my-cnf','tag',NULL,1,0,0),(66,'url','url','tag',NULL,1,0,0),(67,'dns','dns','tag',NULL,1,0,0),(68,'python3','python3','tag',NULL,1,0,0),(69,'jenkins','jenkins','tag',NULL,1,0,0),(70,'maven','maven','tag',NULL,1,0,0),(71,'java','java','tag',NULL,1,0,0),(72,'js','js','tag',NULL,1,0,0),(73,'closure','closure','tag',NULL,1,0,0),(74,'crawl','crawl','tag',NULL,1,0,0),(75,'python','python','tag',NULL,1,0,0),(76,'ip','ip','tag',NULL,1,0,0),(77,'ssh','ssh','tag',NULL,1,0,0),(78,'ifconfig','ifconfig','tag',NULL,1,0,0),(79,'smaba','smaba','tag',NULL,1,0,0),(80,'高并发','高并发','tag',NULL,1,0,0),(81,'架构','架构','tag',NULL,1,0,0),(82,'微信','weixin','category',NULL,0,11,0),(83,'微信','微信','tag',NULL,1,0,0),(84,'命名空间','命名空间','tag',NULL,1,0,0),(85,'学习','学习','tag',NULL,1,0,0);
/*!40000 ALTER TABLE `typecho_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_options`
--

DROP TABLE IF EXISTS `typecho_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_options`
--

LOCK TABLES `typecho_options` WRITE;
/*!40000 ALTER TABLE `typecho_options` DISABLE KEYS */;
INSERT INTO `typecho_options` VALUES ('theme',0,'default'),('theme:default',0,'a:2:{s:7:\"logoUrl\";N;s:12:\"sidebarBlock\";a:5:{i:0;s:15:\"ShowRecentPosts\";i:1;s:18:\"ShowRecentComments\";i:2;s:12:\"ShowCategory\";i:3;s:11:\"ShowArchive\";i:4;s:9:\"ShowOther\";}}'),('timezone',0,'28800'),('lang',0,NULL),('charset',0,'UTF-8'),('contentType',0,'text/html'),('gzip',0,'0'),('generator',0,'Typecho 1.0/14.10.10'),('title',0,'张忠旺的博客 - 思考，运动，学习，总结'),('description',0,'php,linux,c,python,javascript,系统架构,大数据分享博客'),('keywords',0,'linux,c,python,php,javascript,系统架构,大数据'),('rewrite',0,'1'),('frontPage',0,'recent'),('frontArchive',0,'0'),('commentsRequireMail',0,'1'),('commentsWhitelist',0,'0'),('commentsRequireURL',0,'0'),('commentsRequireModeration',0,'0'),('plugins',0,'a:2:{s:9:\"activated\";a:3:{s:18:\"GoogleCodePrettify\";a:1:{s:7:\"handles\";a:2:{s:21:\"Widget_Archive:header\";a:1:{i:0;a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"header\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"footer\";}}}}s:7:\"Smilies\";a:1:{s:7:\"handles\";a:2:{s:34:\"Widget_Abstract_Comments:contentEx\";a:1:{i:0;a:2:{i:0;s:14:\"Smilies_Plugin\";i:1;s:11:\"showsmilies\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:14:\"Smilies_Plugin\";i:1;s:8:\"insertjs\";}}}}s:6:\"Sticky\";a:1:{s:7:\"handles\";a:1:{s:26:\"Widget_Archive:indexHandle\";a:1:{i:0;a:2:{i:0;s:13:\"Sticky_Plugin\";i:1;s:6:\"sticky\";}}}}}s:7:\"handles\";a:4:{s:21:\"Widget_Archive:header\";a:1:{i:0;a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"header\";}}s:21:\"Widget_Archive:footer\";a:2:{i:0;a:2:{i:0;s:25:\"GoogleCodePrettify_Plugin\";i:1;s:6:\"footer\";}s:5:\"0.001\";a:2:{i:0;s:14:\"Smilies_Plugin\";i:1;s:8:\"insertjs\";}}s:34:\"Widget_Abstract_Comments:contentEx\";a:1:{i:0;a:2:{i:0;s:14:\"Smilies_Plugin\";i:1;s:11:\"showsmilies\";}}s:26:\"Widget_Archive:indexHandle\";a:1:{i:0;a:2:{i:0;s:13:\"Sticky_Plugin\";i:1;s:6:\"sticky\";}}}}'),('commentDateFormat',0,'F jS, Y \\a\\t h:i a'),('siteUrl',0,'http://blog.chromev.com'),('defaultCategory',0,'1'),('allowRegister',0,'0'),('defaultAllowComment',0,'1'),('defaultAllowPing',0,'1'),('defaultAllowFeed',0,'1'),('pageSize',0,'5'),('postsListSize',0,'10'),('commentsListSize',0,'10'),('commentsHTMLTagAllowed',0,NULL),('postDateFormat',0,'Y-m-d'),('feedFullText',0,'0'),('editorSize',0,'350'),('autoSave',0,'0'),('markdown',0,'1'),('commentsMaxNestingLevels',0,'5'),('commentsPostTimeout',0,'2592000'),('commentsUrlNofollow',0,'1'),('commentsShowUrl',0,'1'),('commentsMarkdown',0,'0'),('commentsPageBreak',0,'0'),('commentsThreaded',0,'1'),('commentsPageSize',0,'20'),('commentsPageDisplay',0,'last'),('commentsOrder',0,'ASC'),('commentsCheckReferer',0,'1'),('commentsAutoClose',0,'0'),('commentsPostIntervalEnable',0,'1'),('commentsPostInterval',0,'60'),('commentsShowCommentOnly',0,'0'),('commentsAvatar',0,'1'),('commentsAvatarRating',0,'G'),('commentsAntiSpam',0,'1'),('routingTable',0,'a:26:{i:0;a:25:{s:5:\"index\";a:6:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:8:\"|^[/]?$|\";s:6:\"format\";s:1:\"/\";s:6:\"params\";a:0:{}}s:7:\"archive\";a:6:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:13:\"|^/blog[/]?$|\";s:6:\"format\";s:6:\"/blog/\";s:6:\"params\";a:0:{}}s:2:\"do\";a:6:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:32:\"|^/action/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:10:\"/action/%s\";s:6:\"params\";a:1:{i:0;s:6:\"action\";}}s:4:\"post\";a:6:{s:3:\"url\";s:21:\"/archives/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:31:\"|^/archives/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:17:\"/archives/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:10:\"attachment\";a:6:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:28:\"|^/attachment/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/attachment/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:8:\"category\";a:6:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:25:\"|^/category/([^/]+)[/]?$|\";s:6:\"format\";s:13:\"/category/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:3:\"tag\";a:6:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:20:\"|^/tag/([^/]+)[/]?$|\";s:6:\"format\";s:8:\"/tag/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:6:\"author\";a:6:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:24:\"|^/author/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/author/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"uid\";}}s:6:\"search\";a:6:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:23:\"|^/search/([^/]+)[/]?$|\";s:6:\"format\";s:11:\"/search/%s/\";s:6:\"params\";a:1:{i:0;s:8:\"keywords\";}}s:10:\"index_page\";a:6:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/page/([0-9]+)[/]?$|\";s:6:\"format\";s:9:\"/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:12:\"archive_page\";a:6:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:27:\"|^/blog/page/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/blog/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:13:\"category_page\";a:6:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:34:\"|^/category/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:16:\"/category/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:8:\"tag_page\";a:6:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:29:\"|^/tag/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/tag/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:11:\"author_page\";a:6:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/author/([0-9]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/author/%s/%s/\";s:6:\"params\";a:2:{i:0;s:3:\"uid\";i:1;s:4:\"page\";}}s:11:\"search_page\";a:6:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:32:\"|^/search/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/search/%s/%s/\";s:6:\"params\";a:2:{i:0;s:8:\"keywords\";i:1;s:4:\"page\";}}s:12:\"archive_year\";a:6:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:19:\"|^/([0-9]{4})[/]?$|\";s:6:\"format\";s:4:\"/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"year\";}}s:13:\"archive_month\";a:6:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([0-9]{4})/([0-9]{2})[/]?$|\";s:6:\"format\";s:7:\"/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:5:\"month\";}}s:11:\"archive_day\";a:6:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:41:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|\";s:6:\"format\";s:10:\"/%s/%s/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";}}s:17:\"archive_year_page\";a:6:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/([0-9]{4})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:12:\"/%s/page/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:4:\"page\";}}s:18:\"archive_month_page\";a:6:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:44:\"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/%s/%s/page/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:4:\"page\";}}s:16:\"archive_day_page\";a:6:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:55:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"/%s/%s/%s/page/%s/\";s:6:\"params\";a:4:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";i:3;s:4:\"page\";}}s:12:\"comment_page\";a:6:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:36:\"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"%s/comment-page-%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:11:\"commentPage\";}}s:4:\"feed\";a:6:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";s:4:\"regx\";s:17:\"|^/feed(.*)[/]?$|\";s:6:\"format\";s:7:\"/feed%s\";s:6:\"params\";a:1:{i:0;s:4:\"feed\";}}s:8:\"feedback\";a:6:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:29:\"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:5:\"%s/%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:4:\"type\";}}s:4:\"page\";a:6:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:8:\"/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}}s:5:\"index\";a:3:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"archive\";a:3:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:2:\"do\";a:3:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";}s:4:\"post\";a:3:{s:3:\"url\";s:21:\"/archives/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"attachment\";a:3:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"category\";a:3:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:3:\"tag\";a:3:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"author\";a:3:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"search\";a:3:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"index_page\";a:3:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_page\";a:3:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"category_page\";a:3:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"tag_page\";a:3:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"author_page\";a:3:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"search_page\";a:3:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_year\";a:3:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"archive_month\";a:3:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"archive_day\";a:3:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:17:\"archive_year_page\";a:3:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:18:\"archive_month_page\";a:3:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:16:\"archive_day_page\";a:3:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"comment_page\";a:3:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:4:\"feed\";a:3:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";}s:8:\"feedback\";a:3:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";}s:4:\"page\";a:3:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}}'),('actionTable',0,'a:0:{}'),('panelTable',0,'a:0:{}'),('attachmentTypes',0,'@image@'),('secret',0,'KRBDaT!FMDy3aXgnQJ9I90ozzgCT$TyD'),('plugin:GoogleCodePrettify',0,'a:2:{s:4:\"type\";s:16:\"sons-of-obsidian\";s:6:\"custom\";s:0:\"\";}'),('plugin:Smilies',0,'a:4:{s:10:\"smiliesset\";s:10:\"wp-smilies\";s:8:\"allowpop\";s:1:\"0\";s:6:\"jqmode\";s:1:\"0\";s:6:\"jqhost\";N;}'),('editorSize',1,'653'),('plugin:Sticky',0,'a:2:{s:11:\"sticky_cids\";s:3:\"144\";s:11:\"sticky_html\";s:40:\"<span style=\'color:red\'>[置顶] </span>\";}');
/*!40000 ALTER TABLE `typecho_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_relationships`
--

DROP TABLE IF EXISTS `typecho_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_relationships`
--

LOCK TABLES `typecho_relationships` WRITE;
/*!40000 ALTER TABLE `typecho_relationships` DISABLE KEYS */;
INSERT INTO `typecho_relationships` VALUES (6,1),(6,6),(6,7),(17,1),(18,4),(19,1),(20,1),(21,1),(21,8),(22,1),(22,2),(23,1),(23,8),(24,1),(24,2),(24,8),(27,1),(28,2),(28,9),(28,10),(29,2),(29,10),(29,11),(30,2),(30,12),(31,1),(31,10),(31,13),(32,2),(32,14),(33,1),(33,2),(33,11),(34,2),(34,10),(34,15),(34,16),(34,17),(34,18),(34,19),(34,20),(35,1),(35,2),(35,10),(35,15),(35,16),(37,21),(37,22),(37,23),(39,5),(39,24),(39,25),(41,15),(41,26),(45,1),(46,2),(46,27),(46,28),(47,1),(47,29),(54,1),(54,2),(54,3),(54,10),(54,17),(55,1),(55,30),(58,1),(58,2),(58,3),(58,10),(58,31),(59,1),(59,32),(60,1),(60,33),(60,34),(63,1),(63,35),(63,36),(63,37),(63,38),(70,1),(70,32),(71,2),(71,39),(72,1),(72,40),(72,41),(77,1),(77,41),(77,42),(78,1),(78,43),(79,2),(79,10),(79,44),(80,2),(80,45),(80,46),(81,2),(81,47),(82,1),(82,22),(82,32),(82,48),(83,1),(83,2),(83,3),(83,10),(83,31),(83,49),(83,50),(88,1),(88,51),(88,52),(88,53),(94,30),(94,54),(95,1),(95,50),(97,1),(97,10),(97,55),(97,56),(98,1),(102,2),(102,10),(103,54),(103,57),(105,1),(105,58),(106,1),(106,59),(106,60),(107,2),(107,61),(108,1),(112,2),(112,62),(112,63),(113,1),(113,64),(115,1),(116,1),(116,65),(117,2),(117,5),(117,66),(118,1),(118,67),(127,4),(127,68),(128,1),(128,69),(128,70),(128,71),(132,5),(132,72),(132,73),(133,2),(133,10),(133,14),(134,1),(134,4),(134,74),(135,1),(135,4),(135,8),(135,75),(138,1),(138,50),(138,76),(138,77),(138,78),(139,1),(139,50),(139,79),(140,1),(140,80),(140,81),(142,1),(142,83),(143,2),(143,10),(143,84),(144,30),(144,54),(144,85),(147,1),(147,59),(149,1),(149,59);
/*!40000 ALTER TABLE `typecho_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_users`
--

DROP TABLE IF EXISTS `typecho_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_users`
--

LOCK TABLES `typecho_users` WRITE;
/*!40000 ALTER TABLE `typecho_users` DISABLE KEYS */;
INSERT INTO `typecho_users` VALUES (1,'admin','$P$B32B0Y0lAggePcWeSgpfJYy428rVJc/','727271755@qq.com','http://blog.chromev.com','run',1425551739,1488111116,1488076121,'administrator','627e91d0f56e8752cfc14b11326e35f4');
/*!40000 ALTER TABLE `typecho_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-03-27 11:08:19
